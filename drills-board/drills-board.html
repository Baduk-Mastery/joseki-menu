<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Master – Drills Board (Core-Based)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    html, body{
      margin:0; padding:0; height:100%;
      overflow: hidden;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background-color:#1b1208;
      touch-action: none;
      overscroll-behavior:none;
    }

    /* ===== Core wood background root ===== */
    #core-root{
      --wood:url('../img/wood.jpg');
      position: absolute; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background-color:#1b1208;
      background-image: linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)), var(--wood);
      background-size:cover; background-position:center;
      background-repeat:no-repeat;
    }

    /* IMPORTANT: make inner interactive (old core had pointer-events:none) */
    #core-inner{
      width:min(92vw, 720px);
      margin:0 auto;
      z-index: 1;
      pointer-events: auto;

      display:flex;
      flex-direction:column;
      align-items:center;
    }

    #core-board-wrap{
      width:100%;
      max-width:720px;
      margin:0 auto;
      position: relative;
      pointer-events: auto;
    }

    #core-board{
      position:relative; width:100%;
      border-radius:10px; overflow:hidden;
      margin:0 auto;
      box-shadow: 0 18px 40px rgba(0,0,0,.32), 0 6px 16px rgba(0,0,0,.22);
      background:none;
      touch-action: none; user-select: none; -webkit-user-select: none;
      transform-origin: 0 0;
    }

    /* ===== Zoom out button (core reference) ===== */
    #zoom-exit-btn{
      position:fixed;
      left:14px;
      bottom:90px;

      width:120px;
      height:80px;
      border-radius:9px;

      background:rgba(148,163,184,.35);
      border:1px solid rgba(148,163,184,.85);
      box-shadow:0 6px 16px rgba(0,0,0,.55);

      display:none;
      cursor:pointer;
      z-index:99999;

      backdrop-filter:blur(2px);
      -webkit-tap-highlight-color:transparent;

      color:#e5e7eb;
      font-size:18px;
      font-weight:600;

      align-items:center;
      justify-content:center;
    }
    #zoom-exit-btn::after { content: ""; }

    #core-board.is-fullscreen{
      position: fixed;
      top: 0; left: 0;
      width: 100vw !important;
      height: 100vh !important;
      border-radius: 0 !important;
      box-shadow: none !important;
      z-index: 9999;
      margin: 0;
    }

    /* =========================
       Drills Topbar (old drills element)
       ========================= */
    #drill-topbar{
      max-width:720px;
      width:100%;
      margin:16px auto 10px;
      padding:0;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    /* Wood-style Back button – copied from old drills */
    .s-back{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;

      padding:6px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.40);

      font-size:14px;
      font-weight:800;
      line-height:1.1;
      color:#fff3cf;
      text-shadow:0 1px 0 rgba(120,60,20,.7);
      cursor:pointer;

      user-select:none;
      -webkit-user-select:none;
      -moz-user-select:none;
      -ms-user-select:none;
      -webkit-tap-highlight-color:transparent;

      background-image:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.12),
          rgba(255,255,255,.03) 38%,
          rgba(0,0,0,.14) 100%
        ),
        url('../img/wood.jpg');
      background-size:100% 100%, cover;
      background-position:center;
      background-repeat:no-repeat;

      filter:brightness(1.08) saturate(.96);

      box-shadow:
        0 3px 0 rgba(133,74,26,.85),
        0 8px 14px rgba(0,0,0,.45);

      transition:
        transform .08s ease-out,
        box-shadow .08s ease-out,
        filter .12s ease-out;
    }
    .s-back:hover{
      filter:brightness(1.12) saturate(.98);
      transform:translateY(-1px);
      box-shadow:
        0 4px 0 rgba(133,74,26,.9),
        0 10px 16px rgba(0,0,0,.48);
    }
    .s-back:active{
      filter:brightness(.97) saturate(.96);
      transform:translateY(2px);
      box-shadow:
        0 1px 0 rgba(120,60,20,.9),
        0 4px 8px rgba(0,0,0,.55);
    }

    /* =========================
       Blitz timer chip – from old drills
       ========================= */
    #blitz-timer{
      margin-left:auto;
      display:none; /* shown by JS in blitz mode */
      align-items:center;
      justify-content:center;

      padding:6px 12px;
      border-radius:8px;
      min-width:7ch;

      white-space:nowrap;
      text-align:center;

      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-weight:900;
      font-size:14px;
      line-height:1.1;
      letter-spacing:0.5px;

      color:#fff3cf;
      text-shadow:0 1px 0 rgba(0,0,0,.35);

      background:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.10),
          rgba(0,0,0,.18)
        ),
        rgba(0,0,0,.28);

      border:1px solid rgba(255,255,255,.35);

      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.12),
        0 4px 10px rgba(0,0,0,.35);

      cursor:default;
      user-select:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color:transparent;
    }

    /* =========================
       Drills bottom bar – old alignment fix
       ========================= */
    #drill-ctrls{
      max-width: 720px;
      width: 100%;
      box-sizing: border-box;
      margin: 14px auto 0;
      padding: 0 12px 18px;

      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 0;
    }

    /* Wood button skin for bottom bar (reuse old pbtn look) */
    #drill-ctrls .pbtn{
      position: relative;
      width: auto;
      justify-self: center;

      padding: 8px 24px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.40);

      font-size: 16px;
      font-weight: 800;
      line-height: 1.1;
      color: #fff3cf;
      text-shadow: 0 1px 0 rgba(120,60,20,.7);
      cursor: pointer;

      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-tap-highlight-color: transparent;

      background-image:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.12),
          rgba(255,255,255,.03) 38%,
          rgba(0,0,0,.14) 100%
        ),
        url('../img/wood.jpg');
      background-size: 100% 100%, cover;
      background-position: center;
      background-repeat: no-repeat;

      filter: brightness(1.08) saturate(.96);

      box-shadow:
        0 3px 0 rgba(133,74,26,.85),
        0 8px 14px rgba(0,0,0,.45);

      transition:
        transform .08s ease-out,
        box-shadow .08s ease-out,
        filter .12s ease-out;
    }

    #drill-ctrls .pbtn:hover{
      filter: brightness(1.12) saturate(.98);
      transform: translateY(-1px);
      box-shadow:
        0 4px 0 rgba(133,74,26,.9),
        0 10px 16px rgba(0,0,0,.48);
    }
    #drill-ctrls .pbtn:active{
      filter: brightness(.97) saturate(.96);
      transform: translateY(2px);
      box-shadow:
        0 1px 0 rgba(120,60,20,.9),
        0 4px 8px rgba(0,0,0,.55);
    }

    /* Center column */
    #drill-ctrls #dbtn-next{
      grid-column: 2;
      justify-self: center;
    }

    /* Right column */
    #drill-ctrls #drill-progress{
      grid-column: 3;
      justify-self: end;
      text-align: right;
      min-width: 60px;
      font-weight:800;
      opacity:.9;
      color:#fff3cf;
      text-shadow:0 1px 0 rgba(120,60,20,.7);
    }

    @media (max-width: 480px){
      #core-inner{ width: min(94vw, 720px); }
    }
  </style>

  <!-- WGo loader (same CDN you used) -->
  <script>
    (function ensureWGo(){
      if (window.WGo) return;
      var s = document.createElement('script');
      s.src = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754893285939x971907393576095400/wgo.min.js";
      s.async = true;
      document.head.appendChild(s);
    })();
  </script>

  <!-- Shared prefs store -->
  <script>
  (function(){
    var STORAGE_KEY = 'go_prefs';
    var GoPrefs = (window.GoPrefs = window.GoPrefs || {});
    try {
      var saved = localStorage.getItem(STORAGE_KEY);
      if (saved) Object.assign(GoPrefs, JSON.parse(saved) || {});
    } catch (e) {}

    if (typeof GoPrefs.josekiZoom === 'undefined')         GoPrefs.josekiZoom = true;
    if (typeof GoPrefs.soundOn === 'undefined')            GoPrefs.soundOn = true;
    if (typeof GoPrefs.highlightLast === 'undefined')      GoPrefs.highlightLast = true;
    if (typeof GoPrefs.disableAutoZoomOut === 'undefined') GoPrefs.disableAutoZoomOut = false;

    window.GoPrefsSave = function(){
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(GoPrefs)); } catch (e) {}
    };
  })();
  </script>

  <!-- Sound bridge -->
  <script>
  if (!window.StoneSFX) {
    window.StoneSFX = (() => {
      let pool = [], i = 0;
      function init(url, voices = 5){
        pool = Array.from({ length: voices }, () => {
          const a = new Audio(url); a.preload = 'auto'; a.volume = 0.35; return a;
        });
        const unlock = () => {
          pool.forEach(a => { try{ a.play().then(()=>a.pause()).catch(()=>{}); a.currentTime=0; }catch(e){} });
          window.removeEventListener('touchstart', unlock);
          window.removeEventListener('mousedown', unlock);
        };
        window.addEventListener('touchstart', unlock, { once:true });
        window.addEventListener('mousedown', unlock, { once:true });
      }
      function play(){
        if (!pool.length) return;
        const a = pool[i++ % pool.length];
        try { a.currentTime=0; a.playbackRate=0.97+Math.random()*0.06; a.play(); } catch(e){}
      }
      return { init, play };
    })();
  }
  if (!window._stoneSFXInit) { StoneSFX.init("../sound/click.mp3"); window._stoneSFXInit = true; }

  (function(){
    if (!window.StoneSFX || window._soundBridgeReady) return;
    window._soundBridgeReady = true;
    if (typeof StoneSFX.play === 'function' && !('_enabled' in StoneSFX)){
      StoneSFX._enabled = (window.GoPrefs ? !!window.GoPrefs.soundOn : true);
      const _origPlay = StoneSFX.play.bind(StoneSFX);
      StoneSFX.play = function(){ if (StoneSFX._enabled) _origPlay(); };
    }
  })();
  </script>
</head>

<body>

  <div id="core-root">
    <div id="core-inner">

      <!-- Top bar (from old drills) -->
      <div id="drill-topbar">
        <button id="dbtn-menu" class="s-back" type="button" aria-label="Back">← Back</button>
        <div id="blitz-timer" class="blitz-chip">0.0s</div>
      </div>

      <!-- Board -->
      <div id="core-board-wrap">
        <div id="core-board"></div>
      </div>

      <!-- Bottom controls (from old drills) -->
      <div id="drill-ctrls">
        <button id="dbtn-next" class="pbtn" type="button">Skip</button>
        <div id="drill-progress">1 / 1</div>
      </div>

    </div>
  </div>

  <!-- Core-style zoom out button -->
  <div id="zoom-exit-btn"></div>

<script>
(function(){
  var SIZE  = 19;
  var mount = document.getElementById('core-board');
  var wrap  = document.getElementById('core-board-wrap');
  var exitBtn = document.getElementById('zoom-exit-btn');

  // UI refs (old drills elements)
  var btnMenu = document.getElementById('dbtn-menu');
  var btnNext = document.getElementById('dbtn-next');
  var progEl  = document.getElementById('drill-progress');
  var timerEl = document.getElementById('blitz-timer');

  var board = null;

  // ===== Lightweight selection reader (shared for mode + line loading) =====
  function readSelection(){
    try{
      var raw = sessionStorage.getItem('go:drills_next_selection');
      return raw ? JSON.parse(raw) : null;
    }catch(e){
      return null;
    }
  }

  function readSelectionMode(){
    var obj = readSelection();
    return (obj && obj.mode === 'blitz') ? 'blitz' : 'complete';
  }

  var blitzMode = (readSelectionMode() === 'blitz');
  // ===== Drills selection + SGF bridge (minimal, no transforms) =====
  var SGF_URL = "../sgf/library-1.sgf";
  var MIN_MOVES = 10;

  // Small visual preview so you can verify selection is respected.
  // Increase or set to 0 if you want an empty-start preview.
  var PREVIEW_MOVES = 8;

  var selectedLines = [];
  var selIndex = 0;

  var OWN_STORE_KEY = 'go:ownpatterns';
  var FAV_KEY       = 'go_favorites';

  function loadOwnPatterns(){
    try { return JSON.parse(localStorage.getItem(OWN_STORE_KEY) || '[]'); }
    catch(_){ return []; }
  }
  function readFavs(){
    try { return JSON.parse(localStorage.getItem(FAV_KEY) || '{}') || {}; }
    catch(_){ return {}; }
  }

  function normalizeLineLike(obj){
    return {
      size: obj.size || 19,
      rootAB: Array.isArray(obj.rootAB) ? obj.rootAB : [],
      rootAW: Array.isArray(obj.rootAW) ? obj.rootAW : [],
      moves:  (obj.moves || []).map(function(m){
        return { x:m.x, y:m.y, color:(m.color === 'W' ? 'W' : 'B') };
      })
    };
  }

  function lineKey(line){
    var size = line.size || 19;
    var moves = line.moves || [];
    var seq = moves.map(function(m){
      var c = (m.color || 'B')[0];
      return c + ':' + m.x + ',' + m.y;
    }).join('|');
    return size + '|' + seq;
  }

  // --- SGF utils (ported from old drills board) ---
  function rb(str,i){
    var out = '', k = i;
    while(k < str.length){
      var ch = str[k++];
      if(ch === '\\'){
        if(k < str.length) out += str[k++];
        continue;
      }
      if(ch === ']') break;
      out += ch;
    }
    return { t: out, n: k };
  }

  function parseTree(str,i){
    var seq = [], node = null;
    if(str[i] !== '(') return { seq: [], n: i };
    i++;
    while(i < str.length){
      var ch = str[i];
      if(ch === ';'){
        node = {};
        seq.push(node);
        i++;
      } else if(/[A-Za-z]/.test(ch)){
        var key = '';
        while(/[A-Za-z]/.test(str[i] || '')) key += str[i++];
        var vals = [];
        while(str[i] === '['){
          var r = rb(str, i+1);
          vals.push(r.t);
          i = r.n;
        }
        if(!node){
          node = {};
          seq.push(node);
        }
        node[key] = (vals.length > 1) ? vals : vals[0];
      } else if(ch === '('){
        var child = parseTree(str,i);
        i = child.n;
        if(seq.length){
          var p = seq[seq.length-1];
          (p.variations || (p.variations=[])).push(child.seq);
        }
      } else if(ch === ')'){
        i++;
        break;
      } else {
        i++;
      }
    }
    for(var k=0; k<seq.length-1; k++) seq[k].next = seq[k+1];
    return { seq: seq, n: i };
  }

  function parseAllTrees(str){
    var trees = [];
    if (str && str.charCodeAt && str.charCodeAt(0) === 0xFEFF) str = str.slice(1);
    var i = str.indexOf('(');
    while(i >= 0 && i < str.length){
      var r = parseTree(str,i);
      if(r.seq && r.seq.length) trees.push(r.seq);
      var nxt = str.indexOf('(', r.n);
      if(nxt === -1) break;
      i = nxt;
    }
    return trees;
  }

  function parseSZ(sz){
    if(!sz) return 19;
    if(typeof sz === 'string'){
      var n = parseInt(sz.split(':')[0], 10);
      return (n >= 2 && n <= 52) ? n : 19;
    }
    return 19;
  }

  function xy(s,S){
    if(!s || s.length < 2) return null;
    var x = s.charCodeAt(0) - 97;
    var y = s.charCodeAt(1) - 97;
    if(x < 0 || y < 0 || x >= S || y >= S) return null;
    return { x:x, y:y };
  }

  function nodeMove(n,S){
    if(!n) return null;
    if(n.B){
      var pB = xy(n.B, S);
      if(pB) return { x:pB.x, y:pB.y, color:'B' };
    }
    if(n.W){
      var pW = xy(n.W, S);
      if(pW) return { x:pW.x, y:pW.y, color:'W' };
    }
    return null;
  }

  function listCoords(prop,S){
    var arr = Array.isArray(prop) ? prop : (prop ? [prop] : []);
    var out = [];
    for(var i=0; i<arr.length; i++){
      var p = xy(arr[i], S);
      if(p) out.push(p);
    }
    return out;
  }

  function linkify(seq,parent){
    for(var i=0; i<seq.length; i++){
      var n = seq[i];
      n.prev = (i === 0 ? parent : seq[i-1]);
      n.next = (i < seq.length-1 ? seq[i+1] : null);
      if(n.variations){
        for(var v=0; v<n.variations.length; v++){
          var child = n.variations[v];
          if(child && child.length) linkify(child, n);
        }
      }
    }
  }

  function enumerateLines(seq,S){
    var lines = [];
    var start = seq && seq[0];
    while(start && !nodeMove(start,S) && !start.variations) start = start.next;

    function dfs(node, acc){
      if(!node){
        lines.push(acc.slice());
        return;
      }
      acc.push(node);

      if(node.variations && node.variations.length){
        for(var v=0; v<node.variations.length; v++){
          var branch = node.variations[v];
          var f = branch && branch[0];
          while(f && !nodeMove(f,S) && !f.variations) f = f.next;
          if(f) dfs(f, acc.slice());
        }
      }

      if(node.next){
        var nx = node.next;
        while(nx && !nodeMove(nx,S) && !nx.variations) nx = nx.next;
        if(nx) dfs(nx, acc);
        else lines.push(acc.slice());
      } else {
        lines.push(acc.slice());
      }
    }

    if(start) dfs(start, []);
    return lines.map(function(nodes){
      var ms = [];
      for(var i=0; i<nodes.length; i++){
        var mv = nodeMove(nodes[i], S);
        if(mv) ms.push(mv);
      }
      return ms;
    });
  }

  function fetchLibraryLines(){
    return fetch(SGF_URL, { cache:'no-cache' })
      .then(function(r){ return r.text(); })
      .then(function(txt){
        var trees = parseAllTrees(txt);
        var lines = [];
        for(var s=0; s<trees.length; s++){
          var seq = trees[s];
          linkify(seq, null);
          var size = parseSZ(seq[0] && seq[0].SZ);
          var rootAB = listCoords(seq[0] && seq[0].AB, size);
          var rootAW = listCoords(seq[0] && seq[0].AW, size);
          var paths = enumerateLines(seq, size);
          for(var p=0; p<paths.length; p++){
            var moves = paths[p];
            if((moves && moves.length || 0) >= MIN_MOVES){
              lines.push({ size:size, rootAB:rootAB, rootAW:rootAW, moves:moves });
            }
          }
        }
        return lines;
      });
  }

  function buildSelectedLines(){
    var sel = readSelection();

    var hasLib = sel && Array.isArray(sel.library)   && sel.library.length;
    var hasFav = sel && Array.isArray(sel.favorites) && sel.favorites.length;
    var hasOwn = sel && Array.isArray(sel.own)       && sel.own.length;

    // If nothing selected, fall back to full library (old behavior).
    if(!hasLib && !hasFav && !hasOwn){
      return fetchLibraryLines().catch(function(){ return []; });
    }

    var favPick = [];
    if(hasFav){
      var favMap = readFavs();
      var favLines = Object.keys(favMap).map(function(k){ return favMap[k]; }).map(normalizeLineLike);
      favPick = favLines.filter(function(l){
        return sel.favorites.indexOf(lineKey(l)) !== -1;
      });
    }

    var ownPick = [];
    if(hasOwn){
      var ownAll = loadOwnPatterns();
      ownPick = ownAll
        .filter(function(p){ return sel.own.indexOf(p.id) !== -1; })
        .map(normalizeLineLike);
    }

    if(hasLib){
      return fetchLibraryLines()
        .then(function(allLib){
          var libPick = allLib.filter(function(l){
            return sel.library.indexOf(lineKey(l)) !== -1;
          });
          return libPick.concat(favPick, ownPick);
        })
        .catch(function(){
          return favPick.concat(ownPick);
        });
    }

    return Promise.resolve(favPick.concat(ownPick));
  }

  function applyLinePreview(line){
    resetGame();
    if(!line) { redrawBoard(); return; }

    // Root setup stones
    var ab = line.rootAB || [];
    var aw = line.rootAW || [];
    for(var i=0; i<ab.length; i++){
      var p = ab[i];
      if(p && p.x>=0 && p.x<SIZE && p.y>=0 && p.y<SIZE){
        grid[p.y][p.x] = 'B';
      }
    }
    for(var j=0; j<aw.length; j++){
      var q = aw[j];
      if(q && q.x>=0 && q.x<SIZE && q.y>=0 && q.y<SIZE){
        grid[q.y][q.x] = 'W';
      }
    }

    // Preview N moves from the original line (no transforms)
    var moves = line.moves || [];
    var n = Math.min(PREVIEW_MOVES, moves.length);
    for(var k=0; k<n; k++){
      var m = moves[k];
      if(m && m.x>=0 && m.x<SIZE && m.y>=0 && m.y<SIZE){
        grid[m.y][m.x] = (m.color === 'W') ? 'W' : 'B';
        lastMove = { x:m.x, y:m.y };
      }
    }

    if(n){
      var lastC = moves[n-1].color;
      turn = (lastC === 'B') ? 'W' : 'B';
    } else {
      turn = 'B';
    }

    koPoint = null;
    redrawBoard();
  }

  function loadSelectedLine(i){
    if(!selectedLines.length){
      if (progEl) progEl.textContent = '1 / 1';
      resetGame();
      return;
    }
    selIndex = i;
    if(selIndex < 0) selIndex = 0;
    if(selIndex >= selectedLines.length) selIndex = 0;

    applyLinePreview(selectedLines[selIndex]);

    if (progEl){
      progEl.textContent = (selIndex + 1) + ' / ' + selectedLines.length;
    }
  }

  function initSelections(){
    buildSelectedLines().then(function(lines){
      selectedLines = (lines || []).map(normalizeLineLike);

      if(!selectedLines.length){
        if (progEl) progEl.textContent = '1 / 1';
        return;
      }

      loadSelectedLine(0);
    }).catch(function(){
      selectedLines = [];
      if (progEl) progEl.textContent = '1 / 1';
    });
  }


  // ===== Simple timer UI (stopwatch placeholder) =====
  var timerId = null;
  var timerStart = 0;

  function fmtMs(ms){
    if (ms < 0) ms = 0;
    var s = ms/1000;
    var m = Math.floor(s/60);
    var r = s - m*60;
    if (m > 0) {
      var sec = r.toFixed(1).padStart(4,'0');
      return m + ":" + sec;
    }
    return r.toFixed(1) + "s";
  }

  function startBlitzUI(){
    if (!blitzMode || !timerEl) return;
    timerEl.style.display = 'inline-flex';
    timerStart = performance.now();
    stopBlitzUI();
    timerId = setInterval(function(){
      var ms = performance.now() - timerStart;
      timerEl.textContent = fmtMs(ms);
    }, 100);
  }
  function stopBlitzUI(){
    if (timerId){ clearInterval(timerId); timerId = null; }
  }

  // ===== Core zoom engine state (unchanged) =====
  var scale = 1, minScale = 1, maxScale = 2.6;
  var offsetX = 0, offsetY = 0;
  var baseW = 0;
  var zoomLayer = null;
  var isFullscreen = false;
  var isZoomAnimating = false;
  var animId = 0;
  var returnAnchor = null;

  var isPanning = false, panStart = null, tapStart = null;
  var TAP_SLOP2 = 64;
  var isFlinging = false, flingId = 0, flingVX = 0, flingVY = 0, flingLastTime = 0;
  var panSamplePrev = null, panSampleCurr = null;

  // ===== Game state (simple core free-play) =====
  var grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
  var turn = 'B';
  var lastMove = null;
  var koPoint = null;

  // Settings
  var zoomEnabled = (window.GoPrefs && typeof window.GoPrefs.josekiZoom !== 'undefined') ? !!window.GoPrefs.josekiZoom : true;
  var highlightLastEnabled = (window.GoPrefs && typeof window.GoPrefs.highlightLast !== 'undefined') ? !!window.GoPrefs.highlightLast : true;
  var disableAutoZoomOut = (window.GoPrefs && typeof window.GoPrefs.disableAutoZoomOut !== 'undefined') ? !!window.GoPrefs.disableAutoZoomOut : false;

  window.addEventListener('go:prefs-changed', function(e){
    var d = e.detail || {};
    if (!d || typeof d.key === 'undefined') return;

    if (d.key === 'highlightLast') {
      highlightLastEnabled = !!d.value;
      try { redrawBoard(); } catch(_) {}
    } else if (d.key === 'josekiZoom') {
      zoomEnabled = !!d.value;
      if (!zoomEnabled && (isFullscreen || scale > 1)) {
        smoothZoomOutAndExit();
      }
    } else if (d.key === 'soundOn') {
      if (window.StoneSFX) StoneSFX._enabled = !!d.value;
    } else if (d.key === 'disableAutoZoomOut') {
      disableAutoZoomOut = !!d.value;
    }
  });

  // ===== Zoom layer wrapper for core =====
  function ensureZoomLayer(){
    if (zoomLayer) return;

    zoomLayer = document.createElement('div');
    zoomLayer.style.position = 'absolute';
    zoomLayer.style.left = '0px';
    zoomLayer.style.top = '0px';
    zoomLayer.style.transformOrigin = '0 0';
    zoomLayer.style.willChange = 'transform';

    while (mount.firstChild) zoomLayer.appendChild(mount.firstChild);
    mount.appendChild(zoomLayer);

    zoomLayer.style.backgroundImage = "url('../img/wood.jpg')";
    zoomLayer.style.backgroundSize = "cover";
    zoomLayer.style.backgroundPosition = "center";
    mount.style.background = "none";
  }

  function canvasCssScale(){
    var c = mount.querySelector('canvas');
    if (!c) return 1;
    var cssW = c.clientWidth || c.getBoundingClientRect().width || 0;
    var intW = c.width || 0;
    if (!cssW || !intW) return 1;
    return cssW / intW;
  }
  function getXcss(i){ return board.getX(i) * canvasCssScale(); }
  function getYcss(j){ return board.getY(j) * canvasCssScale(); }

  function viewportSize(){
    return { vw: mount.clientWidth, vh: mount.clientHeight };
  }

  function clampPan(){
    if (isZoomAnimating) return;
    var v = viewportSize();
    var vw = v.vw, vh = v.vh;
    var bw = Math.round(baseW * scale);

    var bleedX = Math.ceil(vw * 0.5);
    var bleedY = Math.ceil(vh * 0.5);

    var minOX = -bleedX;
    var maxOX = Math.max(0, bw - vw) + bleedX;
    var minOY = -bleedY;
    var maxOY = Math.max(0, bw - vh) + bleedY;

    offsetX = Math.max(minOX, Math.min(offsetX, maxOX));
    offsetY = Math.max(minOY, Math.min(offsetY, maxOY));
  }

  function applyPanAndSize(redrawAfter){
    var targetW = baseW;

    if (board && board._lastW !== targetW) {
      board.setWidth(targetW);
      if (zoomLayer) {
        zoomLayer.style.width = targetW + 'px';
        zoomLayer.style.height = targetW + 'px';
      }
      board._lastW = targetW;
      if (!redrawAfter) redrawAfter = true;
    }

    clampPan();

    if (zoomLayer) {
      zoomLayer.style.transform =
        'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';
    }

    if (redrawAfter) redrawBoard();
  }

  function animateTo(targetScale, pxWorld, pyWorld, sxTarget, syTarget, onDone){
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
    cancelFling();

    var s0 = scale, ox0 = offsetX, oy0 = offsetY;
    var t0 = performance.now();
    var dur = 300;

    cancelAnimationFrame(animId);
    isZoomAnimating = true;

    var targetOffsetX = (pxWorld * targetScale) - sxTarget;
    var targetOffsetY = (pyWorld * targetScale) - syTarget;

    (function step(now){
      var t = (now - t0) / dur;
      if (t > 1) t = 1;
      var e = 1 - Math.pow(1 - t, 3);

      scale = s0 + (targetScale - s0) * e;
      offsetX = ox0 + (targetOffsetX - ox0) * e;
      offsetY = oy0 + (targetOffsetY - oy0) * e;

      applyPanAndSize(false);

      if (t < 1){
        animId = requestAnimationFrame(step);
      } else {
        isZoomAnimating = false;
        applyPanAndSize(true);
        if (typeof onDone === 'function') onDone();
      }
    })(t0);
  }

  function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
    if (isFullscreen) return;
    cancelFling();

    returnAnchor = document.createElement('div');
    returnAnchor.style.width = mount.clientWidth + 'px';
    returnAnchor.style.height = mount.clientHeight + 'px';
    mount.parentNode.insertBefore(returnAnchor, mount);

    document.body.appendChild(mount);
    mount.classList.add('is-fullscreen');
    isFullscreen = true;
    exitBtn.style.display = 'flex';

    mount.style.width = '100vw';
    mount.style.height = '100vh';

    scale = 1; offsetX = 0; offsetY = 0;

    var vw = window.innerWidth;
    var vh = window.innerHeight;
    baseW = Math.floor(Math.min(vw, vh));
    if (baseW % 2) baseW--;

    requestAnimationFrame(function(){
      applyPanAndSize(true);

      var initialFactor = 2.4;
      var px_curr = getXcss(i);
      var py_curr = getYcss(j);

      var rect = mount.getBoundingClientRect();
      var sx = rect.width / 2;
      var sy = rect.height / 2;

      if (typeof tapClientX === 'number' && typeof tapClientY === 'number'){
        sx = tapClientX - rect.left;
        sy = tapClientY - rect.top;
      }

      offsetX = px_curr * 1.0 - sx;
      offsetY = py_curr * 1.0 - sy;
      applyPanAndSize(false);

      animateTo(initialFactor, px_curr, py_curr, sx, sy);
    });
  }

  function exitFullscreen(){
    cancelFling();
    cancelAnimationFrame(animId);
    isZoomAnimating = false;

    mount.classList.remove('is-fullscreen');
    exitBtn.style.display = 'none';
    isFullscreen = false;

    if (returnAnchor && returnAnchor.parentNode){
      returnAnchor.parentNode.insertBefore(mount, returnAnchor);
      returnAnchor.parentNode.removeChild(returnAnchor);
      returnAnchor = null;
    }

    mount.style.width = '';
    mount.style.height = '';

    fitBoard();
    resetViewLocal();
  }

  function resetViewLocal(){
    scale = 1; offsetX = 0; offsetY = 0;
    applyPanAndSize(true);
  }

  function smoothZoomOutAndExit(){
    if (!zoomEnabled) return;

    cancelFling();
    cancelAnimationFrame(animId);
    isZoomAnimating = false;

    scale = 1;
    offsetX = 0;
    offsetY = 0;

    applyPanAndSize(true);

    if (isFullscreen){
      exitFullscreen();
    }
  }

  function startFling(vx, vy){
    if (scale <= 1) return;
    cancelFling();

    var speed = Math.sqrt(vx*vx + vy*vy);
    var MAX_SPEED = 0.50;
    if (speed > MAX_SPEED){
      var s = MAX_SPEED / speed;
      vx *= s; vy *= s; speed = MAX_SPEED;
    }
    if (speed < 0.04) return;

    isFlinging = true;
    flingVX = vx; flingVY = vy;
    flingLastTime = performance.now();

    (function step(now){
      if (!isFlinging) return;
      var dt = now - flingLastTime;
      if (dt <= 0){
        flingId = requestAnimationFrame(step);
        return;
      }
      if (dt > 50) dt = 50;
      flingLastTime = now;

      offsetX += flingVX * dt;
      offsetY += flingVY * dt;

      var friction = 0.0010;
      var currentSpeed = Math.sqrt(flingVX*flingVX + flingVY*flingVY);
      var decel = friction * dt;

      if (currentSpeed <= 0.01 || decel >= currentSpeed){
        cancelFling();
        applyPanAndSize(true);
        return;
      }

      var newSpeed = currentSpeed - decel;
      var scaleFactor = newSpeed / currentSpeed;
      flingVX *= scaleFactor;
      flingVY *= scaleFactor;

      applyPanAndSize(false);
      flingId = requestAnimationFrame(step);
    })(performance.now());
  }

  function cancelFling(){
    isFlinging = false;
    if (flingId) { cancelAnimationFrame(flingId); flingId = 0; }
  }

  // ===== Simple KO logic from your core =====
  function getGroupStones(x, y){
    var color = grid[y][x];
    if (!color) return [];
    var stack = [[x,y]], seen = {}, stones = [];
    while(stack.length){
      var p = stack.pop();
      var k = p[0]+','+p[1];
      if(seen[k]) continue;
      seen[k]=true;
      stones.push({x:p[0], y:p[1]});
      [[0,1],[0,-1],[1,0],[-1,0]].forEach(function(d){
        var nx=p[0]+d[0], ny=p[1]+d[1];
        if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && grid[ny][nx]===color && !seen[nx+','+ny]){
          stack.push([nx,ny]);
        }
      });
    }
    return stones;
  }

  function countLiberties(x,y,c){
    var stack=[[x,y]], seen={}, libs=0;
    while(stack.length){
      var p=stack.pop(), k=p[0]+','+p[1];
      if(seen[k]) continue;
      seen[k]=true;
      [[0,1],[0,-1],[1,0],[-1,0]].forEach(function(d){
        var nx=p[0]+d[0], ny=p[1]+d[1];
        if(nx>=0&&nx<SIZE&&ny>=0&&ny<SIZE){
          var v=grid[ny][nx];
          if(v===null) libs++;
          else if(v===c && !seen[nx+','+ny]) stack.push([nx,ny]);
        }
      });
    }
    return libs;
  }

  function checkCapture(x, y){
    var color = grid[y][x];
    var stack = [[x,y]], seen = {};
    while(stack.length){
      var p = stack.pop();
      var k = p[0]+','+p[1];
      if(seen[k]) continue;
      seen[k]=true;

      var hasLib = false;
      [[0,1],[0,-1],[1,0],[-1,0]].forEach(function(d){
        var nx=p[0]+d[0], ny=p[1]+d[1];
        if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE){
          var v = grid[ny][nx];
          if(v===null) hasLib=true;
          else if(v===color && !seen[nx+','+ny]) stack.push([nx,ny]);
        }
      });
      if(hasLib) return false;
    }
    return true;
  }

  function removeGroup(x, y){
    var color = grid[y][x];
    var stack = [[x,y]], seen = {}, removed = [];
    while(stack.length){
      var p = stack.pop();
      var k = p[0]+','+p[1];
      if(seen[k]) continue;
      seen[k]=true;

      if (grid[p[1]][p[0]] === color){
        grid[p[1]][p[0]] = null;
        removed.push({x:p[0], y:p[1]});
      }

      [[0,1],[0,-1],[1,0],[-1,0]].forEach(function(d){
        var nx=p[0]+d[0], ny=p[1]+d[1];
        if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && grid[ny][nx]===color && !seen[nx+','+ny]){
          stack.push([nx,ny]);
        }
      });
    }
    return removed;
  }

  function playAt(x, y){
    if (x<0 || y<0 || x>=SIZE || y>=SIZE) return;
    if (grid[y][x] !== null) return;

    if (koPoint && koPoint.x === x && koPoint.y === y) return;

    var me = turn;
    var opp = (me === 'B') ? 'W' : 'B';

    grid[y][x] = me;

    var captured = [];
    var dirs = [[0,1],[0,-1],[1,0],[-1,0]];
    dirs.forEach(function(d){
      var nx=x+d[0], ny=y+d[1];
      if(nx>=0 && nx<SIZE && ny>=0 && ny<SIZE && grid[ny][nx]===opp){
        if (checkCapture(nx, ny)) {
          var removed = removeGroup(nx, ny);
          if (removed && removed.length) captured = captured.concat(removed);
        }
      }
    });

    if (countLiberties(x,y, me) === 0) {
      grid[y][x] = null;
      captured.forEach(function(p){ grid[p.y][p.x] = opp; });
      return;
    }

    if (captured.length === 1) {
      var myGroup = getGroupStones(x, y);
      if (myGroup.length === 1 && countLiberties(x, y, me) === 1) {
        koPoint = { x: captured[0].x, y: captured[0].y };
      } else {
        koPoint = null;
      }
    } else {
      koPoint = null;
    }

    turn = opp;
    lastMove = {x:x, y:y};

    try{ if(window.StoneSFX) StoneSFX.play(); }catch(e){}

    if (!disableAutoZoomOut && scale > 1) {
      setTimeout(smoothZoomOutAndExit, 10);
    }

    redrawBoard();
  }

  function redrawBoard(){
    if (!board) return;
    board.removeAllObjects();
    for(var y=0; y<SIZE; y++){
      for(var x=0; x<SIZE; x++){
        var v = grid[y][x];
        if(v==='B') board.addObject({x:x, y:y, c:WGo.B});
        if(v==='W') board.addObject({x:x, y:y, c:WGo.W});
      }
    }
    if (lastMove && highlightLastEnabled) {
      board.addObject({x:lastMove.x, y:lastMove.y, type:'CR'});
    }
  }

  // ===== Click binding from your core (kept) =====
  function bindClicks(){
    function getGridSpacing(){
      var sX = Math.abs(getXcss(1) - getXcss(0));
      var sY = Math.abs(getYcss(1) - getYcss(0));
      return { x: sX, y: sY };
    }

    mount.addEventListener('pointerdown', function(e){
      if (!zoomEnabled) return;
      if (e.pointerType !== 'touch' && e.button !== 0) return;
      cancelFling();

      var r = mount.getBoundingClientRect();
      var sx = e.clientX - r.left;
      var sy = e.clientY - r.top;

      var boardX = (sx + offsetX) / scale;
      var boardY = (sy + offsetY) / scale;

      var bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
      for (var i = 0; i < SIZE; i++){
        var dx = Math.abs(getXcss(i) - boardX);
        if (dx < bestDx){ bestDx = dx; bestI = i; }
      }
      for (var j = 0; j < SIZE; j++){
        var dy = Math.abs(getYcss(j) - boardY);
        if (dy < bestDy){ bestDy = dy; bestJ = j; }
      }

      var spacing = getGridSpacing();
      var limitX = spacing.x * 0.5;
      var limitY = spacing.y * 0.5;

      panStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY };
      panSamplePrev = panSampleCurr = null;
      try { mount.setPointerCapture(e.pointerId); } catch(_){}

      if (bestDx > limitX || bestDy > limitY) {
        tapStart = null;
        return;
      }

      tapStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY, gridI: bestI, gridJ: bestJ };
    }, {passive:false});

    mount.addEventListener('pointermove', function(e){
      if (!zoomEnabled) return;
      if (!panStart) return;
      if (scale <= 1.01 && !isFullscreen) return;

      var dx = e.clientX - panStart.x;
      var dy = e.clientY - panStart.y;

      if (!isPanning && (dx*dx + dy*dy > TAP_SLOP2)) isPanning = true;

      if (isPanning) {
        offsetX = panStart.ox - dx;
        offsetY = panStart.oy - dy;
        applyPanAndSize(false);
        e.preventDefault();

        var now = performance.now();
        panSamplePrev = panSampleCurr;
        panSampleCurr = { ox: offsetX, oy: offsetY, t: now };
      }
    }, {passive:false});

    mount.addEventListener('pointerup', function(e){
      if (!zoomEnabled) {
        var r = mount.getBoundingClientRect();
        var sx = e.clientX - r.left;
        var sy = e.clientY - r.top;
        var bx = sx, by = sy;

        var bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
        for (var i2=0; i2<SIZE; i2++){
          var dx2 = Math.abs(getXcss(i2) - bx);
          if (dx2<bestDx){ bestDx=dx2; bestI=i2; }
        }
        for (var j2=0; j2<SIZE; j2++){
          var dy2 = Math.abs(getYcss(j2) - by);
          if (dy2<bestDy){ bestDy=dy2; bestJ=j2; }
        }

        var spacing = getGridSpacing();
        if (bestDx > spacing.x * 0.5 || bestDy > spacing.y * 0.5) return;

        e.preventDefault();
        playAt(bestI, bestJ);
        return;
      }

      if (!tapStart) {
        if (panStart) {
          try { mount.releasePointerCapture(e.pointerId); } catch(_){}
          panStart = null;
        }
        return;
      }

      try { mount.releasePointerCapture(e.pointerId); } catch(_){}

      var dist2 = (e.clientX - tapStart.x)*(e.clientX - tapStart.x) + (e.clientY - tapStart.y)*(e.clientY - tapStart.y);
      var gridI = tapStart.gridI;
      var gridJ = tapStart.gridJ;
      var tapX = tapStart.x;
      var tapY = tapStart.y;

      tapStart = null; panStart = null;

      if (isPanning) {
        isPanning = false;
        if (panSamplePrev && panSampleCurr) {
          var dt = panSampleCurr.t - panSamplePrev.t;
          if (dt > 0 && dt < 120) {
            startFling((panSampleCurr.ox - panSamplePrev.ox)/dt, (panSampleCurr.oy - panSamplePrev.oy)/dt);
          }
        }
        return;
      }

      if (dist2 <= TAP_SLOP2) {
        e.preventDefault();
        if (scale <= 1.05 && !isFullscreen) {
          enterFullscreenAtGrid(gridI, gridJ, tapX, tapY);
        } else {
          playAt(gridI, gridJ);
        }
      }
    }, {passive:false});

    board.addEventListener('click', function(x, y){
      if (zoomEnabled && (isFullscreen || scale > 1)) return;
      playAt(x, y);
    });
  }

  // ===== Board setup =====
  function createBoard(){
    if (board || !window.WGo) return;
    board = new WGo.Board(mount, { size: SIZE, background: '' });
    ensureZoomLayer();
    fitBoard();
    redrawBoard();
    bindClicks();
    initSelections();

    exitBtn.addEventListener('click', function(e){
      e.stopPropagation();
      smoothZoomOutAndExit();
    });

    window.addEventListener('resize', fitBoard);
    window.addEventListener('orientationchange', function(){ setTimeout(fitBoard, 150); });
  }

  function fitBoard(){
    if (isFullscreen) return;
    var w = wrap.getBoundingClientRect().width;
    w = Math.floor(w); if(w%2) w--;
    baseW = w;
    mount.style.width = w+'px';
    mount.style.height = w+'px';
    applyPanAndSize(true);
  }

  function initWhenReady(){
    var tries = 0;
    (function wait(){
      if (window.WGo) createBoard();
      else if (tries++ < 120) setTimeout(wait, 50);
    })();
  }

  // ===== UI actions =====
  if (btnMenu){
    btnMenu.addEventListener('click', function(){
      try{ window.location.href = '../drills/drills.html'; }catch(e){}
    });
  }

  function resetGame(){
    grid = Array.from({ length: SIZE }, () => Array(SIZE).fill(null));
    turn = 'B';
    lastMove = null;
    koPoint = null;
    redrawBoard();
  }

  if (btnNext){
    btnNext.addEventListener('click', function(){
      if (selectedLines && selectedLines.length){
        loadSelectedLine(selIndex + 1);
      } else {
        resetGame();
        if (progEl) progEl.textContent = '1 / 1';
      }
    });
  }


  // Timer UI start
  if (blitzMode) startBlitzUI();
  else if (timerEl) timerEl.style.display = 'none';

  window.addEventListener('load', initWhenReady);
})();
</script>

</body>
</html>



