<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Master – Drills Board (Core-Based)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
    html, body{
      margin:0; padding:0; height:100%;
      overflow: hidden;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background-color:#1b1208;
      touch-action: none;
      overscroll-behavior:none;
    }

    /* ===== Core wood background root ===== */
    #core-root{
      --wood:url('../img/wood.jpg');
      position: absolute; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background-color:#1b1208;
      background-image: linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)), var(--wood);
      background-size:cover; background-position:center;
      background-repeat:no-repeat;
    }

    /* IMPORTANT: make inner interactive */
    #core-inner{
      width:min(92vw, 720px);
      margin:0 auto;
      z-index: 1;
      pointer-events: auto;

      display:flex;
      flex-direction:column;
      align-items:center;
    }

    #core-board-wrap{
      width:100%;
      max-width:720px;
      margin:0 auto;
      position: relative;
      pointer-events: auto;
    }

    #core-board{
      position:relative; width:100%;
      border-radius:10px; overflow:hidden;
      margin:0 auto;
      box-shadow: 0 18px 40px rgba(0,0,0,.32), 0 6px 16px rgba(0,0,0,.22);
      background:none;
      touch-action: none; user-select: none; -webkit-user-select: none;
      transform-origin: 0 0;
    }

    /* ===== Zoom out button (core reference) ===== */
    #zoom-exit-btn{
      position:fixed;
      left:14px;
      bottom:90px;

      width:120px;
      height:80px;
      border-radius:9px;

      background:rgba(148,163,184,.35);
      border:1px solid rgba(148,163,184,.85);
      box-shadow:0 6px 16px rgba(0,0,0,.55);

      display:none;
      cursor:pointer;
      z-index:99999;

      backdrop-filter:blur(2px);
      -webkit-tap-highlight-color:transparent;

      color:#e5e7eb;
      font-size:18px;
      font-weight:600;

      align-items:center;
      justify-content:center;
    }
    #zoom-exit-btn::after { content: ""; }

    #core-board.is-fullscreen{
      position: fixed;
      top: 0; left: 0;
      width: 100vw !important;
      height: 100vh !important;
      border-radius: 0 !important;
      box-shadow: none !important;
      z-index: 9999;
      margin: 0;
    }

    /* =========================
       Drills Topbar
       ========================= */
    #drill-topbar{
      max-width:720px;
      width:100%;
      margin:16px auto 10px;
      padding:0;
      box-sizing:border-box;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    /* Wood-style Back button */
    .s-back{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;

      padding:6px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.40);

      font-size:14px;
      font-weight:800;
      line-height:1.1;
      color:#fff3cf;
      text-shadow:0 1px 0 rgba(120,60,20,.7);
      cursor:pointer;

      user-select:none;
      -webkit-user-select:none;
      -moz-user-select:none;
      -ms-user-select:none;
      -webkit-tap-highlight-color:transparent;

      background-image:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.12),
          rgba(255,255,255,.03) 38%,
          rgba(0,0,0,.14) 100%
        ),
        url('../img/wood.jpg');
      background-size:100% 100%, cover;
      background-position:center;
      background-repeat:no-repeat;

      filter:brightness(1.08) saturate(.96);

      box-shadow:
        0 3px 0 rgba(133,74,26,.85),
        0 8px 14px rgba(0,0,0,.45);

      transition:
        transform .08s ease-out,
        box-shadow .08s ease-out,
        filter .12s ease-out;
    }
    .s-back:hover{
      filter:brightness(1.12) saturate(.98);
      transform:translateY(-1px);
      box-shadow:
        0 4px 0 rgba(133,74,26,.9),
        0 10px 16px rgba(0,0,0,.48);
    }
    .s-back:active{
      filter:brightness(.97) saturate(.96);
      transform:translateY(2px);
      box-shadow:
        0 1px 0 rgba(120,60,20,.9),
        0 4px 8px rgba(0,0,0,.55);
    }

    /* =========================
       Blitz timer chip
       ========================= */
    #blitz-timer{
      margin-left:auto;
      display:none; /* toggled by JS */
      align-items:center;
      justify-content:center;

      padding:6px 12px;
      border-radius:8px;
      min-width:7ch;

      white-space:nowrap;
      text-align:center;

      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-weight:900;
      font-size:14px;
      line-height:1.1;
      letter-spacing:0.5px;

      color:#fff3cf;
      text-shadow:0 1px 0 rgba(0,0,0,.35);

      background:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.10),
          rgba(0,0,0,.18)
        ),
        rgba(0,0,0,.28);

      border:1px solid rgba(255,255,255,.35);

      box-shadow:
        inset 0 1px 0 rgba(255,255,255,.12),
        0 4px 10px rgba(0,0,0,.35);

      cursor:default;
      user-select:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .blitz-chip{ }

    /* =========================
       Drills bottom bar alignment
       ========================= */
    #drill-ctrls{
      max-width: 720px;
      width: 100%;
      box-sizing: border-box;
      margin: 14px auto 0;
      padding: 0 12px 18px;

      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 0;
    }

    /* Wood button skin for bottom bar */
    #drill-ctrls .pbtn{
      position: relative;
      width: auto;
      justify-self: center;

      padding: 8px 24px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.40);

      font-size: 16px;
      font-weight: 800;
      line-height: 1.1;
      color: #fff3cf;
      text-shadow: 0 1px 0 rgba(120,60,20,.7);
      cursor: pointer;

      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-tap-highlight-color: transparent;

      background-image:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.12),
          rgba(255,255,255,.03) 38%,
          rgba(0,0,0,.14) 100%
        ),
        url('../img/wood.jpg');
      background-size: 100% 100%, cover;
      background-position: center;
      background-repeat: no-repeat;

      filter: brightness(1.08) saturate(.96);

      box-shadow:
        0 3px 0 rgba(133,74,26,.85),
        0 8px 14px rgba(0,0,0,.45);

      transition:
        transform .08s ease-out,
        box-shadow .08s ease-out,
        filter .12s ease-out;
    }

    #drill-ctrls .pbtn:hover{
      filter: brightness(1.12) saturate(.98);
      transform: translateY(-1px);
      box-shadow:
        0 4px 0 rgba(133,74,26,.9),
        0 10px 16px rgba(0,0,0,.48);
    }
    #drill-ctrls .pbtn:active{
      filter: brightness(.97) saturate(.96);
      transform: translateY(2px);
      box-shadow:
        0 1px 0 rgba(120,60,20,.9),
        0 4px 8px rgba(0,0,0,.55);
    }

    #drill-ctrls #dbtn-next{
      grid-column: 2;
      justify-self: center;
    }

    #drill-ctrls #drill-progress{
      grid-column: 3;
      justify-self: end;
      text-align: right;
      min-width: 60px;
      font-weight:800;
      opacity:.9;
      color:#fff3cf;
      text-shadow:0 1px 0 rgba(120,60,20,.7);
    }

    @media (max-width: 480px){
      #core-inner{ width: min(94vw, 720px); }
    }

    /* =========================
       Drills notifications (from old)
       ========================= */
    .drill-notif{
      position:fixed;
      inset:0;
      z-index:100000;
      display:none;
      align-items:center;
      justify-content:center;
      padding:0;
      background:rgba(0,0,0,.55);
    }

    .drill-notif-card{
      position:relative;
      border-radius:10px;
      border:1px solid #e2e8f0;
      box-shadow:0 12px 28px rgba(15,23,42,.18);
      padding:16px;
      text-align:center;
      font-family:system-ui, "Segoe UI", Arial, sans-serif;

      color:#fff3cf;

      background-image:
        linear-gradient(
          to bottom,
          rgba(0,0,0,.10),
          rgba(0,0,0,.25)
        ),
        url('../img/notification.jpg');
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;

      min-width:280px;
      max-width:min(86vw, 460px);
      max-height:calc(100vh - 32px);
      overflow:auto;
    }

    .drill-notif-card > *{
      color:inherit !important;
    }

    .drill-notif-title{
      font-weight:800;
      font-size:18px;
      line-height:1.35;
      margin-bottom:8px;
    }

    .drill-notif-desc{
      font-size:16px;
      line-height:1.4;
      margin-bottom:14px;
      opacity:.96;
    }

    .drill-stats{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin:6px 0 10px;
    }

    .drill-stat-box{
      border:1px solid rgba(255,255,255,.25);
      border-radius:10px;
      padding:10px 14px;
      min-width:140px;
      background:rgba(0,0,0,.18);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
    }

    .drill-stat-label{
      font-weight:800;
      opacity:.85;
      margin-bottom:2px;
    }

    .drill-stat-value{
      font-weight:900;
      font-size:22px;
      line-height:1;
    }

    .drill-notif-btn{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;

      padding:8px 18px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.40);

      font-size:16px;
      font-weight:800;
      line-height:1.1;
      color:#fff3cf;
      text-shadow:0 1px 0 rgba(120,60,20,.7);
      cursor:pointer;

      user-select:none;
      -webkit-user-select:none;
      -moz-user-select:none;
      -ms-user-select:none;
      -webkit-tap-highlight-color:transparent;

      background-image:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.12),
          rgba(255,255,255,.03) 38%,
          rgba(0,0,0,.14) 100%
        ),
        url('../img/wood.jpg');
      background-size:100% 100%, cover;
      background-position:center;
      background-repeat:no-repeat;

      filter:brightness(1.08) saturate(.96);

      box-shadow:
        0 3px 0 rgba(133,74,26,.85),
        0 8px 14px rgba(0,0,0,.45);

      transition:
        transform .08s ease-out,
        box-shadow .08s ease-out,
        filter .12s ease-out;
    }

    .drill-notif-btn:hover{
      filter:brightness(1.12) saturate(.98);
      transform:translateY(-1px);
      box-shadow:
        0 4px 0 rgba(133,74,26,.9),
        0 10px 16px rgba(0,0,0,.48);
    }

    .drill-notif-btn:active{
      filter:brightness(.97) saturate(.96);
      transform:translateY(2px);
      box-shadow:
        0 1px 0 rgba(120,60,20,.9),
        0 4px 8px rgba(0,0,0,.55);
    }

    .drill-notif-btn-lg{
      padding:10px 22px;
    }

    .drill-notif-actions{
      margin-top:10px;
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }
  </style>

  <!-- WGo loader -->
  <script>
    (function ensureWGo(){
      if (window.WGo) return;
      var s = document.createElement('script');
      s.src = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754893285939x971907393576095400/wgo.min.js";
      s.async = true;
      document.head.appendChild(s);
    })();
  </script>

  <!-- Shared prefs store -->
  <script>
  (function(){
    var STORAGE_KEY = 'go_prefs';
    var GoPrefs = (window.GoPrefs = window.GoPrefs || {});
    try {
      var saved = localStorage.getItem(STORAGE_KEY);
      if (saved) Object.assign(GoPrefs, JSON.parse(saved) || {});
    } catch (e) {}

    if (typeof GoPrefs.josekiZoom === 'undefined')         GoPrefs.josekiZoom = true;
    if (typeof GoPrefs.soundOn === 'undefined')            GoPrefs.soundOn = true;
    if (typeof GoPrefs.highlightLast === 'undefined')      GoPrefs.highlightLast = true;
    if (typeof GoPrefs.disableAutoZoomOut === 'undefined') GoPrefs.disableAutoZoomOut = false;

    window.GoPrefsSave = function(){
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(GoPrefs)); } catch (e) {}
    };
  })();
  </script>

  <!-- Sound bridge -->
  <script>
  if (!window.StoneSFX) {
    window.StoneSFX = (() => {
      let pool = [], i = 0;
      function init(url, voices = 5){
        pool = Array.from({ length: voices }, () => {
          const a = new Audio(url); a.preload = 'auto'; a.volume = 0.35; return a;
        });
        const unlock = () => {
          pool.forEach(a => { try{ a.play().then(()=>a.pause()).catch(()=>{}); a.currentTime=0; }catch(e){} });
          window.removeEventListener('touchstart', unlock);
          window.removeEventListener('mousedown', unlock);
        };
        window.addEventListener('touchstart', unlock, { once:true });
        window.addEventListener('mousedown', unlock, { once:true });
      }
      function play(){
        if (!pool.length) return;
        const a = pool[i++ % pool.length];
        try { a.currentTime=0; a.playbackRate=0.97+Math.random()*0.06; a.play(); } catch(e){}
      }
      return { init, play };
    })();
  }
  if (!window._stoneSFXInit) { StoneSFX.init("../sound/click.mp3"); window._stoneSFXInit = true; }

  (function(){
    if (!window.StoneSFX || window._soundBridgeReady) return;
    window._soundBridgeReady = true;
    if (typeof StoneSFX.play === 'function' && !('_enabled' in StoneSFX)){
      StoneSFX._enabled = (window.GoPrefs ? !!window.GoPrefs.soundOn : true);
      const _origPlay = StoneSFX.play.bind(StoneSFX);
      StoneSFX.play = function(){ if (StoneSFX._enabled) _origPlay(); };
    }
  })();
  </script>
</head>

<body>

  <div id="core-root">
    <div id="core-inner">

      <div id="drill-topbar">
        <button id="dbtn-menu" class="s-back" type="button" aria-label="Back">← Back</button>
        <div id="blitz-timer" class="blitz-chip">0.0s</div>
      </div>

      <div id="core-board-wrap">
        <div id="core-board"></div>
      </div>

      <div id="drill-ctrls">
        <button id="dbtn-next" class="pbtn" type="button">Skip</button>
        <div id="drill-progress">0 / 0</div>
      </div>

    </div>
  </div>

  <div id="zoom-exit-btn"></div>

  <!-- Wrong -->
  <div id="drill-wrong" class="drill-notif" role="alert" aria-live="polite">
    <div class="drill-notif-card">
      <div class="drill-notif-title">Wrong</div>
    </div>
  </div>

  <!-- Cleared -->
  <div id="drill-cleared" class="drill-notif" role="alert" aria-live="polite">
    <div class="drill-notif-card">
      <div class="drill-notif-title">Cleared</div>
    </div>
  </div>

  <!-- All Done -->
  <div id="drill-done" class="drill-notif" role="dialog" aria-modal="true">
    <div class="drill-notif-card">
      <div id="drill-done-title" class="drill-notif-title">All Drills Complete</div>

      <div id="drill-stats" class="drill-stats">
        <div class="drill-stat-box">
          <div class="drill-stat-label">Solved</div>
          <div id="drill-stat-solved" class="drill-stat-value">0</div>
        </div>
        <div class="drill-stat-box">
          <div class="drill-stat-label">Failed</div>
          <div id="drill-stat-failed" class="drill-stat-value">0</div>
        </div>
      </div>

      <div id="drill-done-msg" class="drill-notif-desc">
        Session finished. You can retry the set or go back to selection.
      </div>

      <div class="drill-notif-actions">
        <button id="drill-done-back" class="drill-notif-btn drill-notif-btn-lg" type="button">
          Back to selection
        </button>
        <button id="drill-done-retry" class="drill-notif-btn drill-notif-btn-lg" type="button">
          Retry set
        </button>
      </div>
    </div>
  </div>

  <!-- Run Cap -->
  <div id="drill-cap" class="drill-notif" role="dialog" aria-modal="true">
    <div class="drill-notif-card">
      <div class="drill-notif-title">Limit Reached</div>
      <div class="drill-notif-desc">You’ve reached your current drills limit.</div>
      <div class="drill-notif-actions">
        <button id="drill-cap-ok" class="drill-notif-btn drill-notif-btn-lg" type="button">OK</button>
      </div>
    </div>
  </div>

<script>
(function(){
  var SIZE  = 19;
  var mount = document.getElementById('core-board');
  var wrap  = document.getElementById('core-board-wrap');
  var exitBtn = document.getElementById('zoom-exit-btn');

  var btnMenu = document.getElementById('dbtn-menu');
  var btnNext = document.getElementById('dbtn-next');
  var progEl  = document.getElementById('drill-progress');
  var timerEl = document.getElementById('blitz-timer');

  // Notifs
  var wrongM   = document.getElementById('drill-wrong');
  var clearedM = document.getElementById('drill-cleared');
  var doneM    = document.getElementById('drill-done');
  var doneTitle= document.getElementById('drill-done-title');
  var doneBack = document.getElementById('drill-done-back');
  var doneRetry= document.getElementById('drill-done-retry');
  var statSolvedEl = document.getElementById('drill-stat-solved');
  var statFailedEl = document.getElementById('drill-stat-failed');
  var doneMsgEl    = document.getElementById('drill-done-msg');

  var capM   = document.getElementById('drill-cap');
  var capOK  = document.getElementById('drill-cap-ok');

  function showCapMsg(){
    if (capM) capM.style.display = 'flex';
    else alert('You’ve reached your current drills limit.');
  }
  if (capOK){
    capOK.addEventListener('click', function(){ capM.style.display='none'; });
    capM.addEventListener('click', function(e){ if (e.target === capM) capM.style.display='none'; });
  }

  var board = null;

  // Settings
  var zoomEnabled = (window.GoPrefs && typeof window.GoPrefs.josekiZoom !== 'undefined') ? !!window.GoPrefs.josekiZoom : true;
  var highlightLastEnabled = (window.GoPrefs && typeof window.GoPrefs.highlightLast !== 'undefined') ? !!window.GoPrefs.highlightLast : true;
  var disableAutoZoomOut = (window.GoPrefs && typeof window.GoPrefs.disableAutoZoomOut !== 'undefined') ? !!window.GoPrefs.disableAutoZoomOut : false;

  window.addEventListener('go:prefs-changed', function(e){
    var d = e.detail || {};
    if (!d || typeof d.key === 'undefined') return;

    if (d.key === 'highlightLast') {
      highlightLastEnabled = !!d.value;
      try { redraw(); } catch(_) {}
    } else if (d.key === 'josekiZoom') {
      zoomEnabled = !!d.value;
      if (!zoomEnabled && (isFullscreen || scale > 1)) {
        smoothZoomOutAndExit();
      }
    } else if (d.key === 'soundOn') {
      if (window.StoneSFX) StoneSFX._enabled = !!d.value;
    } else if (d.key === 'disableAutoZoomOut') {
      disableAutoZoomOut = !!d.value;
    }
  });

  // ===== Core zoom engine state =====
  var scale = 1, minScale = 1, maxScale = 2.6;
  var offsetX = 0, offsetY = 0;
  var baseW = 0;
  var zoomLayer = null;
  var isFullscreen = false;
  var isZoomAnimating = false;
  var animId = 0;
  var returnAnchor = null;

  var isPanning = false, panStart = null, tapStart = null;
  var TAP_SLOP2 = 64;
  var isFlinging = false, flingId = 0, flingVX = 0, flingVY = 0, flingLastTime = 0;
  var panSamplePrev = null, panSampleCurr = null;

  function ensureZoomLayer(){
    if (zoomLayer) return;

    zoomLayer = document.createElement('div');
    zoomLayer.style.position = 'absolute';
    zoomLayer.style.left = '0px';
    zoomLayer.style.top = '0px';
    zoomLayer.style.transformOrigin = '0 0';
    zoomLayer.style.willChange = 'transform';

    while (mount.firstChild) zoomLayer.appendChild(mount.firstChild);
    mount.appendChild(zoomLayer);

    zoomLayer.style.backgroundImage = "url('../img/wood.jpg')";
    zoomLayer.style.backgroundSize = "cover";
    zoomLayer.style.backgroundPosition = "center";
    mount.style.background = "none";
  }

  function canvasCssScale(){
    var c = mount.querySelector('canvas');
    if (!c) return 1;
    var cssW = c.clientWidth || c.getBoundingClientRect().width || 0;
    var intW = c.width || 0;
    if (!cssW || !intW) return 1;
    return cssW / intW;
  }
  function getXcss(i){ return board.getX(i) * canvasCssScale(); }
  function getYcss(j){ return board.getY(j) * canvasCssScale(); }

  function getGridSpacing(){
    var sX = Math.abs(getXcss(1) - getXcss(0));
    var sY = Math.abs(getYcss(1) - getYcss(0));
    return { x: sX, y: sY };
  }

  function viewportSize(){
    return { vw: mount.clientWidth, vh: mount.clientHeight };
  }

  function clampPan(){
    if (isZoomAnimating) return;
    var v = viewportSize();
    var vw = v.vw, vh = v.vh;
    var bw = Math.round(baseW * scale);

    var bleedX = Math.ceil(vw * 0.5);
    var bleedY = Math.ceil(vh * 0.5);

    var minOX = -bleedX;
    var maxOX = Math.max(0, bw - vw) + bleedX;
    var minOY = -bleedY;
    var maxOY = Math.max(0, bw - vh) + bleedY;

    offsetX = Math.max(minOX, Math.min(offsetX, maxOX));
    offsetY = Math.max(minOY, Math.min(offsetY, maxOY));
  }

  function applyPanAndSize(redrawAfter){
    var targetW = baseW;

    if (board && board._lastW !== targetW) {
      board.setWidth(targetW);
      if (zoomLayer) {
        zoomLayer.style.width = targetW + 'px';
        zoomLayer.style.height = targetW + 'px';
      }
      board._lastW = targetW;
      if (!redrawAfter) redrawAfter = true;
    }

    clampPan();

    if (zoomLayer) {
      zoomLayer.style.transform =
        'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';
    }

    if (redrawAfter) redraw();
  }

  function animateTo(targetScale, pxWorld, pyWorld, sxTarget, syTarget, onDone){
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
    cancelFling();

    var s0 = scale, ox0 = offsetX, oy0 = offsetY;
    var t0 = performance.now();
    var dur = 300;

    cancelAnimationFrame(animId);
    isZoomAnimating = true;

    var targetOffsetX = (pxWorld * targetScale) - sxTarget;
    var targetOffsetY = (pyWorld * targetScale) - syTarget;

    (function step(now){
      var t = (now - t0) / dur;
      if (t > 1) t = 1;
      var e = 1 - Math.pow(1 - t, 3);

      scale = s0 + (targetScale - s0) * e;
      offsetX = ox0 + (targetOffsetX - ox0) * e;
      offsetY = oy0 + (targetOffsetY - oy0) * e;

      applyPanAndSize(false);

      if (t < 1){
        animId = requestAnimationFrame(step);
      } else {
        isZoomAnimating = false;
        applyPanAndSize(true);
        if (typeof onDone === 'function') onDone();
      }
    })(t0);
  }

  function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
    if (isFullscreen) return;
    cancelFling();

    returnAnchor = document.createElement('div');
    returnAnchor.style.width = mount.clientWidth + 'px';
    returnAnchor.style.height = mount.clientHeight + 'px';
    mount.parentNode.insertBefore(returnAnchor, mount);

    document.body.appendChild(mount);
    mount.classList.add('is-fullscreen');
    isFullscreen = true;
    exitBtn.style.display = 'flex';

    mount.style.width = '100vw';
    mount.style.height = '100vh';

    scale = 1; offsetX = 0; offsetY = 0;

    var vw = window.innerWidth;
    var vh = window.innerHeight;
    baseW = Math.floor(Math.min(vw, vh));
    if (baseW % 2) baseW--;

    requestAnimationFrame(function(){
      applyPanAndSize(true);

      var initialFactor = 2.4;
      var px_curr = getXcss(i);
      var py_curr = getYcss(j);

      var rect = mount.getBoundingClientRect();
      var sx = rect.width / 2;
      var sy = rect.height / 2;

      if (typeof tapClientX === 'number' && typeof tapClientY === 'number'){
        sx = tapClientX - rect.left;
        sy = tapClientY - rect.top;
      }

      offsetX = px_curr * 1.0 - sx;
      offsetY = py_curr * 1.0 - sy;
      applyPanAndSize(false);

      animateTo(initialFactor, px_curr, py_curr, sx, sy);
    });
  }

  function exitFullscreen(){
    cancelFling();
    cancelAnimationFrame(animId);
    isZoomAnimating = false;

    mount.classList.remove('is-fullscreen');
    exitBtn.style.display = 'none';
    isFullscreen = false;

    if (returnAnchor && returnAnchor.parentNode){
      returnAnchor.parentNode.insertBefore(mount, returnAnchor);
      returnAnchor.parentNode.removeChild(returnAnchor);
      returnAnchor = null;
    }

    mount.style.width = '';
    mount.style.height = '';

    fitBoard();
    resetViewLocal();
  }

  function resetViewLocal(){
    scale = 1; offsetX = 0; offsetY = 0;
    applyPanAndSize(true);
  }

  function smoothZoomOutAndExit(){
    if (!zoomEnabled) return;

    cancelFling();
    cancelAnimationFrame(animId);
    isZoomAnimating = false;

    scale = 1;
    offsetX = 0;
    offsetY = 0;

    applyPanAndSize(true);

    if (isFullscreen){
      exitFullscreen();
    }
  }

  function startFling(vx, vy){
    if (scale <= 1) return;
    cancelFling();

    var speed = Math.sqrt(vx*vx + vy*vy);
    var MAX_SPEED = 0.50;
    if (speed > MAX_SPEED){
      var s = MAX_SPEED / speed;
      vx *= s; vy *= s; speed = MAX_SPEED;
    }
    if (speed < 0.04) return;

    isFlinging = true;
    flingVX = vx; flingVY = vy;
    flingLastTime = performance.now();

    (function step(now){
      if (!isFlinging) return;
      var dt = now - flingLastTime;
      if (dt <= 0){
        flingId = requestAnimationFrame(step);
        return;
      }
      if (dt > 50) dt = 50;
      flingLastTime = now;

      offsetX += flingVX * dt;
      offsetY += flingVY * dt;

      var friction = 0.0010;
      var currentSpeed = Math.sqrt(flingVX*flingVX + flingVY*flingVY);
      var decel = friction * dt;

      if (currentSpeed <= 0.01 || decel >= currentSpeed){
        cancelFling();
        applyPanAndSize(true);
        return;
      }

      var newSpeed = currentSpeed - decel;
      var scaleFactor = newSpeed / currentSpeed;
      flingVX *= scaleFactor;
      flingVY *= scaleFactor;

      applyPanAndSize(false);
      flingId = requestAnimationFrame(step);
    })(performance.now());
  }

  function cancelFling(){
    isFlinging = false;
    if (flingId) { cancelAnimationFrame(flingId); flingId = 0; }
  }

  // =========================
  // Drills engine (ported from old)
  // =========================
  var SGF_URL = "../sgf/library-1.sgf";
  var MIN_MOVES = 10;

  // Plan helpers
  var Tier = window.Tier || {
    get: function(){
      try { return (localStorage.getItem('go_tier') || 'free').toLowerCase(); }
      catch(e){ return 'free'; }
    }
  };

  function isPro(){
    try{
      if (window.GoLimits && typeof window.GoLimits.get === 'function'){
        var lim = window.GoLimits.get();
        if (lim && lim.drills){
          if (lim.drills.triesPerDay === Number.POSITIVE_INFINITY) return true;
          if (typeof lim.drills.plan === 'string' && lim.drills.plan.toLowerCase() === 'pro') return true;
        }
      }
    }catch(e){}
    var t = Tier && typeof Tier.get === 'function' ? Tier.get() : 'free';
    return (t || 'free').toLowerCase() === 'pro';
  }

  var FREE_DAILY_LIMIT_COMPLETE = 2;
  var FREE_DAILY_LIMIT_BLITZ    = 2;

  function getDailyLimitForMode(mode){
    if (isPro()) return Infinity;
    return (mode === 'blitz') ? FREE_DAILY_LIMIT_BLITZ : FREE_DAILY_LIMIT_COMPLETE;
  }

  function readDailyDrillBucket(mode){
    var m   = (mode === 'blitz') ? 'blitz' : 'complete';
    var key = 'go:drills_attempts_' + m + '_today_v1';
    try{
      var raw   = localStorage.getItem(key);
      var today = (new Date()).toISOString().slice(0,10);
      var obj   = raw ? JSON.parse(raw) : null;
      if (!obj || obj.day !== today || typeof obj.count !== 'number'){
        obj = { day: today, count: 0 };
      }
      return { key: key, state: obj };
    }catch(_){
      return { key: key, state: null };
    }
  }

  function getDrillsUsedToday(mode){
    var bucket = readDailyDrillBucket(mode);
    if (!bucket.state) return 0;
    return bucket.state.count || 0;
  }

  function hasDrillAttemptsLeft(mode){
    if (isPro()) return true;
    var limit = getDailyLimitForMode(mode);
    if (!Number.isFinite(limit)) return true;
    var used  = getDrillsUsedToday(mode);
    return used < limit;
  }

  function recordDrillAttempt(mode){
    if (isPro()) return;
    var limit = getDailyLimitForMode(mode);
    if (!Number.isFinite(limit)) return;

    var bucket = readDailyDrillBucket(mode);
    if (!bucket.state) return;

    bucket.state.count = (bucket.state.count || 0) + 1;
    try{ localStorage.setItem(bucket.key, JSON.stringify(bucket.state)); }catch(_){}
  }

  // Board-side helpers: use current mode
  function currentModeForDaily(){
    return blitzMode ? 'blitz' : 'complete';
  }
  function dailyAttemptsLeftForCurrentMode(){
    var m     = currentModeForDaily();
    var limit = getDailyLimitForMode(m);
    if (!Number.isFinite(limit)) return Infinity;
    var used  = getDrillsUsedToday(m);
    return Math.max(0, limit - used);
  }
  function hasDailyAttemptsLeftForCurrentMode(){
    return hasDrillAttemptsLeft(currentModeForDaily());
  }
  function recordDailyAttemptForCurrentMode(){
    recordDrillAttempt(currentModeForDaily());
  }

  // --- SGF utils ---
  function rb(str,i){ var out='',k=i; while(k<str.length){ var ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; } if(ch===']') break; out+=ch; } return {t:out,n:k}; }
  function parseTree(str,i){
    var seq=[], node=null; if(str[i]!=='(') return {seq:[],n:i}; i++;
    while(i<str.length){
      var ch=str[i];
      if(ch===';'){ node={}; seq.push(node); i++; }
      else if(/[A-Za-z]/.test(ch)){
        var key=''; while(/[A-Za-z]/.test(str[i]||'')) key+=str[i++];
        var vals=[];
        while(str[i]==='['){ var r=rb(str,i+1); vals.push(r.t); i=r.n; }
        if(!node){ node={}; seq.push(node); }
        node[key]=vals.length>1?vals:vals[0];
      } else if(ch==='('){
        var child=parseTree(str,i); i=child.n;
        if(seq.length){
          var p=seq[seq.length-1];
          (p.variations||(p.variations=[])).push(child.seq);
        }
      } else if(ch===')'){ i++; break; }
      else i++;
    }
    for(var k=0;k<seq.length-1;k++) seq[k].next=seq[k+1];
    return {seq:seq,n:i};
  }
  function parseAllTrees(str){
    var trees=[]; var i=str.indexOf('(');
    if (str.charCodeAt && str.charCodeAt(0)===0xFEFF) str = str.slice(1);
    while(i>=0 && i<str.length){
      var r = parseTree(str,i);
      if (r.seq && r.seq.length) trees.push(r.seq);
      var nxt = str.indexOf('(', r.n);
      if (nxt === -1) break;
      i = nxt;
    }
    return trees;
  }
  function parseSZ(sz){ if(!sz) return 19; if(typeof sz==='string'){ var n=parseInt(sz.split(':')[0],10); return (n>=2&&n<=52)?n:19; } return 19; }
  function xy(s,S){ if(!s||s.length<2) return null; var x=s.charCodeAt(0)-97,y=s.charCodeAt(1)-97; if(x<0||y<0||x>=S||y>=S) return null; return {x:x,y:y}; }
  function nodeMove(n,S){
    if(!n) return null;
    if(n.B){ var p=xy(n.B,S); if(p) return {x:p.x,y:p.y,color:'B'}; }
    if(n.W){ var p2=xy(n.W,S); if(p2) return {x:p2.x,y:p2.y,color:'W'}; }
    return null;
  }
  function listCoords(prop,S){
    var arr = Array.isArray(prop)?prop:(prop?[prop]:[]);
    var out=[];
    for(var i=0;i<arr.length;i++){
      var p=xy(arr[i],S);
      if(p) out.push(p);
    }
    return out;
  }
  function linkify(seq,parent){
    for(var i=0;i<seq.length;i++){
      var n=seq[i];
      n.prev=(i===0?parent:seq[i-1]);
      n.next=(i<seq.length-1?seq[i+1]:null);
      if(n.variations){
        for(var j=0;j<n.variations.length;j++){
          var v=n.variations[j];
          if(v&&v.length) linkify(v,n);
        }
      }
    }
  }
  function enumerateLines(seq,S){
    var lines=[];
    var start=seq&&seq[0];
    while(start && !nodeMove(start,S) && !start.variations) start=start.next;

    function dfs(node,acc){
      if(!node){ lines.push(acc.slice()); return; }
      acc.push(node);

      if(node.variations && node.variations.length){
        for(var i=0;i<node.variations.length;i++){
          var v=node.variations[i];
          var f=v&&v[0];
          while(f && !nodeMove(f,S) && !f.variations) f=f.next;
          if(f) dfs(f,acc.slice());
        }
      }

      if(node.next){
        var nx=node.next;
        while(nx && !nodeMove(nx,S) && !nx.variations) nx=nx.next;
        if(nx) dfs(nx,acc);
        else lines.push(acc.slice());
      } else {
        lines.push(acc.slice());
      }
    }

    if(start) dfs(start,[]);
    return lines.map(function(nodes){
      return nodes.map(function(n){ return nodeMove(n,S); }).filter(Boolean);
    });
  }

  function lineKey(line){
    var size = line.size || 19;
    var seq = (line.moves||[]).map(function(m){
      return (m.color||'B')[0]+':'+m.x+','+m.y;
    }).join('|');
    return size + '|' + seq;
  }

  // --- transforms ---
  function t_identity(p){ return {x:p.x,y:p.y}; }
  function t_swap(p){ return {x:p.y, y:p.x}; }
  function t_rot90(p,S){  return {x: S-1 - p.y, y: p.x}; }
  function t_rot180(p,S){ return {x: S-1 - p.x, y: S-1 - p.y}; }
  function t_rot270(p,S){ return {x: p.y, y: S-1 - p.x}; }
  function compose(a,b,S){ return function(p){ return a(b(p,S),S); }; }
  function ORIENT_FUNCS(S){
    return [
      function(p){ return t_identity(p); },
      function(p){ return t_swap(p); },
      function(p){ return t_rot90(p,S); },
      function(p){ return compose(t_swap,t_rot90,S)(p); },
      function(p){ return t_rot180(p,S); },
      function(p){ return compose(t_swap,t_rot180,S)(p); },
      function(p){ return t_rot270(p,S); },
      function(p){ return compose(t_swap,t_rot270,S)(p); }
    ];
  }
  var ROT_IDX_ONLY = [0,2,4,6];

  function makeTransformed(line, orientIdx, swap){
    var S = line.size || 19;
    var ORS = ORIENT_FUNCS(S);
    var o = ORS[orientIdx % ORS.length];

    function tf(p){
      var t = o({x:p.x,y:p.y}, S);
      return {x:t.x,y:t.y};
    }

    var AB = (line.rootAB||[]).map(tf);
    var AW = (line.rootAW||[]).map(tf);

    var mv = (line.moves||[]).map(function(m){
      var t = tf(m);
      var c = swap ? (m.color==='B'?'W':'B') : m.color;
      return { x:t.x, y:t.y, color:c };
    });

    return {
      size:S,
      rootAB: swap ? AW : AB,
      rootAW: swap ? AB : AW,
      moves: mv
    };
  }

  // --- storage for favorites / own ---
  var OWN_STORE_KEY = 'go:ownpatterns';
  var FAV_KEY       = 'go_favorites';

  function loadOwnPatterns(){ try { return JSON.parse(localStorage.getItem(OWN_STORE_KEY) || '[]'); } catch(_){ return []; } }
  function readFavs(){ try { return JSON.parse(localStorage.getItem(FAV_KEY) || '{}') || {}; } catch(_){ return {}; } }

  function normalizeLineLike(obj){
    return {
      size: obj.size || 19,
      rootAB: Array.isArray(obj.rootAB)?obj.rootAB:[],
      rootAW: Array.isArray(obj.rootAW)?obj.rootAW:[],
      moves:  (obj.moves||[]).map(function(m){
        return { x:m.x, y:m.y, color:(m.color==='W'?'W':'B') };
      })
    };
  }

  function fetchLibraryLines(){
    return fetch(SGF_URL, { cache:'no-cache' }).then(function(r){ return r.text(); }).then(function(txt){
      var trees = parseAllTrees(txt);
      var lines=[];
      for(var s=0;s<trees.length;s++){
        var seq = trees[s];
        linkify(seq,null);
        var size = parseSZ(seq[0] && seq[0].SZ);
        var rootAB = listCoords(seq[0] && seq[0].AB, size);
        var rootAW = listCoords(seq[0] && seq[0].AW, size);
        var paths  = enumerateLines(seq,size);
        for(var p=0;p<paths.length;p++){
          var moves = paths[p];
          if ((moves && moves.length || 0) >= MIN_MOVES){
            lines.push({ size:size, rootAB:rootAB, rootAW:rootAW, moves:moves });
          }
        }
      }
      return lines;
    });
  }

  // Selections helper
  function getDrillSelections(){
    if (window.GoDrills && typeof window.GoDrills.getSelections === 'function'){
      try { return window.GoDrills.getSelections(); } catch(e){}
    }
    try{
      var raw = sessionStorage.getItem('go:drills_next_selection');
      if (!raw) return null;
      var obj = JSON.parse(raw);
      if (!obj || typeof obj !== 'object') return null;
      return obj;
    }catch(e){ return null; }
  }

  // ===== slots / planning =====
  var PER = 3;
  var slots = [];
  var lineToSlotIdxs = {};
  var runPlan = {};
  var index  = 0;
  var remain = [];
  var currentTransformed = null;

  var solvedCount = 0;
  var failedCount = 0;
  var locked = false;
  var wrongTimer = null;
  var clearedTimer = null;

  // Blitz mode state + timer
  var blitzMode = false;
  var timerMs = 0;
  var timerId = null;
  var blitzCornerPlannedMoves = 0;
  var timeUp = false;
  var blitzCornerState = null;

  function fmtMs(ms){
    if (ms < 0) ms = 0;
    var s = ms/1000;
    var m = Math.floor(s/60);
    var r = s - m*60;
    if (m > 0) {
      var sec = r.toFixed(1).padStart(4,'0');
      return m + ":" + sec;
    }
    return r.toFixed(1) + "s";
  }

  function startTimer(){
    if (!blitzMode) return;
    stopTimer();
    timeUp = false;
    if (timerEl) {
      timerEl.style.display = 'inline-flex';
      timerEl.textContent = fmtMs(timerMs);
    }
    timerId = setInterval(function(){
      timerMs -= 100;
      if (timerEl) timerEl.textContent = fmtMs(timerMs);
      if (timerMs <= 0){
        stopTimer();
        timeUp = true;
        showDone('Time’s up!');
      }
    }, 100);
  }
  function stopTimer(){
    if (timerId){ clearInterval(timerId); timerId = null; }
  }

  function shuffle(a){
    for(var i=a.length-1;i>0;i--){
      var j=Math.floor(Math.random()*(i+1));
      var tmp=a[i]; a[i]=a[j]; a[j]=tmp;
    }
    return a;
  }
  function range(a,b){
    var out=[];
    for(var i=a;i<=b;i++) out.push(i);
    return out;
  }

  function mixSlotsFairly(slotList){
    var buckets = new Map();
    for (var i=0;i<slotList.length;i++){
      var s = slotList[i];
      if (!buckets.has(s.key)) buckets.set(s.key, []);
      buckets.get(s.key).push(s);
    }
    buckets.forEach(function(arr){ shuffle(arr); });

    var keys = Array.from(buckets.keys());
    var lastKey = null;
    var out = [];

    function pickKey(){
      var candidates = keys.filter(function(k){
        return (buckets.get(k)||[]).length && k !== lastKey;
      });
      var pool = candidates.length ? candidates : keys.filter(function(k){
        return (buckets.get(k)||[]).length;
      });
      if (!pool.length) return null;
      return pool[Math.floor(Math.random()*pool.length)];
    }

    while (out.length < slotList.length){
      var k = pickKey();
      if (k == null) break;
      out.push(buckets.get(k).pop());
      lastKey = k;
    }
    return out;
  }

  function buildRunPlanForLine(key, line, slotIdxs){
    var L = line.moves.length, k = slotIdxs.length;

    if (blitzMode){
      var orientIdxs = shuffle(ROT_IDX_ONLY.slice()).slice(0, k || 1);
      var swaps = Array(k).fill(false);
      var nSwap = Math.round(k * 0.5);
      for (var i=0;i<nSwap;i++) swaps[i]=true;
      swaps = shuffle(swaps);

      var plan = new Map();
      var shuffledSlots = shuffle(slotIdxs.slice());
      for (var s=0;s<k;s++){
        plan.set(shuffledSlots[s], {
          orientIdx: orientIdxs[s % orientIdxs.length],
          startIndex: 0,
          swap: swaps[s]
        });
      }
      return plan;
    }

    function allowedStartRange(L){
      var min = Math.max(4,0);
      var max = Math.max(min, L-2);
      return range(min,max);
    }

    var startsPool = allowedStartRange(L);
    var orientAll = range(0,7);
    var orientPicked = shuffle(orientAll).slice(0, slotIdxs.length || 1);
    var chosenStarts = shuffle(startsPool.slice());

    var swaps2 = Array(slotIdxs.length).fill(false);
    var nSwap2 = Math.round(slotIdxs.length * 0.5);
    for (var j=0;j<nSwap2;j++) swaps2[j]=true;
    swaps2 = shuffle(swaps2);

    var plan2 = new Map();
    var shuffledSlots2 = shuffle(slotIdxs.slice());
    for (var p=0;p<slotIdxs.length;p++){
      plan2.set(shuffledSlots2[p], {
        orientIdx: orientPicked[p % orientPicked.length],
        startIndex: chosenStarts[p % chosenStarts.length],
        swap: swaps2[p]
      });
    }
    return plan2;
  }

  function ensureRunPlanFor(key,line){
    if (!runPlan[key]){
      var idxs = lineToSlotIdxs[key] || [];
      runPlan[key] = buildRunPlanForLine(key, line, idxs);
    }
  }

  function newRunPlan(){
    runPlan = {};
    var seen = new Set();
    for (var i=0;i<slots.length;i++){
      var s = slots[i];
      if (seen.has(s.key)) continue;
      seen.add(s.key);
      ensureRunPlanFor(s.key, s.base);
    }
  }

  function setProgress(){
    if (progEl) progEl.textContent = (slots.length ? (index+1) : 0) + ' / ' + (slots.length || 0);
  }

  function resetStats(){
    solvedCount = 0;
    failedCount = 0;
    if (statSolvedEl) statSolvedEl.textContent = '0';
    if (statFailedEl) statFailedEl.textContent = '0';
  }

  function clearTimers(){
    if (wrongTimer){ clearTimeout(wrongTimer); wrongTimer=null; }
    if (clearedTimer){ clearTimeout(clearedTimer); clearedTimer=null; }
  }

  // ===== board state for drills =====
  var grid = null;

  function resetGrid(){
    grid = Array.from({length:SIZE}, function(){ return Array(SIZE).fill(null); });
  }
  function addStone(x,y,color){ grid[y][x]=color; }

  function inside(x,y){ return x>=0 && y>=0 && x<SIZE && y<SIZE; }
  function neigh4(x,y){
    var arr = [
      {x:x+1,y:y},{x:x-1,y:y},{x:x,y:y+1},{x:x,y:y-1}
    ];
    return arr.filter(function(p){ return inside(p.x,p.y); });
  }

  function groupAndLiberties(x,y){
    var color = grid[y][x]; if (!color) return { stones:[], libs:0 };
    var seen = new Set(), libset = new Set(), stones=[];
    function key(a,b){ return a+','+b; }
    var stack=[{x:x,y:y}]; seen.add(key(x,y));
    while(stack.length){
      var p = stack.pop(); stones.push(p);
      var ns = neigh4(p.x,p.y);
      for (var i=0;i<ns.length;i++){
        var n = ns[i];
        var v = grid[n.y][n.x];
        if (v === null) libset.add(key(n.x,n.y));
        else if (v === color){
          var k = key(n.x,n.y);
          if (!seen.has(k)){ seen.add(k); stack.push(n); }
        }
      }
    }
    return { stones:stones, libs: libset.size };
  }

  function removeStones(stones){
    for (var i=0;i<stones.length;i++){
      var s = stones[i];
      grid[s.y][s.x] = null;
    }
  }

  function resolveCapturesAfterPlacing(x,y,color){
    var opp = (color==='B'?'W':'B');
    var seenOpp = new Set();

    var ns = neigh4(x,y);
    for (var i=0;i<ns.length;i++){
      var n = ns[i];
      if (grid[n.y][n.x] !== opp) continue;
      var k = n.x+','+n.y;
      if (seenOpp.has(k)) continue;

      var g = groupAndLiberties(n.x,n.y);
      for (var j=0;j<g.stones.length;j++){
        var s = g.stones[j];
        seenOpp.add(s.x+','+s.y);
      }
      if (g.libs === 0) removeStones(g.stones);
    }

    if (grid[y][x] === color){
      var gSelf = groupAndLiberties(x,y);
      if (gSelf.libs === 0) removeStones(gSelf.stones);
    }
  }

  function playMove(x,y,color, silent){
    addStone(x,y,color);
    resolveCapturesAfterPlacing(x,y,color);
    if (!silent && window.StoneSFX) StoneSFX.play();
    redraw();
  }

  function isCornerHoshi(pt,S){
    var a = 3, b = S-4;
    return ((pt.x===a || pt.x===b) && (pt.y===a || pt.y===b));
  }
  function corner33BelowOfHoshi(h,S){
    var dx = (h.x===3) ? -1 : +1;
    var dy = (h.y===3) ? -1 : +1;
    return { x: h.x + dx, y: h.y + dy };
  }
  function drawBlitzMarkers(){
    if (!currentTransformed || !Array.isArray(currentTransformed.moves) || currentTransformed.moves.length < 1) return;
    var m1 = currentTransformed.moves[0];
    board.addObject({ x:m1.x, y:m1.y, type:'LB', text:'A' });

    if (currentTransformed.moves.length >= 2 && isCornerHoshi(m1, SIZE)){
      var m2 = currentTransformed.moves[1];
      board.addObject({ x:m2.x, y:m2.y, type:'LB', text:'a' });

      if (currentTransformed.moves.length >= 3){
        var below = corner33BelowOfHoshi(m1, SIZE);
        if (m2.x === below.x && m2.y === below.y){
          var m3 = currentTransformed.moves[2];
          board.addObject({ x:m3.x, y:m3.y, type:'LB', text:'A' });
        }
      }
    }
  }

  function redraw(){
    if (!board || !grid) return;
    board.removeAllObjects();

    for(var y=0;y<SIZE;y++){
      for(var x=0;x<SIZE;x++){
        var v = grid[y][x];
        if(v==='B') board.addObject({x:x, y:y, c:WGo.B});
        else if(v==='W') board.addObject({x:x, y:y, c:WGo.W});
      }
    }

    if (highlightLastEnabled && lastPlaced){
      board.addObject({x:lastPlaced.x, y:lastPlaced.y, type:'CR'});
    }

    if (blitzMode) drawBlitzMarkers();
  }

  var lastPlaced = null;

  function prepareCorner(tline, startIndex){
    resetGrid();
    (tline.rootAB||[]).forEach(function(p){ addStone(p.x,p.y,'B'); });
    (tline.rootAW||[]).forEach(function(p){ addStone(p.x,p.y,'W'); });

    for (var s=0;s<startIndex;s++){
      var m = tline.moves[s];
      playMove(m.x,m.y,m.color, true);
    }

    remain = tline.moves.slice(startIndex).map(function(m){
      return {x:m.x,y:m.y,color:m.color};
    });

    lastPlaced = null;
    redraw();
  }

  function startDrill(i, opts){
    opts = opts || {};
    var fromSkip = !!opts.fromSkip;

    index = i;
    if (index >= slots.length){ showDone(); return; }

    var slot = slots[index];
    var base = slot.base;
    var key  = slot.key;

    SIZE = base.size || 19;
    if (!board) initBoard();
    clearTimers();

    ensureRunPlanFor(key, base);
    var variant = runPlan[key].get(index);
    var tline = makeTransformed(base, variant.orientIdx, variant.swap);
    currentTransformed = tline;

    prepareCorner(tline, variant.startIndex);

    blitzCornerPlannedMoves = remain.length;

    if (blitzMode){
      if (!fromSkip){
        timerMs += blitzCornerPlannedMoves * 1500;
      }
      if (timerEl){
        timerEl.style.display = 'inline-flex';
        timerEl.textContent = fmtMs(timerMs);
      }
      if (!timerId) startTimer();

      blitzCornerState = {
        tline: tline,
        startIndex: variant.startIndex,
        plannedN: blitzCornerPlannedMoves
      };
    }

    setProgress();
    locked = false;
  }

  function restartSameCornerBlitz(){
    if (!blitzMode || !blitzCornerState) return;
    prepareCorner(blitzCornerState.tline, blitzCornerState.startIndex);
    locked = false;
  }

  function showWrongThenRestart(){
    clearTimers();
    if (wrongM) wrongM.style.display='flex';
    locked = true;
    wrongTimer = setTimeout(function(){
      if (wrongM) wrongM.style.display='none';
      restartSameCornerBlitz();
    }, 800);
  }

  function showWrongAuto(){
    clearTimers();
    if (wrongM) wrongM.style.display='flex';
    locked = true;
    wrongTimer = setTimeout(function(){
      if (wrongM) wrongM.style.display='none';
      locked = false;
      if (index >= (slots.length - 1)) showDone();
      else startDrill(index+1);
    }, 1000);
  }

  function showClearedAuto(){
    clearTimers();
    if (clearedM) clearedM.style.display='flex';
    locked = true;
    clearedTimer = setTimeout(function(){
      if (clearedM) clearedM.style.display='none';
      locked = false;
      startDrill(index+1);
    }, 850);
  }

  function showClearedThenDone(){
    clearTimers();
    if (clearedM) clearedM.style.display='flex';
    locked = true;
    clearedTimer = setTimeout(function(){
      if (clearedM) clearedM.style.display='none';
      showDone();
    }, 800);
  }

  function showDone(customTitle){
    clearTimers();

    if (statSolvedEl) statSolvedEl.textContent = String(solvedCount);
    if (statFailedEl) statFailedEl.textContent = String(failedCount);
    if (doneTitle)    doneTitle.textContent   = customTitle || 'All Drills Complete';

    var left = dailyAttemptsLeftForCurrentMode();

    if (left <= 0){
      if (doneMsgEl) doneMsgEl.textContent = 'You reached your drills limit.';
      if (doneRetry){
        doneRetry.disabled = true;
        doneRetry.style.opacity = '.6';
        doneRetry.style.cursor = 'not-allowed';
      }
    } else {
      if (doneMsgEl){
        doneMsgEl.textContent = customTitle
          ? 'Session ended.'
          : 'Session finished. You can retry the set or go back to selection.';
      }
      if (doneRetry){
        doneRetry.disabled = false;
        doneRetry.style.opacity = '1';
        doneRetry.style.cursor = 'pointer';
      }
    }

    if (doneM) doneM.style.display = 'flex';
    if (blitzMode) stopTimer();
  }

  function reshuffleSlots(){
    if (!slots.length) return;
    slots = mixSlotsFairly(slots.slice());
    lineToSlotIdxs = {};
    for (var i=0;i<slots.length;i++){
      var k = slots[i].key;
      if (!lineToSlotIdxs[k]) lineToSlotIdxs[k] = [];
      lineToSlotIdxs[k].push(i);
    }
  }

  function onBoardClick(x,y){
    if (locked || timeUp) return;
    if (x<0 || y<0 || x>=SIZE || y>=SIZE) return;
    if (!grid || grid[y][x] !== null) return;
    if (!remain.length) return;

    var next = remain[0];

    if (next.x === x && next.y === y){
      playMove(x,y,next.color, false);
      lastPlaced = {x:x, y:y};
      remain.shift();

      if (!disableAutoZoomOut && scale > 1){
        setTimeout(smoothZoomOutAndExit, 10);
      }

      if (!remain.length){
        solvedCount++;

        if (blitzMode){
          timerMs += blitzCornerPlannedMoves * 500;
          if (timerEl) timerEl.textContent = fmtMs(timerMs);
        }

        if (index >= (slots.length - 1)) showClearedThenDone();
        else showClearedAuto();
      }
    } else {
      failedCount++;
      if (blitzMode) showWrongThenRestart();
      else showWrongAuto();
    }
  }

  // ===== Click binding adapted to drills =====
  function bindClicks(){
    mount.addEventListener('pointerdown', function(e){
      if (!zoomEnabled) return;
      if (e.pointerType !== 'touch' && e.button !== 0) return;
      cancelFling();

      var r = mount.getBoundingClientRect();
      var sx = e.clientX - r.left;
      var sy = e.clientY - r.top;

      var boardX = (sx + offsetX) / scale;
      var boardY = (sy + offsetY) / scale;

      var bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
      for (var i = 0; i < SIZE; i++){
        var dx = Math.abs(getXcss(i) - boardX);
        if (dx < bestDx){ bestDx = dx; bestI = i; }
      }
      for (var j = 0; j < SIZE; j++){
        var dy = Math.abs(getYcss(j) - boardY);
        if (dy < bestDy){ bestDy = dy; bestJ = j; }
      }

      var spacing = getGridSpacing();
      var limitX = spacing.x * 0.5;
      var limitY = spacing.y * 0.5;

      panStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY };
      panSamplePrev = panSampleCurr = null;
      try { mount.setPointerCapture(e.pointerId); } catch(_){}

      if (bestDx > limitX || bestDy > limitY) {
        tapStart = null;
        return;
      }

      tapStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY, gridI: bestI, gridJ: bestJ };
    }, {passive:false});

    mount.addEventListener('pointermove', function(e){
      if (!zoomEnabled) return;
      if (!panStart) return;
      if (scale <= 1.01 && !isFullscreen) return;

      var dx = e.clientX - panStart.x;
      var dy = e.clientY - panStart.y;

      if (!isPanning && (dx*dx + dy*dy > TAP_SLOP2)) isPanning = true;

      if (isPanning) {
        offsetX = panStart.ox - dx;
        offsetY = panStart.oy - dy;
        applyPanAndSize(false);
        e.preventDefault();

        var now = performance.now();
        panSamplePrev = panSampleCurr;
        panSampleCurr = { ox: offsetX, oy: offsetY, t: now };
      }
    }, {passive:false});

    mount.addEventListener('pointerup', function(e){
      // Zoom disabled path: still allow drills tapping
      if (!zoomEnabled) {
        var r0 = mount.getBoundingClientRect();
        var bx = e.clientX - r0.left;
        var by = e.clientY - r0.top;

        var bestI0 = -1, bestJ0 = -1, bestDx0 = 1e9, bestDy0 = 1e9;
        for (var i0=0; i0<SIZE; i0++){
          var dx0 = Math.abs(getXcss(i0) - bx);
          if (dx0<bestDx0){ bestDx0=dx0; bestI0=i0; }
        }
        for (var j0=0; j0<SIZE; j0++){
          var dy0 = Math.abs(getYcss(j0) - by);
          if (dy0<bestDy0){ bestDy0=dy0; bestJ0=j0; }
        }

        var spacing0 = getGridSpacing();
        if (bestDx0 > spacing0.x * 0.5 || bestDy0 > spacing0.y * 0.5) return;

        e.preventDefault();
        onBoardClick(bestI0, bestJ0);
        return;
      }

      if (!tapStart) {
        if (panStart) {
          try { mount.releasePointerCapture(e.pointerId); } catch(_){}
          panStart = null;
        }
        return;
      }

      try { mount.releasePointerCapture(e.pointerId); } catch(_){}

      var dist2 = (e.clientX - tapStart.x)*(e.clientX - tapStart.x) + (e.clientY - tapStart.y)*(e.clientY - tapStart.y);
      var gridI = tapStart.gridI;
      var gridJ = tapStart.gridJ;
      var tapX = tapStart.x;
      var tapY = tapStart.y;

      tapStart = null; panStart = null;

      if (isPanning) {
        isPanning = false;
        if (panSamplePrev && panSampleCurr) {
          var dt = panSampleCurr.t - panSamplePrev.t;
          if (dt > 0 && dt < 120) {
            startFling((panSampleCurr.ox - panSamplePrev.ox)/dt, (panSampleCurr.oy - panSamplePrev.oy)/dt);
          }
        }
        return;
      }

      if (dist2 <= TAP_SLOP2) {
        e.preventDefault();
        if (scale <= 1.05 && !isFullscreen) {
          enterFullscreenAtGrid(gridI, gridJ, tapX, tapY);
        } else {
          onBoardClick(gridI, gridJ);
        }
      }
    }, {passive:false});

    board.addEventListener('click', function(x, y){
      if (zoomEnabled && (isFullscreen || scale > 1)) return;
      onBoardClick(x, y);
    });
  }

  // ===== Board setup =====
  function createBoard(){
    if (board || !window.WGo) return;
    board = new WGo.Board(mount, { size: SIZE, background: '' });
    ensureZoomLayer();
    fitBoard();

    resetGrid();
    redraw();
    bindClicks();

    exitBtn.addEventListener('click', function(e){
      e.stopPropagation();
      smoothZoomOutAndExit();
    });

    window.addEventListener('resize', fitBoard);
    window.addEventListener('orientationchange', function(){ setTimeout(fitBoard, 150); });
  }

  function fitBoard(){
    if (isFullscreen) return;
    var w = wrap.getBoundingClientRect().width;
    w = Math.floor(w); if(w%2) w--;
    baseW = w;
    mount.style.width = w+'px';
    mount.style.height = w+'px';
    applyPanAndSize(true);
  }

  function initWhenReady(){
    var tries = 0;
    (function wait(){
      if (window.WGo) createBoard();
      else if (tries++ < 120) setTimeout(wait, 50);
    })();
  }

  // ===== Build slots from selections or full library =====
  function buildSlotsFromLines(baseLines){
    var raw = [];
    for (var i=0;i<baseLines.length;i++){
      var base = baseLines[i];
      var key = lineKey(base);
      for (var k=0;k<PER;k++){
        raw.push({ key:key, base:base });
      }
    }
    slots = mixSlotsFairly(raw);

    lineToSlotIdxs = {};
    for (var s=0;s<slots.length;s++){
      var kk = slots[s].key;
      if (!lineToSlotIdxs[kk]) lineToSlotIdxs[kk] = [];
      lineToSlotIdxs[kk].push(s);
    }
  }

  function DrillLoad(linesOrNull, opts){
    opts = opts || {};
    PER = Math.max(1, parseInt(opts.perJoseki || 3, 10) || 3);

    var sel = getDrillSelections();
    var selMode = (sel && sel.mode === 'blitz') ? 'blitz' : 'complete';
    blitzMode = (selMode === 'blitz');

    function go(lines){
      var usable = (lines||[]).filter(function(l){
        return Array.isArray(l.moves) && l.moves.length >= MIN_MOVES;
      }).map(normalizeLineLike);

      if (!usable.length){
        alert('No eligible drills (need patterns with 10+ moves).');
        return;
      }

      buildSlotsFromLines(usable);
      newRunPlan();

      resetStats();
      index = 0;
      blitzCornerState = null;
      timeUp = false;

      if (blitzMode){
        timerMs = 0;
        if (timerEl){
          timerEl.style.display = 'inline-flex';
          timerEl.textContent = fmtMs(timerMs);
        }
        startTimer();
      } else {
        if (timerEl) timerEl.style.display = 'none';
        stopTimer();
      }

      startDrill(0);
    }

    if (Array.isArray(linesOrNull)){
      go(linesOrNull);
      return;
    }

    if (sel && (
        (sel.library && sel.library.length) ||
        (sel.favorites && sel.favorites.length) ||
        (sel.own && sel.own.length)
      )){

      var favMap   = readFavs();
      var favLines = Object.values(favMap).map(normalizeLineLike);
      var favPick  = favLines.filter(function(l){
        return (sel.favorites || []).includes(lineKey(l));
      });

      var ownAll   = loadOwnPatterns();
      var ownPick  = ownAll
        .filter(function(p){ return (sel.own || []).includes(p.id); })
        .map(normalizeLineLike);

      if ((sel.library || []).length){
        fetchLibraryLines().then(function(allLib){
          var libPick = allLib.filter(function(l){
            return (sel.library || []).includes(lineKey(l));
          });
          go([].concat(libPick, favPick, ownPick));
        }).catch(function(){
          go([].concat(favPick, ownPick));
        });
      } else {
        go([].concat(favPick, ownPick));
      }
      return;
    }

    fetchLibraryLines().then(go).catch(function(){
      alert('Could not load drills.');
    });
  }

  // ===== UI actions =====
  if (btnMenu){
    btnMenu.addEventListener('click', function(){
      try{ window.location.href = '../drills/drills.html'; }catch(e){}
    });
  }

  if (btnNext){
    btnNext.addEventListener('click', function(){
      if (!slots.length) return;
      startDrill(index + 1, { fromSkip: true });
    });
  }

  if (doneBack){
    doneBack.addEventListener('click', function(){
      doneM.style.display='none';
      try{ window.location.href = '../drills/drills.html'; }catch(e){}
    });
  }

  if (doneRetry){
    doneRetry.addEventListener('click', function(){
      if (!hasDailyAttemptsLeftForCurrentMode()){
        showCapMsg();
        if (doneMsgEl) doneMsgEl.textContent = 'You reached your drills limit.';
        doneRetry.disabled = true;
        doneRetry.style.opacity = '.6';
        doneRetry.style.cursor = 'not-allowed';
        return;
      }

      recordDailyAttemptForCurrentMode();

      doneM.style.display = 'none';
      resetStats();
      reshuffleSlots();
      newRunPlan();
      blitzCornerState = null;
      timeUp = false;

      if (blitzMode){
        timerMs = 0;
        if (timerEl){
          timerEl.style.display = 'inline-flex';
          timerEl.textContent = fmtMs(timerMs);
        }
        startTimer();
      } else {
        if (timerEl) timerEl.style.display = 'none';
        stopTimer();
      }

      if (slots.length) startDrill(0);
    });
  }

  // ===== Auto start (standalone board page) =====
  function autoStart(){
    DrillLoad(null, { perJoseki: 3 });
  }

  window.addEventListener('load', function(){
    initWhenReady();
    // delay autoStart slightly so board sizing is stable
    setTimeout(autoStart, 60);
  });

})();
</script>

</body>
</html>
