<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Master – Drills Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    html, body{
      margin:0;
      padding:0;
      min-height:100%;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background-image:url("../img/wood.jpg");
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
      overscroll-behavior:none;
    }

    @media (max-width: 480px){
      #go-board-drill-wrap { padding:8px 12px 0; }
    }

    /* we don’t hide the wrapper via data-hidden now, so it’s always visible */
    #go-board-drill canvas{ display:block; margin:0 auto; }

    .prac-ctrls{
      max-width:720px; margin:10px auto 0;
      padding:8px 12px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
    }
    .pbtn{
      padding:12px 16px; border-radius:12px; border:1px solid #cbd5e1;
      background:#fff; font-weight:800; font-size:15px; color:#0f172a;
      cursor:pointer; box-shadow:0 2px 8px rgba(15,23,42,.06);
    }
    .pbtn:active{ transform:translateY(1px); }
    .pbtn-strong{ background:#111827; color:#fff; border-color:#111827; }
    .pbtn-alt{ background:#e7f0ff; color:#0b4aa2; border-color:#a7c1ff; }

    /* Blitz timer chip */
    #blitz-timer{
      position:absolute; right:10px; top:10px; z-index:4;
      padding:6px 10px; border-radius:10px;
      font-weight:900; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background:rgba(15,23,42,.88); color:#e6f3ff; border:1px solid rgba(148,163,184,.35);
      box-shadow:0 6px 16px rgba(2,6,23,.35);
      letter-spacing:0.5px;
    }
  </style>
<style>
  /* Fullscreen zoom overlay for drills (Practice-style zoom) */
  #go-zoom-overlay-drill{
    position:fixed;
    inset:0;
    z-index:99998;
    display:none;
    align-items:center;
    justify-content:center;
    background:transparent;
    -webkit-tap-highlight-color:transparent;
    touch-action:none;
  }

  #go-zoom-stage-drill{
    width:100vw;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    touch-action:none;
  }

  #go-zoom-exit-drill{
    position:fixed;
    left:14px;
    bottom:90px;
    width:120px;
    height:80px;
    border-radius:9px;

    background:rgba(148,163,184,.35);
    border:1px solid rgba(148,163,184,.85);
    box-shadow:0 6px 16px rgba(0,0,0,.55);

    display:none;
    cursor:pointer;
    z-index:99999;
    backdrop-filter:blur(2px);
    -webkit-tap-highlight-color:transparent;
  }

  #go-zoom-exit-drill::before{
    content:"";
  }
</style>

</head>
<body>

<!-- ================= DRILL BOARD (adds Blitz mode) ================= -->
<div id="go-board-drill-wrap" style="width:100%;max-width:720px;margin:0 auto;box-sizing:border-box;">
  <div id="go-board-drill"
       style="position:relative;width:100%;border-radius:10px;overflow:hidden;box-shadow:
        0 18px 40px rgba(0,0,0,.32),
        0 6px 16px rgba(0,0,0,.22);">
    <!-- Blitz timer (created by JS if needed) -->
  </div>

  <div id="drill-ctrls" class="prac-ctrls">
    <button id="dbtn-menu"  class="pbtn pbtn-strong" type="button">Back</button>
    <button id="dbtn-next"  class="pbtn pbtn-alt"   type="button">Next</button>
    <div id="drill-progress" style="font-weight:800;opacity:.9;">1 / 1</div>
  </div>
</div>

<!-- Wrong Move (drill) -->
<div id="drill-wrong" style="display:none;position:fixed;inset:0;z-index:99999;align-items:center;justify-content:center;">
  <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
  <div style="position:relative;z-index:1;background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 12px 28px rgba(15,23,42,.18);width:min(86vw,420px);padding:16px;text-align:center;font-family:system-ui,Segoe UI,Arial,sans-serif;color:#0f172a;">
    <div style="font-weight:800;font-size:18px;margin-bottom:2px;">Wrong</div>
  </div>
</div>

<!-- Drill Cleared (auto-dismiss) -->
<div id="drill-cleared" style="display:none;position:fixed;inset:0;z-index:99999;align-items:center;justify-content:center;">
  <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
  <div style="position:relative;z-index:1;background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 12px 28px rgba(15,23,42,.18);width:min(86vw,420px);padding:16px;text-align:center;font-family:system-ui,Segoe UI,Arial,sans-serif;color:#0f172a;">
    <div style="font-weight:800;font-size:18px;margin-bottom:2px;">Cleared</div>
  </div>
</div>


<div id="drill-done" style="display:none;position:fixed;inset:0;z-index:99999;align-items:center;justify-content:center;">
  <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
  <div style="position:relative;z-index:1;background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 12px 28px rgba(15,23,42,.18);width:min(86vw,460px);padding:16px;text-align:center;font-family:system-ui,Segoe UI,Arial,sans-serif;color:#0f172a;">
    <div id="drill-done-title" style="font-weight:800;font-size:18px;margin-bottom:8px;">All Drills Complete</div>

    <!-- Stats block -->
    <div id="drill-stats" style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin:6px 0 10px;">
      <div style="border:1px solid #e2e8f0;border-radius:10px;padding:10px 14px;min-width:140px;">
        <div style="font-weight:800;opacity:.8;margin-bottom:2px;">Solved</div>
        <div id="drill-stat-solved" style="font-weight:900;font-size:22px;line-height:1;">0</div>
      </div>
      <div style="border:1px solid #e2e8f0;border-radius:10px;padding:10px 14px;min-width:140px;">
        <div style="font-weight:800;opacity:.8;margin-bottom:2px;">Failed</div>
        <div id="drill-stat-failed" style="font-weight:900;font-size:22px;line-height:1;">0</div>
      </div>
    </div>

    <!-- Message BELOW the stats -->
    <div id="drill-done-msg" style="color:#334155;margin-bottom:14px;">Session finished. You can retry the set or go back to selection.</div>

    <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
      <button id="drill-done-back"  style="padding:8px 14px;border-radius:8px;border:1px solid #cbd5e1;background:#e7f0ff;color:#0b4aa2;font-weight:700;cursor:pointer;">Back to selection</button>
      <button id="drill-done-retry" style="padding:8px 14px;border-radius:8px;border:1px solid #cbd5e1;background:#f1f5f9;color:#0f172a;font-weight:700;cursor:pointer;">Retry set</button>
    </div>
  </div>
</div>

<!-- Run Cap overlay -->
<div id="drill-cap" style="display:none;position:fixed;inset:0;z-index:100000;align-items:center;justify-content:center;">
  <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
  <div style="position:relative;z-index:1;background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 12px 28px rgba(15,23,42,.18);width:min(86vw,460px);padding:16px;text-align:center;font-family:system-ui,Segoe UI,Arial,sans-serif;color:#0f172a;">
    <div style="font-weight:800;font-size:18px;margin-bottom:8px;">Limit Reached</div>
    <div style="color:#334155;margin-bottom:14px;">You’ve reached your current drills limit.</div>
    <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
      <button id="drill-cap-ok" style="padding:8px 14px;border-radius:8px;border:1px solid #cbd5e1;background:#f1f5f9;color:#0f172a;font-weight:700;cursor:pointer;">OK</button>
    </div>
  </div>
</div>

<!-- WGo (if not already loaded) -->
<script>
if (!window.WGo) {
  var s = document.createElement('script');
  s.src = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754893285939x971907393576095400/wgo.min.js";
  s.async = true;
  document.head.appendChild(s);
}
</script>

<script>
if (!window.StoneSFX) {
  window.StoneSFX = (() => {
    let pool = [], i = 0;
    function init(url, voices = 5){
      pool = Array.from({ length: voices }, () => {
        const a = new Audio(url); a.preload = 'auto'; a.volume = 0.35; return a;
      });
      const unlock = () => {
        pool.forEach(a => { try{ a.play().then(()=>a.pause()).catch(()=>{}); a.currentTime=0; }catch(e){} });
        window.removeEventListener('touchstart', unlock); window.removeEventListener('mousedown', unlock);
      };
      window.addEventListener('touchstart', unlock, { once:true });
      window.addEventListener('mousedown', unlock, { once:true });
    }
    function play(){
      if (!pool.length) return;
      const a = pool[i++ % pool.length];
      try { a.currentTime=0; a.playbackRate=0.97+Math.random()*0.06; a.play(); } catch(e){}
    }
    return { init, play };
  })();
  StoneSFX.init("https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754926303439x491369894441766600/klick.mp3");
}
</script>

<script>
(function(){
  console.log("Drill Script Starting...");

  // --- 1. SGF UTILS ---
  function parseSZ(sz){ if(!sz) return 19; const n=parseInt(sz.split(':')[0],10); return (n>=2&&n<=52)?n:19; }
  function xy(s,S){ if(!s||s.length<2) return null; const x=s.charCodeAt(0)-97,y=s.charCodeAt(1)-97; if(x<0||y<0||x>=S||y>=S) return null; return {x,y}; }
  function nodeMove(n,S){ if(!n) return null; if(n.B){ const p=xy(n.B,S); if(p) return {x:p.x,y:p.y,color:'B'}; } if(n.W){ const p=xy(n.W,S); if(p) return {x:p.x,y:p.y,color:'W'}; } return null; }
  function listCoords(prop,S){ const arr=Array.isArray(prop)?prop:(prop?[prop]:[]); const out=[]; for(const v of arr){ const p=xy(v,S); if(p) out.push(p); } return out; }
  
  function parseTree(str,i){
    const seq=[]; let node=null; if(str[i]!=='(') return {seq:[],n:i}; i++;
    function rb(str,i){ let out='',k=i; while(k<str.length){ const ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; } if(ch===']') break; out+=ch; } return {t:out,n:k}; }
    while(i<str.length){
      const ch=str[i];
      if(ch===';'){ node={}; seq.push(node); i++; }
      else if(/[A-Za-z]/.test(ch)){
        let key=''; while(/[A-Za-z]/.test(str[i]||'')) key+=str[i++]; const vals=[];
        while(str[i]==='['){ const r=rb(str,i+1); vals.push(r.t); i=r.n; }
        if(!node){ node={}; seq.push(node); } node[key]=vals.length>1?vals:vals[0];
      } else if(ch==='('){ const child=parseTree(str,i); i=child.n; if(seq.length){ const p=seq[seq.length-1]; (p.variations||(p.variations=[])).push(child.seq); } }
      else if(ch===')'){ i++; break; } else i++;
    }
    for(let k=0;k<seq.length-1;k++) seq[k].next=seq[k+1];
    return {seq,n:i};
  }

  function parseAllTrees(str){
    const trees=[]; let i=str.indexOf('(');
    if (str.charCodeAt && str.charCodeAt(0)===0xFEFF) str = str.slice(1);
    while(i>=0 && i<str.length){
      const r = parseTree(str,i);
      if (r.seq && r.seq.length) trees.push(r.seq);
      const nxt = str.indexOf('(', r.n);
      if (nxt === -1) break; i = nxt;
    }
    return trees;
  }
  
  function linkify(seq,parent){ for(let i=0;i<seq.length;i++){ const n=seq[i]; n.prev=(i===0?parent:seq[i-1]); n.next=(i<seq.length-1?seq[i+1]:null); if(n.variations) for(const v of n.variations) if(v&&v.length) linkify(v,n); } }

  function enumerateLines(seq,S){
    const lines=[]; let start=seq&&seq[0]; while(start && !nodeMove(start,S) && !start.variations) start=start.next;
    function dfs(node,acc){ if(!node){ lines.push(acc.slice()); return; }
      acc.push(node);
      if(node.variations && node.variations.length){
        for(const v of node.variations){
          let f=v&&v[0]; while(f && !nodeMove(f,S) && !f.variations) f=f.next;
          if(f) dfs(f,acc.slice());
        }
      }
      if(node.next){ let nx=node.next; while(nx && !nodeMove(nx,S) && !nx.variations) nx=nx.next;
        if(nx) dfs(nx,acc); else lines.push(acc.slice()); }
      else lines.push(acc.slice());
    }
    if(start) dfs(start,[]); 
    return lines.map(nodes=>nodes.map(n=>nodeMove(n,S)).filter(Boolean));
  }

  // --- 2. TRANSFORMS ---
  function t_identity(p){ return {x:p.x,y:p.y}; }
  function t_swap(p){ return {x:p.y, y:p.x}; }
  function t_rot90(p,S){  return {x: S-1 - p.y, y: p.x}; }
  function t_rot180(p,S){ return {x: S-1 - p.x, y: S-1 - p.y}; }
  function t_rot270(p,S){ return {x: p.y, y: S-1 - p.x}; }
  function compose(a,b,S){ return function(p){ return a(b(p,S),S); }; }
  function ORIENT_FUNCS(S){
    return [
      p=>t_identity(p), p=>t_swap(p),
      p=>t_rot90(p,S), p=>compose(t_swap,t_rot90,S)(p),
      p=>t_rot180(p,S), p=>compose(t_swap,t_rot180,S)(p),
      p=>t_rot270(p,S), p=>compose(t_swap,t_rot270,S)(p)
    ];
  }
  const ROT_IDX_ONLY = [0,2,4,6];
  function makeTransformed(line, orientIdx, swap){
    const S = line.size || 19, ORS = ORIENT_FUNCS(S), o = ORS[orientIdx % ORS.length];
    const tf = p => { const t=o({x:p.x,y:p.y}, S); return {x:t.x,y:t.y}; };
    const AB = (line.rootAB||[]).map(tf), AW = (line.rootAW||[]).map(tf);
    const mv = (line.moves||[]).map(m=>{ const t=tf(m); const c = swap ? (m.color==='B'?'W':'B') : m.color; return { x:t.x, y:t.y, color:c }; });
    return { size:S, rootAB: swap ? AW : AB, rootAW: swap ? AB : AW, moves: mv };
  }

  // --- 3. STATE & UI VARIABLES ---
  var SIZE = 19;
  var mount = document.getElementById('core-board');
  var wrap  = document.getElementById('core-board-wrap');
  var exitBtn = document.getElementById('zoom-exit-btn');
  var board = null;
  var grid = []; 

  // Drill State
  var slots = [], runPlan = {}, index = 0, remain = [], currentTransformed = null;
  var solvedCount = 0, failedCount = 0, locked = false;
  var blitzMode = false, timerMs = 0, timerId = null, blitzPlanned = 0, timeUp = false;
  var blitzCornerState = null;
  var MIN_MOVES = 5; 
  
  // UI Elements
  var progEl = document.getElementById('drill-progress');
  var wrongM = document.getElementById('drill-wrong');
  var clearedM = document.getElementById('drill-cleared');
  var doneM = document.getElementById('drill-done');
  var timerEl = null;

  // Zoom State
  var scale = 1, minScale = 1, maxScale = 2.6;
  var offsetX = 0, offsetY = 0, baseW = 0; 
  var zoomLayer = null;
  var isFullscreen = false, isZoomAnimating = false, animId = 0;
  var returnAnchor = null; 
  var isPanning = false, panStart = null, tapStart = null;
  var TAP_SLOP2 = 64; 
  var isFlinging = false, flingId = 0, flingVX = 0, flingVY = 0, flingLastTime = 0;
  var panSamplePrev = null, panSampleCurr = null;

  // Prefs
  var zoomEnabled = (window.GoPrefs && typeof window.GoPrefs.josekiZoom !== 'undefined') ? !!window.GoPrefs.josekiZoom : true;
  var disableAutoZoomOut = (window.GoPrefs && typeof window.GoPrefs.disableAutoZoomOut !== 'undefined') ? !!window.GoPrefs.disableAutoZoomOut : false;

  // --- 4. BOARD INIT ---
  function ensureTimerEl(){
    if (timerEl || !blitzMode) return;
    timerEl = document.createElement('div');
    timerEl.id = 'blitz-timer';
    timerEl.textContent = '0.0s';
    mount.appendChild(timerEl);
  }

  function initBoard(){
    if (!window.WGo) return setTimeout(initBoard, 40);
    if (board) return;

    board = new WGo.Board(mount, { size: SIZE });

    // Wood Background (Zoom Layer)
    (function ensureDrillWoodLayer(){
      if (mount.__woodLayerReady) return;
      const layer = document.createElement('div');
      layer.id = 'go-drill-wood';
      layer.style.position = 'absolute';
      layer.style.left = '0'; layer.style.top = '0'; layer.style.right = '0'; layer.style.bottom = '0';
      layer.style.backgroundImage = "url('https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1755870506985x437178801728222500/wood.jpg')";
      layer.style.backgroundSize = 'cover'; layer.style.backgroundPosition = 'center'; layer.style.backgroundRepeat = 'no-repeat';
      layer.style.willChange = 'left, top, width, height';
      mount.appendChild(layer);
      function moveChildrenIntoLayer(){
         const kids = Array.from(mount.childNodes).filter(n => n !== layer);
         for (const n of kids) layer.appendChild(n);
      }
      moveChildrenIntoLayer();
      const mo = new MutationObserver(moveChildrenIntoLayer);
      mo.observe(mount, { childList: true });
      mount.__woodLayerReady = true; mount.__woodLayer = layer; mount.__woodObserver = mo;
    })();

    mount.style.position = 'relative'; mount.style.overflow = 'hidden';
    zoomLayer = mount.__woodLayer || mount;
    
    setTimeout(function(){ fitBoard(); }, 50);

    bindClicks();
    window.addEventListener('resize', () => setTimeout(fitBoard, 10));
    exitBtn.addEventListener('click', (e)=>{ e.stopPropagation(); smoothZoomOutAndExit(); });
    
    loadAndStart();
  }

  // --- 5. ZOOM LOGIC ---
  function canvasCssScale(){
    var c = mount.querySelector('canvas');
    if (!c) return 1;
    return (c.clientWidth || 0) / (c.width || 1);
  }
  function getXcss(i){ return board.getX(i) * canvasCssScale(); }
  function getYcss(j){ return board.getY(j) * canvasCssScale(); }
  function viewportSize(){ return { vw: mount.clientWidth, vh: mount.clientHeight }; }
  
  function clampPan(){
    if (isZoomAnimating) return;
    const {vw, vh} = viewportSize();
    const bw = Math.round(baseW * scale);
    const bleedX = Math.ceil(vw * 0.5), bleedY = Math.ceil(vh * 0.5);
    const minOX = -bleedX, maxOX = Math.max(0, bw - vw) + bleedX;
    const minOY = -bleedY, maxOY = Math.max(0, bw - vh) + bleedY;
    offsetX = Math.max(minOX, Math.min(offsetX, maxOX));
    offsetY = Math.max(minOY, Math.min(offsetY, maxOY));
  }

  function applyPanAndSize(redrawAfter){
    if (board && board._lastW !== baseW) {
      board.setWidth(baseW);
      if (zoomLayer) { zoomLayer.style.width = baseW + 'px'; zoomLayer.style.height = baseW + 'px'; }
      board._lastW = baseW;
      if (!redrawAfter) redrawAfter = true;
    }
    clampPan();
    if (zoomLayer) zoomLayer.style.transform = 'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';
    if (redrawAfter) redrawBoard();
  }

  function animateTo(targetScale, pxWorld, pyWorld, sxTarget, syTarget){
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
    cancelFling();
    const s0 = scale, ox0 = offsetX, oy0 = offsetY;
    const t0 = performance.now(), dur = 300;
    cancelAnimationFrame(animId); isZoomAnimating = true;
    const targetOffsetX = (pxWorld * targetScale) - sxTarget;
    const targetOffsetY = (pyWorld * targetScale) - syTarget;
    (function step(now){
      let t = (now - t0) / dur; if (t > 1) t = 1;
      const e = 1 - Math.pow(1 - t, 3);
      scale = s0 + (targetScale - s0) * e;
      offsetX = ox0 + (targetOffsetX - ox0) * e;
      offsetY = oy0 + (targetOffsetY - oy0) * e;
      applyPanAndSize(false);
      if (t < 1) animId = requestAnimationFrame(step);
      else { isZoomAnimating = false; applyPanAndSize(true); }
    })(t0);
  }

  function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
    if (isFullscreen) return;
    cancelFling();
    returnAnchor = document.createElement('div');
    returnAnchor.style.width = mount.clientWidth + 'px'; returnAnchor.style.height = mount.clientHeight + 'px';
    mount.parentNode.insertBefore(returnAnchor, mount);
    document.body.appendChild(mount);
    mount.classList.add('is-fullscreen'); isFullscreen = true; exitBtn.style.display = 'flex';
    mount.style.width = '100vw'; mount.style.height = '100vh';
    scale = 1; offsetX = 0; offsetY = 0;
    const vw = window.innerWidth, vh = window.innerHeight;
    baseW = Math.floor(Math.min(vw, vh)); if (baseW % 2) baseW--;
    requestAnimationFrame(function(){
      applyPanAndSize(true);
      const initialFactor = 2.4;
      const px_curr = getXcss(i); const py_curr = getYcss(j);
      const rect = mount.getBoundingClientRect();
      let sx = rect.width / 2, sy = rect.height / 2;
      if (typeof tapClientX === 'number'){ sx = tapClientX - rect.left; sy = tapClientY - rect.top; }
      offsetX = px_curr * 1.0 - sx; offsetY = py_curr * 1.0 - sy;
      applyPanAndSize(false);
      animateTo(initialFactor, px_curr, py_curr, sx, sy);
    });
  }

  function exitFullscreen(){
    cancelFling(); cancelAnimationFrame(animId); isZoomAnimating = false;
    mount.classList.remove('is-fullscreen'); exitBtn.style.display = 'none'; isFullscreen = false;
    if (returnAnchor && returnAnchor.parentNode){
      returnAnchor.parentNode.insertBefore(mount, returnAnchor);
      returnAnchor.parentNode.removeChild(returnAnchor); returnAnchor = null;
    }
    mount.style.width = ''; mount.style.height = '';
    fitBoard(); resetViewLocal();
  }

  function fitBoard(){
    if (isFullscreen) return; 
    var w = wrap.getBoundingClientRect().width;
    w = Math.floor(w); if(w%2) w--;
    baseW = w; mount.style.width = w+'px'; mount.style.height = w+'px';
    applyPanAndSize(true);
  }
  function resetViewLocal(){ scale = 1; offsetX = 0; offsetY = 0; applyPanAndSize(true); }
  function smoothZoomOutAndExit(){ if (!zoomEnabled) return; cancelFling(); scale = 1; offsetX = 0; offsetY = 0; applyPanAndSize(true); if (isFullscreen) exitFullscreen(); }

  // --- 6. INPUT HANDLING ---
  function bindClicks(){
    function getGridSpacing(){ var sX = Math.abs(getXcss(1)-getXcss(0)); var sY = Math.abs(getYcss(1)-getYcss(0)); return {x:sX, y:sY}; }

    mount.addEventListener('pointerdown', function(e){
      if (!zoomEnabled) return;
      if (e.pointerType !== 'touch' && e.button !== 0) return;
      cancelFling();
      const r = mount.getBoundingClientRect();
      const sx = e.clientX - r.left, sy = e.clientY - r.top;
      const boardX = (sx + offsetX) / scale, boardY = (sy + offsetY) / scale;
      
      let bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
      for (let i=0; i<SIZE; i++){ const dx = Math.abs(getXcss(i)-boardX); if (dx<bestDx){ bestDx=dx; bestI=i; } }
      for (let j=0; j<SIZE; j++){ const dy = Math.abs(getYcss(j)-boardY); if (dy<bestDy){ bestDy=dy; bestJ=j; } }
      
      const spacing = getGridSpacing();
      if (bestDx > spacing.x * 0.5 || bestDy > spacing.y * 0.5) { tapStart = null; return; }
      
      panStart = { x:e.clientX, y:e.clientY, ox:offsetX, oy:offsetY };
      try { mount.setPointerCapture(e.pointerId); } catch(_){}
      tapStart = { x:e.clientX, y:e.clientY, ox:offsetX, oy:offsetY, gridI:bestI, gridJ:bestJ };
    }, {passive:false});

    mount.addEventListener('pointermove', function(e){
      if (!zoomEnabled || !panStart) return;
      if (scale <= 1.01 && !isFullscreen) return;
      const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y;
      if (!isPanning && (dx*dx + dy*dy > TAP_SLOP2)) isPanning = true;
      if (isPanning) {
        offsetX = panStart.ox - dx; offsetY = panStart.oy - dy;
        applyPanAndSize(false); e.preventDefault();
        const now = performance.now();
        panSamplePrev = panSampleCurr; panSampleCurr = { ox:offsetX, oy:offsetY, t:now };
      }
    }, {passive:false});

    mount.addEventListener('pointerup', function(e){
      if (!zoomEnabled) {
         const r = mount.getBoundingClientRect();
         const bx = e.clientX - r.left, by = e.clientY - r.top;
         let bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
         for (let i=0; i<SIZE; i++){ const dx = Math.abs(getXcss(i)-bx); if (dx<bestDx){ bestDx=dx; bestI=i; } }
         for (let j=0; j<SIZE; j++){ const dy = Math.abs(getYcss(j)-by); if (dy<bestDy){ bestDy=dy; bestJ=j; } }
         const spacing = getGridSpacing();
         if (bestDx > spacing.x*0.5 || bestDy > spacing.y*0.5) return;
         e.preventDefault(); playAt(bestI, bestJ); return;
      }
      if (!tapStart) { if (panStart) try { mount.releasePointerCapture(e.pointerId); panStart=null; } catch(_){} return; }
      try { mount.releasePointerCapture(e.pointerId); } catch(_){}
      const dist2 = (e.clientX - tapStart.x)**2 + (e.clientY - tapStart.y)**2;
      const { gridI, gridJ } = tapStart; const tapX=tapStart.x, tapY=tapStart.y;
      tapStart=null; panStart=null;
      if (isPanning) {
        isPanning = false;
        if (panSamplePrev && panSampleCurr) {
          const dt = panSampleCurr.t - panSamplePrev.t;
          if (dt>0 && dt<120) startFling((panSampleCurr.ox - panSamplePrev.ox)/dt, (panSampleCurr.oy - panSamplePrev.oy)/dt);
        }
        return;
      }
      if (dist2 <= TAP_SLOP2) {
        e.preventDefault();
        if (scale <= 1.05 && !isFullscreen) enterFullscreenAtGrid(gridI, gridJ, tapX, tapY);
        else playAt(gridI, gridJ);
      }
    }, {passive:false});
  }

  function startFling(vx, vy){
    if (scale <= 1) return; cancelFling();
    var speed = Math.sqrt(vx*vx + vy*vy), MAX_SPEED = 0.50;
    if (speed > MAX_SPEED){ var s = MAX_SPEED/speed; vx*=s; vy*=s; speed=MAX_SPEED; }
    if (speed < 0.04) return;
    isFlinging = true; flingVX = vx; flingVY = vy; flingLastTime = performance.now();
    (function step(now){
      if (!isFlinging) return;
      var dt = now - flingLastTime; if (dt<=0){ flingId = requestAnimationFrame(step); return; }
      if (dt>50) dt=50; flingLastTime = now;
      offsetX += flingVX * dt; offsetY += flingVY * dt;
      var friction = 0.0010, currentSpeed = Math.sqrt(flingVX*flingVX + flingVY*flingVY), decel = friction*dt;
      if (currentSpeed <= 0.01 || decel >= currentSpeed){ cancelFling(); applyPanAndSize(true); return; }
      var scaleFactor = (currentSpeed - decel) / currentSpeed;
      flingVX *= scaleFactor; flingVY *= scaleFactor;
      applyPanAndSize(false); flingId = requestAnimationFrame(step);
    })(performance.now());
  }
  function cancelFling(){ isFlinging = false; if (flingId) { cancelAnimationFrame(flingId); flingId = 0; } }


  // --- 7. GAME ENGINE ---
  function resetGrid(){ grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null)); }
  function addStone(x,y,color){ grid[y][x]=color; }
  
  function resolveCapturesAfterPlacing(x,y,color){
    function neigh4(x,y){ return [{x:x+1,y:y},{x:x-1,y:y},{x:x,y:y+1},{x:x,y:y-1}].filter(p=>p.x>=0&&p.x<SIZE&&p.y>=0&&p.y<SIZE); }
    function groupAndLibs(x,y){
       const c=grid[y][x]; if(!c) return {stones:[],libs:0};
       const stack=[{x,y}], seen=new Set(), libs=new Set(), stones=[]; seen.add(x+','+y);
       while(stack.length){
         const p=stack.pop(); stones.push(p);
         neigh4(p.x,p.y).forEach(n=>{
           const v=grid[n.y][n.x];
           if(v===null) libs.add(n.x+','+n.y);
           else if(v===c){ const k=n.x+','+n.y; if(!seen.has(k)){ seen.add(k); stack.push(n); } }
         });
       }
       return {stones, libs:libs.size};
    }
    function removeGroup(gx, gy){
        const c = grid[gy][gx]; if(!c) return;
        const stack=[{x:gx,y:gy}], seen=new Set(); seen.add(gx+','+gy);
        while(stack.length){
            const p=stack.pop(); grid[p.y][p.x] = null;
            neigh4(p.x,p.y).forEach(n=>{
                if(grid[n.y][n.x]===c && !seen.has(n.x+','+n.y)){
                    seen.add(n.x+','+n.y); stack.push(n);
                }
            });
        }
    }
    const opp = color==='B'?'W':'B', seenOpp = new Set();
    neigh4(x,y).forEach(n=>{
       if(grid[n.y][n.x]===opp){
         const k=n.x+','+n.y; if(seenOpp.has(k)) return;
         const g=groupAndLibs(n.x,n.y);
         g.stones.forEach(s=>seenOpp.add(s.x+','+s.y));
         if(g.libs===0) removeGroup(n.x, n.y);
       }
    });
  }

  function playMove(x,y,color, silent=false){
    addStone(x,y,color);
    resolveCapturesAfterPlacing(x,y,color);
    if (!silent && window.StoneSFX) StoneSFX.play();
    redrawBoard();
  }

  function redrawBoard(){
    if (!board) return;
    board.removeAllObjects();
    for(var y=0; y<SIZE; y++) for(var x=0; x<SIZE; x++){
       var v = grid[y][x];
       if(v==='B') board.addObject({x:x, y:y, c:WGo.B});
       if(v==='W') board.addObject({x:x, y:y, c:WGo.W});
    }
    if(blitzMode) drawBlitzMarkers();
  }
  
  function drawBlitzMarkers(){
     if(!currentTransformed || !currentTransformed.moves || currentTransformed.moves.length<1) return;
     const m1 = currentTransformed.moves[0];
     board.addObject({ x:m1.x, y:m1.y, type:'LB', text:'A' });
     if(currentTransformed.moves.length>=2 && isCornerHoshi(m1)){
        const m2 = currentTransformed.moves[1];
        board.addObject({ x:m2.x, y:m2.y, type:'LB', text:'a' });
        if(currentTransformed.moves.length>=3){
           const below = corner33Below(m1);
           if(m2.x===below.x && m2.y===below.y){
              const m3 = currentTransformed.moves[2];
              board.addObject({ x:m3.x, y:m3.y, type:'LB', text:'A' });
           }
        }
     }
  }
  function isCornerHoshi(p){ return (p.x===3||p.x===SIZE-4) && (p.y===3||p.y===SIZE-4); }
  function corner33Below(p){ const dx=(p.x===3)?-1:1; const dy=(p.y===3)?-1:1; return {x:p.x+dx,y:p.y+dy}; }

  function playAt(x, y){
    if (locked || timeUp) return;
    if (x<0 || y<0 || x>=SIZE || y>=SIZE) return;
    if (grid[y][x] !== null) return;
    if (!remain.length) return;

    const next = remain[0];
    if (next.x === x && next.y === y) {
      playMove(x, y, next.color, false);
      remain.shift();
      if (!disableAutoZoomOut && scale > 1) setTimeout(smoothZoomOutAndExit, 10);
      if (!remain.length) {
         solvedCount++;
         if (blitzMode){ timerMs += blitzPlanned * 500; if (timerEl) timerEl.textContent = fmtMs(timerMs); }
         if (index >= (slots.length - 1)) showClearedThenDone();
         else showClearedAuto();
      }
    } else {
      failedCount++;
      if (blitzMode) showWrongThenRestart();
      else showWrongAuto();
    }
  }

  // --- 8. DRILL LIFECYCLE ---
  function startDrill(i){
    console.log("Start Drill " + i);
    index = i;
    if (index >= slots.length){ showDone(); return; }
    const slot = slots[index], base = slot.base, key = slot.key;
    SIZE = base.size || 19;
    if (!board) initBoard();
    clearTimers();

    if(!runPlan[key]) runPlan[key] = buildRunPlan(key, base, lineToSlotIdxs[key]||[]);
    const variant = runPlan[key].get(index);
    const tline = makeTransformed(base, variant.orientIdx, variant.swap);
    currentTransformed = tline;

    resetGrid();
    (tline.rootAB||[]).forEach(p=>addStone(p.x,p.y,'B'));
    (tline.rootAW||[]).forEach(p=>addStone(p.x,p.y,'W'));
    
    const startIdx = Math.max(0, Math.min(variant.startIndex, tline.moves.length-2));
    for(let s=0; s<startIdx; s++){ const m=tline.moves[s]; playMove(m.x,m.y,m.color, true); }
    remain = tline.moves.slice(startIdx).map(m=>({x:m.x,y:m.y,color:m.color}));
    
    blitzPlanned = remain.length;
    if(blitzMode){
       ensureTimerEl(); timerEl.style.display='block';
       timerMs += blitzPlanned * 1500;
       if(!timerId) startTimer();
       timerEl.textContent = fmtMs(timerMs);
       blitzCornerState = { tline, startIdx, planned: blitzPlanned };
    } else {
       if(timerEl) timerEl.style.display='none';
       stopTimer();
    }
    if(progEl) progEl.textContent = (index+1) + ' / ' + slots.length;
    locked = false;
    redrawBoard();
  }
  
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function buildRunPlan(key, line, slotIdxs){
     const L = line.moves.length;
     const startsPool = []; for(let i=Math.max(4,0); i<=Math.max(4,L-2); i++) startsPool.push(i);
     const k = slotIdxs.length;
     const orientIdxs = shuffle([0,1,2,3,4,5,6,7]).slice(0, k||1);
     const chosenStarts = shuffle(startsPool).slice(0, k||1);
     let swaps = Array(k).fill(false); for(let i=0; i<Math.round(k*0.5); i++) swaps[i]=true; swaps=shuffle(swaps);
     const plan = new Map();
     const shuffledSlots = shuffle(slotIdxs.slice());
     for(let i=0; i<k; i++){
        plan.set(shuffledSlots[i], {
           orientIdx: orientIdxs[i % orientIdxs.length],
           startIndex: (blitzMode ? 0 : chosenStarts[i % chosenStarts.length]),
           swap: swaps[i]
        });
     }
     return plan;
  }
  
  function showWrongThenRestart(){ clearTimers(); wrongM.style.display='flex'; locked=true; wrongTimer=setTimeout(()=>{ wrongM.style.display='none'; restartBlitz(); }, 800); }
  function restartBlitz(){
     if(!blitzMode || !blitzCornerState) return;
     const { tline, startIdx } = blitzCornerState;
     resetGrid();
     (tline.rootAB||[]).forEach(p=>addStone(p.x,p.y,'B'));
     (tline.rootAW||[]).forEach(p=>addStone(p.x,p.y,'W'));
     for(let s=0; s<startIdx; s++){ const m=tline.moves[s]; playMove(m.x,m.y,m.color, true); }
     remain = tline.moves.slice(startIdx).map(m=>({x:m.x,y:m.y,color:m.color}));
     redrawBoard(); locked=false;
  }
  function showWrongAuto(){ clearTimers(); wrongM.style.display='flex'; locked=true; wrongTimer=setTimeout(()=>{ wrongM.style.display='none'; locked=false; if(index>=slots.length-1) showDone(); else startDrill(index+1); }, 1000); }
  function showClearedAuto(){ clearTimers(); clearedM.style.display='flex'; locked=true; clearedTimer=setTimeout(()=>{ clearedM.style.display='none'; locked=false; startDrill(index+1); }, 850); }
  function showClearedThenDone(){ clearTimers(); clearedM.style.display='flex'; locked=true; clearedTimer=setTimeout(()=>{ clearedM.style.display='none'; showDone(); }, 800); }
  function showDone(){
     clearTimers();
     document.getElementById('drill-stat-solved').textContent = solvedCount;
     document.getElementById('drill-stat-failed').textContent = failedCount;
     doneM.style.display='flex';
     if(blitzMode) stopTimer();
  }
  function clearTimers(){ if(wrongTimer) clearTimeout(wrongTimer); if(clearedTimer) clearTimeout(clearedTimer); }
  function fmtMs(ms){ if(ms<0)ms=0; const s=ms/1000, m=Math.floor(s/60), r=s-m*60; return m>0 ? `${m}:${r.toFixed(1).padStart(4,'0')}` : `${r.toFixed(1)}s`; }
  function startTimer(){ stopTimer(); timeUp=false; timerId=setInterval(()=>{ timerMs-=100; if(timerEl)timerEl.textContent=fmtMs(timerMs); if(timerMs<=0){ stopTimer(); timeUp=true; showDone(); } }, 100); }
  function stopTimer(){ if(timerId) clearInterval(timerId); timerId=null; }

  document.getElementById('dbtn-menu').addEventListener('click', ()=>{ try{window.location.href='../drills/drills.html'}catch(e){} });
  document.getElementById('drill-done-back').addEventListener('click', ()=>{ doneM.style.display='none'; try{window.location.href='../drills/drills.html'}catch(e){} });
  document.getElementById('drill-done-retry').addEventListener('click', ()=>{ 
     doneM.style.display='none'; solvedCount=0; failedCount=0; index=0; 
     if(blitzMode){ timerMs=0; ensureTimerEl(); timerEl.textContent=fmtMs(timerMs); startTimer(); }
     startDrill(0); 
  });
  document.getElementById('dbtn-next').addEventListener('click', ()=>{ if(slots.length) startDrill(index+1); });

  // --- 9. LOAD AND START (Dual Strategy) ---
  function getDrillSelections(){
    try {
      if (typeof sessionStorage !== 'undefined') {
        var raw = sessionStorage.getItem('go:drills_next_selection');
        if (raw) return JSON.parse(raw);
      }
    } catch(e){}
    return null;
  }
  
  const OWN_STORE_KEY = 'go:ownpatterns';
  const FAV_KEY       = 'go_favorites';
  function loadOwnPatterns(){ try { return JSON.parse(localStorage.getItem(OWN_STORE_KEY) || '[]'); } catch(_){ return []; } }
  function readFavs(){ try { return JSON.parse(localStorage.getItem(FAV_KEY) || '{}') || {}; } catch(_){ return {}; } }
  function normalizeLineLike(obj){ return { size: obj.size||19, rootAB: obj.rootAB||[], rootAW: obj.rootAW||[], moves: (obj.moves||[]).map(m=>({x:m.x, y:m.y, color:m.color==='W'?'W':'B'})) }; }
  function lineKey(line){ const s=line.size||19, seq=(line.moves||[]).map(m=>(m.color||'B')[0]+':'+m.x+','+m.y).join('|'); return `${s}|${seq}`; }
  
  function startWithLines(usableLines, perJoseki){
      if (usableLines.length === 0) { alert("No drills available. Check internet or local storage."); return; }
      console.log("Starting with " + usableLines.length + " patterns");
      
      slots = []; lineToSlotIdxs = {}; runPlan = {};
      for(const base of usableLines){
         const key = lineKey(base);
         for(let k=0; k<perJoseki; k++) slots.push({key, base});
      }
      slots = shuffle(slots); 
      for(let i=0; i<slots.length; i++){
         const key = slots[i].key;
         if(!lineToSlotIdxs[key]) lineToSlotIdxs[key]=[];
         lineToSlotIdxs[key].push(i);
      }
      if(slots.length > 0) startDrill(0);
  }

  function loadAndStart(){
     const sel = getDrillSelections();
     const PER = 3;
     blitzMode = (sel && sel.mode==='blitz');
     
     // 1. Try Local file, 2. Try CDN, 3. Fallback to dummy
     const LOCAL_URL = "../sgf/library-1.sgf";
     const CDN_URL = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1756283064420x481184906507390100/game%20(1).sgf";
     // A tiny dummy SGF so board always loads something if offline
     const DUMMY_SGF = "(;GM[1]SZ[19]AB[pd][dd]AW[pp][dp];B[qn];W[nq];B[pj];W[nc];B[lc];W[ne])";

     const favMap = readFavs();
     const favLines = Object.values(favMap).map(normalizeLineLike);
     const ownAll = loadOwnPatterns().map(normalizeLineLike);

     function processSGF(text){
        const trees = parseAllTrees(text);
        const libLines = [];
        for(const seq of trees){
           linkify(seq,null);
           const size = parseSZ(seq[0]?.SZ);
           const rootAB = listCoords(seq[0]?.AB, size);
           const rootAW = listCoords(seq[0]?.AW, size);
           const paths = enumerateLines(seq,size);
           for(const moves of paths){
              if((moves?.length||0)>=MIN_MOVES) libLines.push({size, rootAB, rootAW, moves});
           }
        }
        
        let usable = [];
        if (sel) {
            if (sel.library && sel.library.length) usable = usable.concat(libLines.filter(l => sel.library.includes(lineKey(l))));
            if (sel.favorites && sel.favorites.length) usable = usable.concat(favLines.filter(l => sel.favorites.includes(lineKey(l))));
            if (sel.own && sel.own.length) usable = usable.concat(ownAll); 
        } else {
            usable = libLines;
        }
        
        if(usable.length === 0 && libLines.length > 0) usable = libLines; // Fallback to all if selection empty
        startWithLines(usable, PER);
     }

     console.log("Fetching local...");
     fetch(LOCAL_URL).then(r=>{ if(!r.ok) throw new Error("Local fail"); return r.text(); })
       .then(txt => { console.log("Local loaded"); processSGF(txt); })
       .catch(e => {
          console.warn("Local fetch failed, trying CDN...", e);
          fetch(CDN_URL).then(r=>{ if(!r.ok) throw new Error("CDN fail"); return r.text(); })
            .then(txt => { console.log("CDN loaded"); processSGF(txt); })
            .catch(e2 => {
               console.warn("CDN failed, loading dummy/local only", e2);
               // Try building from just favs/own
               let usable = [];
               if(sel && sel.favorites) usable = usable.concat(favLines.filter(l=>sel.favorites.includes(lineKey(l))));
               if(sel && sel.own) usable = usable.concat(ownAll);
               
               if(usable.length>0) startWithLines(usable, PER);
               else {
                  console.log("No local data, using Dummy SGF.");
                  processSGF(DUMMY_SGF);
               }
            });
       });
  }

  if (mount && !board) initBoard();
})();
</script>
</body>
</html>
