<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Master – Drills Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    html, body{
      margin:0;
      padding:0;
      min-height:100%;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background-image:url("../img/wood.jpg");
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
      overscroll-behavior:none;
    }

    @media (max-width: 480px){
      #go-board-drill-wrap { padding:8px 12px 0; }
    }

    /* we don’t hide the wrapper via data-hidden now, so it’s always visible */
    #go-board-drill canvas{ display:block; margin:0 auto; }

    .prac-ctrls{
      max-width:720px; margin:10px auto 0;
      padding:8px 12px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
    }
    .pbtn{
      padding:12px 16px; border-radius:12px; border:1px solid #cbd5e1;
      background:#fff; font-weight:800; font-size:15px; color:#0f172a;
      cursor:pointer; box-shadow:0 2px 8px rgba(15,23,42,.06);
    }
    .pbtn:active{ transform:translateY(1px); }
    .pbtn-strong{ background:#111827; color:#fff; border-color:#111827; }
    .pbtn-alt{ background:#e7f0ff; color:#0b4aa2; border-color:#a7c1ff; }

    /* Blitz timer chip */
    #blitz-timer{
      position:absolute; right:10px; top:10px; z-index:4;
      padding:6px 10px; border-radius:10px;
      font-weight:900; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background:rgba(15,23,42,.88); color:#e6f3ff; border:1px solid rgba(148,163,184,.35);
      box-shadow:0 6px 16px rgba(2,6,23,.35);
      letter-spacing:0.5px;
    }
  </style>
</head>
<body>

<!-- ================= DRILL BOARD (adds Blitz mode) ================= -->
<div id="go-board-drill-wrap" style="width:100%;max-width:720px;margin:0 auto;box-sizing:border-box;">
  <div id="go-board-drill"
       style="position:relative;width:100%;border-radius:10px;overflow:hidden;box-shadow:
        0 18px 40px rgba(0,0,0,.32),
        0 6px 16px rgba(0,0,0,.22);">
    <!-- Blitz timer (created by JS if needed) -->
  </div>

  <div id="drill-ctrls" class="prac-ctrls">
    <button id="dbtn-menu"  class="pbtn pbtn-strong" type="button">Back</button>
    <button id="dbtn-next"  class="pbtn pbtn-alt"   type="button">Next</button>
    <div id="drill-progress" style="font-weight:800;opacity:.9;">1 / 1</div>
  </div>
</div>

<!-- Wrong Move (drill) -->
<div id="drill-wrong" style="display:none;position:fixed;inset:0;z-index:99999;align-items:center;justify-content:center;">
  <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
  <div style="position:relative;z-index:1;background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 12px 28px rgba(15,23,42,.18);width:min(86vw,420px);padding:16px;text-align:center;font-family:system-ui,Segoe UI,Arial,sans-serif;color:#0f172a;">
    <div style="font-weight:800;font-size:18px;margin-bottom:2px;">Wrong</div>
  </div>
</div>

<!-- Drill Cleared (auto-dismiss) -->
<div id="drill-cleared" style="display:none;position:fixed;inset:0;z-index:99999;align-items:center;justify-content:center;">
  <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
  <div style="position:relative;z-index:1;background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 12px 28px rgba(15,23,42,.18);width:min(86vw,420px);padding:16px;text-align:center;font-family:system-ui,Segoe UI,Arial,sans-serif;color:#0f172a;">
    <div style="font-weight:800;font-size:18px;margin-bottom:2px;">Cleared</div>
  </div>
</div>

<!-- All Done -->
<div id="drill-done" style="display:none;position:fixed;inset:0;z-index:99999;align-items:center;justify-content:center;">
  <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
  <div style="position:relative;z-index:1;background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 12px 28px rgba(15,23,42,.18);width:min(86vw,460px);padding:16px;text-align:center;font-family:system-ui,Segoe UI,Arial,sans-serif;color:#0f172a;">
    <div id="drill-done-title" style="font-weight:800;font-size:18px;margin-bottom:8px;">All Drills Complete</div>

    <!-- Stats block -->
    <div id="drill-stats" style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin:6px 0 10px;">
      <div style="border:1px solid #e2e8f0;border-radius:10px;padding:10px 14px;min-width:140px;">
        <div style="font-weight:800;opacity:.8;margin-bottom:2px;">Solved</div>
        <div id="drill-stat-solved" style="font-weight:900;font-size:22px;line-height:1;">0</div>
      </div>
      <div style="border:1px solid #e2e8f0;border-radius:10px;padding:10px 14px;min-width:140px;">
        <div style="font-weight:800;opacity:.8;margin-bottom:2px;">Failed</div>
        <div id="drill-stat-failed" style="font-weight:900;font-size:22px;line-height:1;">0</div>
      </div>
    </div>

    <!-- Message BELOW the stats -->
    <div id="drill-done-msg" style="color:#334155;margin-bottom:14px;">Session finished. You can retry the set or go back to selection.</div>

    <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
      <button id="drill-done-back"  style="padding:8px 14px;border-radius:8px;border:1px solid #cbd5e1;background:#e7f0ff;color:#0b4aa2;font-weight:700;cursor:pointer;">Back to selection</button>
      <button id="drill-done-retry" style="padding:8px 14px;border-radius:8px;border:1px solid #cbd5e1;background:#f1f5f9;color:#0f172a;font-weight:700;cursor:pointer;">Retry set</button>
    </div>
  </div>
</div>

<!-- Run Cap overlay -->
<div id="drill-cap" style="display:none;position:fixed;inset:0;z-index:100000;align-items:center;justify-content:center;">
  <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
  <div style="position:relative;z-index:1;background:#fff;border:1px solid #e2e8f0;border-radius:10px;box-shadow:0 12px 28px rgba(15,23,42,.18);width:min(86vw,460px);padding:16px;text-align:center;font-family:system-ui,Segoe UI,Arial,sans-serif;color:#0f172a;">
    <div style="font-weight:800;font-size:18px;margin-bottom:8px;">Limit Reached</div>
    <div style="color:#334155;margin-bottom:14px;">You’ve reached your current drills limit.</div>
    <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;">
      <button id="drill-cap-ok" style="padding:8px 14px;border-radius:8px;border:1px solid #cbd5e1;background:#f1f5f9;color:#0f172a;font-weight:700;cursor:pointer;">OK</button>
    </div>
  </div>
</div>

<!-- WGo (if not already loaded) -->
<script>
if (!window.WGo) {
  var s = document.createElement('script');
  s.src = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754893285939x971907393576095400/wgo.min.js";
  s.async = true;
  document.head.appendChild(s);
}
</script>

<!-- Sound bridge (respects Settings → Sound) -->
<script>
if (!window.StoneSFX) {
  window.StoneSFX = (() => {
    let pool = [], i = 0, unlocked = false;
    function init(url, voices = 5, volume = 0.35){
      pool = Array.from({ length: voices }, () => {
        const a = new Audio(url); a.preload = 'auto'; a.volume = volume; return a;
      });
      const unlock = () => {
        if (unlocked) return;
        for (const a of pool) { try { a.play().then(()=>a.pause()).catch(()=>{}); a.currentTime = 0; } catch(e){} }
        unlocked = true;
        window.removeEventListener('touchstart', unlock);
        window.removeEventListener('mousedown',  unlock);
      };
      window.addEventListener('touchstart', unlock, { once:true });
      window.addEventListener('mousedown',  unlock, { once:true });
    }
    function play(){ if (!pool.length) return; const a = pool[i++ % pool.length]; try { a.currentTime=0; a.playbackRate=0.97+Math.random()*0.06; a.play(); } catch(e){} }
    return { init, play };
  })();
  StoneSFX.init("https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754926303439x491369894441766600/klick.mp3");
}
(function bridgeSoundSetting(){
  if (window._drillSoundInit) return;
  window._drillSoundInit = true;
  if (typeof StoneSFX.play === 'function' && !('_enabled' in StoneSFX)){
    StoneSFX._enabled = (window.GoPrefs ? !!window.GoPrefs.soundOn : true);
    const _orig = StoneSFX.play.bind(StoneSFX);
    StoneSFX.play = function(){ if (StoneSFX._enabled) _orig(); };
  }
  window.JosekiSound = window.JosekiSound || {
    isEnabled(){ return !!StoneSFX._enabled; },
    setEnabled(v){ StoneSFX._enabled = !!v; }
  };
})();

(function DrillBoardMount(){
  const SGF_URL = "../sgf/library-1.sgf";  // same as drills.html
  const MIN_MOVES = 10;

  /* ===== Plan helpers (match drills list) ===== */
  var Tier = window.Tier || {
    get: function(){
      try {
        return (localStorage.getItem('go_tier') || 'free').toLowerCase();
      } catch(e){
        return 'free';
      }
    }
  };

  function isPro(){
    try{
      if (window.GoLimits && typeof window.GoLimits.get === 'function'){
        var lim = window.GoLimits.get();
        if (lim && lim.drills){
          if (lim.drills.triesPerDay === Number.POSITIVE_INFINITY) return true;
          if (typeof lim.drills.plan === 'string' && lim.drills.plan.toLowerCase() === 'pro') return true;
        }
      }
    }catch(e){}
    var t = Tier && typeof Tier.get === 'function' ? Tier.get() : 'free';
    return (t || 'free').toLowerCase() === 'pro';
  }

 /* ===== Run cap (Start + Retry)
     - Disabled: limits are handled per mode/day on drills.html
  ================================= */
  const RUN_LIMIT_FREE = Infinity;
  const RUNS_KEY = 'go:drill_runs_session_count';

  function getRunLimit(){
    // Pro → unlimited, Free → fixed cap
    return isPro() ? Infinity : RUN_LIMIT_FREE;
  }

  function getRuns(){
    try {
      return parseInt(sessionStorage.getItem(RUNS_KEY) || '0', 10) || 0;
    } catch(e){
      return 0;
    }
  }

  function setRuns(n){
    try {
      sessionStorage.setItem(RUNS_KEY, String(Math.max(0, n | 0)));
    } catch(e){}
  }

  function canStart(){
    const limit = getRunLimit();
    if (!Number.isFinite(limit)) return true;    // Pro: always allowed
    return getRuns() < limit;                    // Free: compare vs 2
  }

  function incRuns(){
    const limit = getRunLimit();
    if (!Number.isFinite(limit)) return;         // Pro: don't count runs
    setRuns(getRuns() + 1);
  }

  function runsLeft(){
    const limit = getRunLimit();
    if (!Number.isFinite(limit)) return Infinity;
    return Math.max(0, limit - getRuns());
  }


  // NEW overlay references
  const capM   = document.getElementById('drill-cap');
  const capOK  = document.getElementById('drill-cap-ok');
  function showCapMsg(){
    if (capM){
      capM.style.display = 'flex';
    } else {
      alert('You’ve reached your current drills limit.');
    }
  }

  if (capOK){
    capOK.addEventListener('click', ()=> capM.style.display='none');
    if (capM){
      capM.addEventListener('click', (e)=>{ if (e.target === capM) capM.style.display='none'; });
    }
  }

  // --- SGF utils ---
  function rb(str,i){ let out='',k=i; while(k<str.length){ const ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; } if(ch===']') break; out+=ch; } return {t:out,n:k}; }
  function parseTree(str,i){
    const seq=[]; let node=null; if(str[i]!=='(') return {seq:[],n:i}; i++;
    while(i<str.length){
      const ch=str[i];
      if(ch===';'){ node={}; seq.push(node); i++; }
      else if(/[A-Za-z]/.test(ch)){
        let key=''; while(/[A-Za-z]/.test(str[i]||'')) key+=str[i++]; const vals=[];
        while(str[i]==='['){ const r=rb(str,i+1); vals.push(r.t); i=r.n; }
        if(!node){ node={}; seq.push(node); } node[key]=vals.length>1?vals:vals[0];
      } else if(ch==='('){ const child=parseTree(str,i); i=child.n; if(seq.length){ const p=seq[seq.length-1]; (p.variations||(p.variations=[])).push(child.seq); } }
      else if(ch===')'){ i++; break; } else i++;
    }
    for(let k=0;k<seq.length-1;k++) seq[k].next=seq[k+1];
    return {seq,n:i};
  }
  function parseAllTrees(str){
    const trees=[]; let i=str.indexOf('(');
    if (str.charCodeAt && str.charCodeAt(0)===0xFEFF) str = str.slice(1);
    while(i>=0 && i<str.length){
      const r = parseTree(str,i);
      if (r.seq && r.seq.length) trees.push(r.seq);
      const nxt = str.indexOf('(', r.n);
      if (nxt === -1) break;
      i = nxt;
    }
    return trees;
  }
  function parseSZ(sz){ if(!sz) return 19; if(typeof sz==='string'){ const n=parseInt(sz.split(':')[0],10); return (n>=2&&n<=52)?n:19; } return 19; }
  function xy(s,S){ if(!s||s.length<2) return null; const x=s.charCodeAt(0)-97,y=s.charCodeAt(1)-97; if(x<0||y<0||x>=S||y>=S) return null; return {x,y}; }
  function nodeMove(n,S){ if(!n) return null; if(n.B){ const p=xy(n.B,S); if(p) return {x:p.x,y:p.y,color:'B'}; } if(n.W){ const p=xy(n.W,S); if(p) return {x:p.x,y:p.y,color:'W'}; } return null; }
  function listCoords(prop,S){ const arr=Array.isArray(prop)?prop:(prop?[prop]:[]); const out=[]; for(const v of arr){ const p=xy(v,S); if(p) out.push(p); } return out; }
  function linkify(seq,parent){ for(let i=0;i<seq.length;i++){ const n=seq[i]; n.prev=(i===0?parent:seq[i-1]); n.next=(i<seq.length-1?seq[i+1]:null); if(n.variations) for(const v of n.variations) if(v&&v.length) linkify(v,n); } }
  function enumerateLines(seq,S){
    const lines=[]; let start=seq&&seq[0]; while(start && !nodeMove(start,S) && !start.variations) start=start.next;
    function dfs(node,acc){ if(!node){ lines.push(acc.slice()); return; }
      acc.push(node);
      if(node.variations && node.variations.length){
        for(const v of node.variations){
          let f=v&&v[0]; while(f && !nodeMove(f,S) && !f.variations) f=f.next;
          if(f) dfs(f,acc.slice());
        }
      }
      if(node.next){ let nx=node.next; while(nx && !nodeMove(nx,S) && !nx.variations) nx=nx.next;
        if(nx) dfs(nx,acc); else lines.push(acc.slice()); }
      else lines.push(acc.slice());
    }
    if(start) dfs(start,[]); 
    return lines.map(nodes=>nodes.map(n=>nodeMove(n,S)).filter(Boolean));
  }
  function lineKey(line){
    const size = line.size || 19;
    const seq = (line.moves||[]).map(m => (m.color||'B')[0]+':'+m.x+','+m.y).join('|');
    return `${size}|${seq}`;
  }

  // --- transforms (8; for Blitz we restrict to 4 rotations = corners) ---
  function t_identity(p){ return {x:p.x,y:p.y}; }
  function t_swap(p){ return {x:p.y, y:p.x}; }
  function t_rot90(p,S){  return {x: S-1 - p.y, y: p.x}; }
  function t_rot180(p,S){ return {x: S-1 - p.x, y: S-1 - p.y}; }
  function t_rot270(p,S){ return {x: p.y, y: S-1 - p.x}; }
  function compose(a,b,S){ return function(p){ return a(b(p,S),S); }; }
  function ORIENT_FUNCS(S){
    return [
      p=>t_identity(p),
      p=>t_swap(p),
      p=>t_rot90(p,S),
      p=>compose(t_swap,t_rot90,S)(p),
      p=>t_rot180(p,S),
      p=>compose(t_swap,t_rot180,S)(p),
      p=>t_rot270(p,S),
      p=>compose(t_swap,t_rot270,S)(p)
    ];
  }
  const ROT_IDX_ONLY = [0,2,4,6]; // pure rotations (corners)

  // --- UI elements ---
  const wrap   = document.getElementById('go-board-drill-wrap');
  const mount  = document.getElementById('go-board-drill');
  const btnMenu= document.getElementById('dbtn-menu');
  const btnNext = document.getElementById('dbtn-next');
  const progEl  = document.getElementById('drill-progress');

  const wrongM   = document.getElementById('drill-wrong');
  const clearedM = document.getElementById('drill-cleared');
  const doneM    = document.getElementById('drill-done');
  const doneTitle= document.getElementById('drill-done-title');
  const doneBack = document.getElementById('drill-done-back');
  const doneRetry= document.getElementById('drill-done-retry');
  const statSolvedEl = document.getElementById('drill-stat-solved');
  const statFailedEl = document.getElementById('drill-stat-failed');
  const doneMsgEl    = document.getElementById('drill-done-msg');

  // --- board state ---
  let SIZE = 19, board=null, grid=null;

  // session control
  let solvedCount = 0;
  let failedCount = 0;
  let locked = false;
  let wrongTimer = null;
  let clearedTimer = null;

  // slots / planning
  let PER = 3;
  let slots = [];                 // [{ key, base }]
  let lineToSlotIdxs = {};        // key -> [slotIdx,...]
  let runPlan = {};               // key -> Map(slotIdx -> {orientIdx, swap, startIndex})
  let index  = 0;                 // current slot
  let remain = [];                // remaining transformed moves
  let currentTransformed = null;

  // BLITZ flags + timer
  let blitzMode = false;
  let timerEl = null;
  let timerMs = 0;
  let timerId = null;
  let blitzCornerPlannedMoves = 0;
  let timeUp = false;

  function ensureTimerEl(){
    if (timerEl || !blitzMode) return;
    timerEl = document.createElement('div');
    timerEl.id = 'blitz-timer';
    timerEl.textContent = '0.0s';
    mount.appendChild(timerEl);
  }
  function fmtMs(ms){
    if (ms < 0) ms = 0;
    const s = ms/1000;
    const m = Math.floor(s/60);
    const r = s - m*60;
    if (m>0) return `${m}:${r.toFixed(1).padStart(4,'0')}`;
    return `${r.toFixed(1)}s`;
  }
  function startTimer(){
    if (!blitzMode) return;
    ensureTimerEl();
    stopTimer();
    timeUp = false;
    timerId = setInterval(()=>{
      timerMs -= 100;
      if (timerEl) timerEl.textContent = fmtMs(timerMs);
      if (timerMs <= 0){
        stopTimer();
        timeUp = true;
        showDone('Time’s up!');
      }
    }, 100);
  }
  function stopTimer(){ if (timerId){ clearInterval(timerId); timerId=null; } }

  // board helpers
  function initBoard(){
    if (!window.WGo) return setTimeout(initBoard, 40);
    board = new WGo.Board(mount, { size: SIZE });

    // wood bg inside mount
    (function ensureDrillWoodLayer(){
      if (mount.__woodLayerReady) return;
      const layer = document.createElement('div');
      layer.id = 'go-drill-wood';
      layer.style.position = 'absolute';
      layer.style.left = '0'; layer.style.top = '0'; layer.style.right = '0'; layer.style.bottom = '0';
      layer.style.backgroundImage = "url('https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1755870506985x437178801728222500/wood.jpg')";
      layer.style.backgroundSize = 'cover';
      layer.style.backgroundPosition = 'center';
      layer.style.backgroundRepeat = 'no-repeat';
      layer.style.willChange = 'left, top, width, height';
      mount.appendChild(layer);
      function moveChildrenIntoLayer(){
        const kids = Array.from(mount.childNodes).filter(n => n !== layer);
        for (const n of kids) layer.appendChild(n);
      }
      moveChildrenIntoLayer();
      const mo = new MutationObserver(moveChildrenIntoLayer);
      mo.observe(mount, { childList: true });
      mount.__woodLayerReady = true;
      mount.__woodLayer = layer;
      mount.__woodObserver = mo;
    })();

    fitBoard();
    board.addEventListener('click', onBoardClick);
  }
  function fitBoard(){
    const w = Math.floor(mount.getBoundingClientRect().width || wrap.clientWidth || 400);
    if (board) board.setWidth(w - (w%2));
    mount.style.height = (w - (w%2)) + 'px';
  }
  window.addEventListener('resize', ()=>setTimeout(fitBoard,10));

  function resetGrid(){ grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null)); }
  function addStone(x,y,color){ grid[y][x]=color; }

  function inside(x,y){ return x>=0 && y>=0 && x<SIZE && y<SIZE; }
  function neigh4(x,y){ return [{x:x+1,y:y},{x:x-1,y:y},{x:x,y:y+1},{x:x,y:y-1}].filter(p=>inside(p.x,p.y)); }
  function groupAndLiberties(x,y){
    const color = grid[y][x]; if (!color) return { stones:[], libs:0 };
    const seen = new Set(), libset = new Set(), stones=[];
    const key=(a,b)=>a+','+b; const stack=[{x,y}]; seen.add(key(x,y));
    while(stack.length){
      const p = stack.pop(); stones.push(p);
      for (const n of neigh4(p.x,p.y)){
        const v = grid[n.y][n.x];
        if (v === null) libset.add(key(n.x,n.y));
        else if (v === color){
          const k = key(n.x,n.y); if (!seen.has(k)){ seen.add(k); stack.push(n); }
        }
      }
    }
    return { stones, libs: libset.size };
  }
  function removeStones(stones){ for (const s of stones){ grid[s.y][s.x] = null; } }
  function resolveCapturesAfterPlacing(x,y,color){
    const opp = (color==='B'?'W':'B'), seenOpp = new Set();
    for (const n of neigh4(x,y)){
      if (grid[n.y][n.x] !== opp) continue;
      const k = n.x+','+n.y; if (seenOpp.has(k)) continue;
      const g = groupAndLiberties(n.x,n.y);
      g.stones.forEach(s=>seenOpp.add(s.x+','+s.y));
      if (g.libs === 0) removeStones(g.stones);
    }
    if (grid[y][x] === color){
      const gSelf = groupAndLiberties(x,y);
      if (gSelf.libs === 0) removeStones(gSelf.stones);
    }
  }
  function playMove(x,y,color, silent=false){
    addStone(x,y,color);
    resolveCapturesAfterPlacing(x,y,color);
    if (!silent && window.StoneSFX) StoneSFX.play();
    redraw();
  }

  function redraw(){
    if (!board) return;
    board.removeAllObjects();
    for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++){
      const v=grid[y][x];
      if (v==='B') board.addObject({x,y,c:WGo.B});
      else if (v==='W') board.addObject({x,y,c:WGo.W});
    }
    if (blitzMode) drawBlitzMarkers();
  }

  function isCornerHoshi(pt,S){
    const a = 3, b = S-4;
    return ( (pt.x===a || pt.x===b) && (pt.y===a || pt.y===b) );
  }
  function corner33BelowOfHoshi(h,S){
    const dx = (h.x===3) ? -1 : +1;
    const dy = (h.y===3) ? -1 : +1;
    return { x: h.x + dx, y: h.y + dy };
  }
  function drawBlitzMarkers(){
    if (!currentTransformed || !Array.isArray(currentTransformed.moves) || currentTransformed.moves.length < 1) return;
    const m1 = currentTransformed.moves[0];
    board.addObject({ x:m1.x, y:m1.y, type:'LB', text:'A' });

    if (currentTransformed.moves.length >= 2 && isCornerHoshi(m1, SIZE)){
      const m2 = currentTransformed.moves[1];
      board.addObject({ x:m2.x, y:m2.y, type:'LB', text:'a' });

      if (currentTransformed.moves.length >= 3){
        const below = corner33BelowOfHoshi(m1, SIZE);
        if (m2.x === below.x && m2.y === below.y){
          const m3 = currentTransformed.moves[2];
          board.addObject({ x:m3.x, y:m3.y, type:'LB', text:'A' });
        }
      }
    }
  }

  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function range(a,b){ const out=[]; for(let i=a;i<=b;i++) out.push(i); return out; }

  function mixSlotsFairly(slotList){
    const buckets = new Map();
    for (const s of slotList){
      if (!buckets.has(s.key)) buckets.set(s.key, []);
      buckets.get(s.key).push(s);
    }
    for (const arr of buckets.values()) shuffle(arr);
    const keys = Array.from(buckets.keys());
    let lastKey = null;
    const out = [];
    function pickKey(){
      const candidates = keys.filter(k => (buckets.get(k)||[]).length && k !== lastKey);
      const pool = candidates.length ? candidates : keys.filter(k => (buckets.get(k)||[]).length);
      if (!pool.length) return null;
      return pool[Math.floor(Math.random()*pool.length)];
    }
    while (out.length < slotList.length){
      const k = pickKey();
      if (k == null) break;
      out.push(buckets.get(k).pop());
      lastKey = k;
    }
    return out;
  }

  function makeTransformed(line, orientIdx, swap){
    const S = line.size || 19, ORS = ORIENT_FUNCS(S), o = ORS[orientIdx % ORS.length];
    const tf = p => { const t=o({x:p.x,y:p.y}, S); return {x:t.x,y:t.y}; };
    const AB = (line.rootAB||[]).map(tf), AW = (line.rootAW||[]).map(tf);
    const mv = (line.moves||[]).map(m=>{ const t=tf(m); const c = swap ? (m.color==='B'?'W':'B') : m.color; return { x:t.x, y:t.y, color:c }; });
    return { size:S, rootAB: swap ? AW : AB, rootAW: swap ? AB : AW, moves: mv };
  }

  function buildRunPlanForLine(key, line, slotIdxs){
    const L = line.moves.length, k = slotIdxs.length;
    if (blitzMode){
      const orientIdxs = shuffle(ROT_IDX_ONLY.slice()).slice(0, k || 1);
      let swaps = Array(k).fill(false);
      let nSwap = Math.round(k * 0.5);
      for (let i=0;i<nSwap;i++) swaps[i]=true;
      swaps = shuffle(swaps);
      const plan = new Map(), shuffledSlots = shuffle(slotIdxs.slice());
      for (let i=0;i<k;i++){
        plan.set(shuffledSlots[i], { orientIdx: orientIdxs[i % orientIdxs.length], startIndex: 0, swap: swaps[i] });
      }
      return plan;
    }

    const startsPool = (function allowedStartRange(L){ const min = Math.max(4,0); const max = Math.max(min, L-2); return range(min,max); })(L);
    const orientIdxs = shuffle(range(0,7)).slice(0, slotIdxs.length || 1);
    const chosenStarts = shuffle(startsPool.slice());
    let swaps = Array(slotIdxs.length).fill(false);
    let nSwap = Math.round(slotIdxs.length * 0.5);
    for (let i=0;i<nSwap;i++) swaps[i]=true;
    swaps = shuffle(swaps);

    const plan = new Map(), shuffledSlots = shuffle(slotIdxs.slice());
    for (let i=0;i<slotIdxs.length;i++){
      plan.set(shuffledSlots[i], {
        orientIdx: orientIdxs[i % orientIdxs.length],
        startIndex: chosenStarts[i % chosenStarts.length],
        swap: swaps[i]
      });
    }
    return plan;
  }
  function ensureRunPlanFor(key,line){
    if (!runPlan[key]){
      const idxs = lineToSlotIdxs[key] || [];
      runPlan[key] = buildRunPlanForLine(key, line, idxs);
    }
  }
  function newRunPlan(){
    runPlan = {};
    const seen = new Set();
    for (const s of slots){
      if (seen.has(s.key)) continue;
      seen.add(s.key);
      ensureRunPlanFor(s.key, s.base);
    }
  }

  function setProgress(){
    if (progEl) progEl.textContent = (slots.length ? (index+1) : 0) + ' / ' + (slots.length || 0);
  }

  function resetStats(){
    solvedCount = 0;
    failedCount = 0;
    if (statSolvedEl) statSolvedEl.textContent = '0';
    if (statFailedEl) statFailedEl.textContent = '0';
  }

  function clearTimers(){
    if (wrongTimer){ clearTimeout(wrongTimer); wrongTimer=null; }
    if (clearedTimer){ clearTimeout(clearedTimer); clearedTimer=null; }
  }

  let blitzCornerState = null;

  function prepareCorner(tline, startIndex){
    resetGrid();
    (tline.rootAB||[]).forEach(p=>addStone(p.x,p.y,'B'));
    (tline.rootAW||[]).forEach(p=>addStone(p.x,p.y,'W'));
    for (let s=0;s<startIndex;s++){ const m = tline.moves[s]; playMove(m.x,m.y,m.color, true); }
    remain = tline.moves.slice(startIndex).map(m=>({x:m.x,y:m.y,color:m.color}));
    redraw();
  }

  function startDrill(i){
    index = i;
    if (index >= slots.length){ showDone(); return; }
    const slot = slots[index], base = slot.base, key  = slot.key;

    SIZE = base.size || 19;
    if (!board) initBoard();
    clearTimers();

    ensureRunPlanFor(key, base);
    const variant = runPlan[key].get(index);
    const tline = makeTransformed(base, variant.orientIdx, variant.swap);
    currentTransformed = tline;

    prepareCorner(tline, variant.startIndex);

    blitzCornerPlannedMoves = remain.length;
    if (blitzMode){
      ensureTimerEl();
      timerMs += blitzCornerPlannedMoves * 1500;
      if (!timerId) startTimer();
      if (timerEl) timerEl.textContent = fmtMs(timerMs);
      blitzCornerState = {
        tline,
        startIndex: variant.startIndex,
        plannedN: blitzCornerPlannedMoves
      };
    }

    setProgress();
    locked = false;
  }

  function restartSameCornerBlitz(){
    if (!blitzMode || !blitzCornerState) return;
    prepareCorner(blitzCornerState.tline, blitzCornerState.startIndex);
    locked = false;
  }

  function onBoardClick(x,y){
    if (locked || timeUp) return;
    if (x<0 || y<0 || x>=SIZE) return;
    if (grid[y][x] !== null) return;
    if (!remain.length) return;

    const next = remain[0];
    if (next.x === x && next.y === y){
      playMove(x,y,next.color, false);
      remain.shift();

      if (!remain.length){
        solvedCount++;
        if (blitzMode){
          timerMs += blitzCornerPlannedMoves * 500;
          if (timerEl) timerEl.textContent = fmtMs(timerMs);
        }
        if (index >= (slots.length - 1)) {
          showClearedThenDone();
        } else {
          showClearedAuto();
        }
      }
    } else {
      failedCount++;
      if (blitzMode){
        showWrongThenRestart();
      } else {
        showWrongAuto();
      }
    }
  }

  function showWrongThenRestart(){
    clearTimers();
    wrongM.style.display='flex';
    locked = true;
    wrongTimer = setTimeout(() => {
      wrongM.style.display='none';
      restartSameCornerBlitz();
    }, 800);
  }
  function showWrongAuto(){
    clearTimers();
    wrongM.style.display='flex';
    locked = true;
    wrongTimer = setTimeout(() => {
      wrongM.style.display='none';
      locked = false;
      if (index >= (slots.length - 1)) showDone(); else startDrill(index+1);
    }, 1000);
  }

  function showClearedAuto(){
    clearTimers();
    clearedM.style.display='flex';
    locked = true;
    clearedTimer = setTimeout(() => {
      clearedM.style.display='none';
      locked = false;
      startDrill(index+1);
    }, 850);
  }
  function showClearedThenDone(){
    clearTimers();
    clearedM.style.display='flex';
    locked = true;
    clearedTimer = setTimeout(() => {
      clearedM.style.display='none';
      showDone();
    }, 800);
  }

  function showDone(customTitle){
    clearTimers();
    if (statSolvedEl) statSolvedEl.textContent = String(solvedCount);
    if (statFailedEl) statFailedEl.textContent = String(failedCount);
    if (doneTitle) doneTitle.textContent = customTitle || 'All Drills Complete';

    if (runsLeft() <= 0){
      if (doneMsgEl) doneMsgEl.textContent = 'You reached your drills limit.';
      doneRetry.disabled = true;
      doneRetry.style.opacity = '.6';
      doneRetry.style.cursor = 'not-allowed';
    } else {
      if (doneMsgEl) doneMsgEl.textContent = customTitle ? 'Session ended.' : 'Session finished. You can retry the set or go back to selection.';
      doneRetry.disabled = false;
      doneRetry.style.opacity = '1';
      doneRetry.style.cursor = 'pointer';
    }
    doneM.style.display='flex';
    if (blitzMode) stopTimer();
  }

  doneBack.addEventListener('click', function(){
    doneM.style.display='none';
    try{ window.location.href = '../drills/drills.html'; }catch(e){}
  });

  function reshuffleSlots(){
    if (!slots.length) return;
    slots = mixSlotsFairly(slots.slice());
    lineToSlotIdxs = {};
    for (let i=0;i<slots.length;i++){
      const key = slots[i].key;
      if (!lineToSlotIdxs[key]) lineToSlotIdxs[key] = [];
      lineToSlotIdxs[key].push(i);
    }
  }

  doneRetry.addEventListener('click', function(){
    if (!canStart()){
      showCapMsg();
      if (doneMsgEl) doneMsgEl.textContent = 'You reached your drills limit.';
      doneRetry.disabled = true;
      doneRetry.style.opacity = '.6';
      doneRetry.style.cursor = 'not-allowed';
      return;
    }
    incRuns();
    doneM.style.display='none';
    resetStats();
    reshuffleSlots();
    newRunPlan();
    blitzCornerState = null;
    timeUp = false;
    if (blitzMode){
      timerMs = 0;
      ensureTimerEl();
      timerEl.textContent = fmtMs(timerMs);
      startTimer();
    } else {
      if (timerEl) timerEl.style.display = 'none';
      stopTimer();
    }
    if (slots.length){ startDrill(0); }
  });

  btnNext.addEventListener('click',  function(){
    if (!slots.length) return;
    startDrill(index+1);
  });

  btnMenu.addEventListener('click',  function(){
    try{ window.location.href = '../drills/drills.html'; }catch(e){}
  });

  const OWN_STORE_KEY = 'go:ownpatterns';
  const FAV_KEY       = 'go_favorites';

  function loadOwnPatterns(){ try { return JSON.parse(localStorage.getItem(OWN_STORE_KEY) || '[]'); } catch(_){ return []; } }
  function readFavs(){ try { return JSON.parse(localStorage.getItem(FAV_KEY) || '{}') || {}; } catch(_){ return {}; } }

  function normalizeLineLike(obj){
    return {
      size: obj.size || 19,
      rootAB: Array.isArray(obj.rootAB)?obj.rootAB:[],
      rootAW: Array.isArray(obj.rootAW)?obj.rootAW:[],
      moves:  (obj.moves||[]).map(m => ({ x:m.x, y:m.y, color:(m.color==='W'?'W':'B') }))
    };
  }

  function fetchLibraryLines(){
    return fetch(SGF_URL, { cache:'no-cache' }).then(r=>r.text()).then(txt=>{
      const trees = parseAllTrees(txt);
      const lines=[];
      for (const seq of trees){
        linkify(seq,null);
        const size = parseSZ(seq[0]?.SZ);
        const rootAB = listCoords(seq[0]?.AB, size);
        const rootAW = listCoords(seq[0]?.AW, size);
        const paths  = enumerateLines(seq,size);
        for (const moves of paths){
          if ((moves?.length||0) >= MIN_MOVES){
            lines.push({ size, rootAB, rootAW, moves });
          }
        }
      }
      return lines;
    });
  }
  // Helper: get selections either from GoDrills (inline/Bubble)
  // or from sessionStorage (drills.html → drills-board.html bridge)
  function getDrillSelections(){
    // 1) If GoDrills exists (same-page integration), use it
    if (window.GoDrills && typeof window.GoDrills.getSelections === 'function') {
      try {
        return window.GoDrills.getSelections();
      } catch (e) {}
    }

    // 2) Otherwise, use the bridge from the list page
    try {
      if (typeof sessionStorage === 'undefined') return null;
      var raw = sessionStorage.getItem('go:drills_next_selection');
      if (!raw) return null;
      var obj = JSON.parse(raw);
      if (!obj || typeof obj !== 'object') return null;
      return obj;
    } catch (e) {
      return null;
    }
  }

  const DrillBoard = {
    load: function(linesOrNull, opts){
      PER = Math.max(1, parseInt((opts && opts.perJoseki) || 3, 10) || 3);

      // Read selections via helper (GoDrills on same page OR sessionStorage bridge)
      const sel = getDrillSelections();
      const selMode = (sel && sel.mode === 'blitz') ? 'blitz' : 'complete';
      blitzMode = (selMode === 'blitz');

      function buildSlots(baseLines){
        const raw = [];
        for (const base of baseLines){
          const key = lineKey(base);
          for (let k=0;k<PER;k++){
            raw.push({ key, base });
          }
        }
        slots = mixSlotsFairly(raw);
        lineToSlotIdxs = {};
        for (let i=0;i<slots.length;i++){
          const key = slots[i].key;
          if (!lineToSlotIdxs[key]) lineToSlotIdxs[key] = [];
          lineToSlotIdxs[key].push(i);
        }
      }

      function go(lines){
        const usable = (lines||[]).filter(l => Array.isArray(l.moves) && l.moves.length >= MIN_MOVES).map(normalizeLineLike);
        if (!usable.length){
          alert('No eligible drills (need patterns with 10+ moves).');
          return;
        }
        buildSlots(usable);
        newRunPlan();

        resetStats();
        index=0;
        blitzCornerState = null;
        timeUp = false;

        if (blitzMode){
          timerMs = 0;
          ensureTimerEl();
          timerEl.style.display = 'block';
          timerEl.textContent = fmtMs(timerMs);
          startTimer();
        } else {
          if (timerEl) timerEl.style.display = 'none';
          stopTimer();
        }

        startDrill(0);
        try{ (wrap).scrollIntoView({behavior:'smooth',block:'start'});}catch(_){}
      }

      if (Array.isArray(linesOrNull)){
        go(linesOrNull);
        return;
      }

      // If we have a selection (from GoDrills or from sessionStorage),
      // use ONLY those lines instead of the full library.
      if (sel && (
          (sel.library && sel.library.length) ||
          (sel.favorites && sel.favorites.length) ||
          (sel.own && sel.own.length)
        )){

        const favMap   = readFavs();
        const favLines = Object.values(favMap).map(normalizeLineLike);
        const favPick  = favLines.filter(l => (sel.favorites || []).includes(lineKey(l)));

        const ownAll   = loadOwnPatterns();
        const ownPick  = ownAll
          .filter(p => (sel.own || []).includes(p.id))
          .map(normalizeLineLike);

        if ((sel.library || []).length){
          fetchLibraryLines().then(allLib => {
            const libPick = allLib.filter(l => (sel.library || []).includes(lineKey(l)));
            go([ ...libPick, ...favPick, ...ownPick ]);
          }).catch(() => {
            go([ ...favPick, ...ownPick ]);
          });
        } else {
          go([ ...favPick, ...ownPick ]);
        }
        return;
      }

      // Fallback: no selection info → load full library (old behavior)
      fetchLibraryLines().then(go).catch(() => alert('Could not load drills.'));

    },

    exit: function(){
      stopTimer();
    }
  };
  window.DrillBoard = DrillBoard;

  if (mount && !board) initBoard();

  function hookStart(){
    const s = document.getElementById('drills-start');
    if (!s) return setTimeout(hookStart, 150);
    if (s.__dbHooked) return;
    s.__dbHooked = true;

    function ensureDrillWins(){
      try{
        const gj = document.getElementById('group-joseki');
        if (gj) gj.setAttribute('data-hidden','1');
      }catch(_){}
    }

    function startNow(e){
      if (s.disabled || s.getAttribute('aria-hidden') === 'true' || s.style.display === 'none') return;

      if (!canStart()){
        if (e){ e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); }
        showCapMsg();
        return;
      }
      incRuns();

      if (e){
        e.preventDefault();
        e.stopImmediatePropagation();
        e.stopPropagation();
      }

      if (window.GoDrills && typeof GoDrills.close === 'function'){
        GoDrills.close();
      } else {
        const over = document.getElementById('drills-overlay');
        if (over) over.style.display = 'none';
      }

      setTimeout(()=>{ DrillBoard.load(null, { perJoseki: 3 }); }, 30);
      setTimeout(ensureDrillWins, 120);
      setTimeout(ensureDrillWins, 350);
    }

    s.addEventListener('click',     startNow, true);
    s.addEventListener('pointerup', startNow, true);
    s.addEventListener('touchend',  startNow, { capture:true, passive:false });

    document.addEventListener('click', function docCap(e){
      const t = e.target && e.target.closest ? e.target.closest('#drills-start') : null;
      if (!t) return;
      startNow(e);
    }, true);
  }
  hookStart();

  // Auto-start when used as standalone page (no drills overlay present)
  function autoStartStandalone(){
    const over = document.getElementById('drills-overlay');
    const startBtn = document.getElementById('drills-start');
    const isStandalone = !over && !startBtn;
    if (!isStandalone) return;

    if (!canStart()){
      showCapMsg();
      return;
    }
    incRuns();
    DrillBoard.load(null, { perJoseki: 3 });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', autoStartStandalone);
  } else {
    autoStartStandalone();
  }
})();
</script>

</body>
</html>
