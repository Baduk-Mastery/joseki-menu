<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Master â€“ Drills</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  
  <style>
    /* --- 1. CORE LAYOUT & ZOOM (From Clean Board) --- */
    html, body{
      margin:0; padding:0; height:100%;
      overflow: hidden; 
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background-color:#1b1208;
      touch-action: none;
    }

    #core-root{
      --wood:url('../img/wood.jpg'); 
      position: absolute; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background-color:#1b1208;
      background-image: linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)), var(--wood);
      background-size:cover; background-position:center;
    }

    /* Wrapper limits width but allows board to scale */
    #core-inner{ width:min(92vw, 720px); margin:0 auto; z-index: 1; pointer-events: none; }
    
    /* The Board Container */
    #core-board-wrap{ 
        width:100%; max-width:720px; margin:0 auto; 
        position: relative; pointer-events: auto; 
    }

    #core-board{
      position:relative; width:100%;
      border-radius:10px; overflow:hidden; 
      margin:0 auto;
      box-shadow: 0 18px 40px rgba(0,0,0,.32), 0 6px 16px rgba(0,0,0,.22);
      background:none; 
      touch-action: none; user-select: none; -webkit-user-select: none;
      transform-origin: 0 0;
    }

    /* Fullscreen State */
    #core-board.is-fullscreen {
      position: fixed; top: 0; left: 0;
      width: 100vw !important; height: 100vh !important;
      border-radius: 0 !important; box-shadow: none !important;
      z-index: 9999; margin: 0;
    }

    /* Zoom Exit Button */
    #zoom-exit-btn{
      position:fixed; left:14px; bottom:90px;
      width:120px; height:80px; border-radius:9px;
      background:rgba(148,163,184,.35); border:1px solid rgba(148,163,184,.85);
      box-shadow:0 6px 16px rgba(0,0,0,.55);
      display:none; cursor:pointer; z-index:99999;
      backdrop-filter:blur(2px); -webkit-tap-highlight-color:transparent;
      color:#e5e7eb; font-size:18px; font-weight:600;
      align-items:center; justify-content:center;
    }
    #zoom-exit-btn::after { content: "Zoom Out"; }

    /* --- 2. DRILL UI ELEMENTS (Controls, Timer, Overlays) --- */
    
    /* Controls Bar */
    .prac-ctrls{
      max-width:720px; margin:10px auto 0;
      padding:8px 12px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
      pointer-events: auto;
    }
    .pbtn{
      padding:12px 16px; border-radius:12px; border:1px solid #cbd5e1;
      background:#fff; font-weight:800; font-size:15px; color:#0f172a;
      cursor:pointer; box-shadow:0 2px 8px rgba(15,23,42,.06);
    }
    .pbtn:active{ transform:translateY(1px); }
    .pbtn-strong{ background:#111827; color:#fff; border-color:#111827; }
    .pbtn-alt{ background:#e7f0ff; color:#0b4aa2; border-color:#a7c1ff; }

    /* Blitz timer chip */
    #blitz-timer{
      position:absolute; right:10px; top:10px; z-index:4;
      padding:6px 10px; border-radius:10px;
      font-weight:900; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background:rgba(15,23,42,.88); color:#e6f3ff; border:1px solid rgba(148,163,184,.35);
      box-shadow:0 6px 16px rgba(2,6,23,.35);
      letter-spacing:0.5px;
      display:none; /* Hidden by default */
    }

    /* Overlays (Wrong, Cleared, Done) */
    .drill-overlay {
        display:none; position:fixed; inset:0; z-index:99999;
        align-items:center; justify-content:center;
    }
    .drill-overlay-bg { position:absolute; inset:0; background:rgba(0,0,0,.55); }
    .drill-card {
        position:relative; z-index:1; background:#fff; border:1px solid #e2e8f0;
        border-radius:10px; box-shadow:0 12px 28px rgba(15,23,42,.18);
        width:min(86vw,420px); padding:16px; text-align:center;
        font-family:system-ui, Segoe UI, Arial, sans-serif; color:#0f172a;
    }
    .drill-title { font-weight:800; font-size:18px; margin-bottom:2px; }
  </style>

  <script>
    (function ensureWGo(){
      if (window.WGo) return;
      var s = document.createElement('script');
      s.src = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754893285939x971907393576095400/wgo.min.js";
      s.async = true;
      document.head.appendChild(s);
    })();
  </script>

  <script>
  (function(){
    var STORAGE_KEY = 'go_prefs';
    var GoPrefs = (window.GoPrefs = window.GoPrefs || {});
    try {
      var saved = localStorage.getItem(STORAGE_KEY);
      if (saved) Object.assign(GoPrefs, JSON.parse(saved) || {});
    } catch (e) {}
    
    if (typeof GoPrefs.josekiZoom === 'undefined') GoPrefs.josekiZoom = true;
    if (typeof GoPrefs.soundOn === 'undefined')     GoPrefs.soundOn = true;
    if (typeof GoPrefs.disableAutoZoomOut === 'undefined') GoPrefs.disableAutoZoomOut = false;
  })();

  if (!window.StoneSFX) {
    window.StoneSFX = (() => {
      let pool = [], i = 0;
      function init(url, voices = 5){
        pool = Array.from({ length: voices }, () => {
          const a = new Audio(url); a.preload = 'auto'; a.volume = 0.35; return a;
        });
        const unlock = () => {
          pool.forEach(a => { try{ a.play().then(()=>a.pause()).catch(()=>{}); a.currentTime=0; }catch(e){} });
          window.removeEventListener('touchstart', unlock); window.removeEventListener('mousedown', unlock);
        };
        window.addEventListener('touchstart', unlock, { once:true });
        window.addEventListener('mousedown', unlock, { once:true });
      }
      function play(){
        if (!pool.length) return;
        const a = pool[i++ % pool.length];
        try { a.currentTime=0; a.playbackRate=0.97+Math.random()*0.06; a.play(); } catch(e){}
      }
      return { init, play };
    })();
    StoneSFX.init("https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754926303439x491369894441766600/klick.mp3");
  }
  </script>
</head>
<body>

<div id="core-root">
  <div id="core-inner">
    <div id="core-board-wrap">
      <div id="core-board">
         </div>

      <div id="drill-ctrls" class="prac-ctrls">
        <button id="dbtn-menu" class="pbtn pbtn-strong" type="button">Back</button>
        <button id="dbtn-next" class="pbtn pbtn-alt"    type="button">Next</button>
        <div id="drill-progress" style="font-weight:800;opacity:.9;">- / -</div>
      </div>
    </div>
  </div>
</div>

<div id="zoom-exit-btn"></div>

<div id="drill-wrong" class="drill-overlay">
  <div class="drill-overlay-bg"></div>
  <div class="drill-card"><div class="drill-title">Wrong</div></div>
</div>

<div id="drill-cleared" class="drill-overlay">
  <div class="drill-overlay-bg"></div>
  <div class="drill-card"><div class="drill-title">Cleared</div></div>
</div>

<div id="drill-done" class="drill-overlay">
  <div class="drill-overlay-bg"></div>
  <div class="drill-card" style="width:min(86vw,460px)">
    <div id="drill-done-title" class="drill-title" style="margin-bottom:8px;">All Drills Complete</div>
    <div style="display:flex;gap:10px;justify-content:center;margin:6px 0 10px;">
       <div style="border:1px solid #e2e8f0;border-radius:10px;padding:10px 14px;min-width:120px;">
          <div style="font-weight:800;opacity:.8;font-size:14px">Solved</div>
          <div id="drill-stat-solved" style="font-weight:900;font-size:22px;">0</div>
       </div>
       <div style="border:1px solid #e2e8f0;border-radius:10px;padding:10px 14px;min-width:120px;">
          <div style="font-weight:800;opacity:.8;font-size:14px">Failed</div>
          <div id="drill-stat-failed" style="font-weight:900;font-size:22px;">0</div>
       </div>
    </div>
    <div id="drill-done-msg" style="color:#334155;margin-bottom:14px;">Session finished.</div>
    <div style="display:flex;gap:8px;justify-content:center;">
       <button id="drill-done-back"  class="pbtn pbtn-alt">Selection</button>
       <button id="drill-done-retry" class="pbtn pbtn-strong">Retry</button>
    </div>
  </div>
</div>

<script>
(function(){
  // --- 1. SGF UTILS & DRILL LOGIC ---
  function parseSZ(sz){ if(!sz) return 19; const n=parseInt(sz.split(':')[0],10); return (n>=2&&n<=52)?n:19; }
  function xy(s,S){ if(!s||s.length<2) return null; const x=s.charCodeAt(0)-97,y=s.charCodeAt(1)-97; if(x<0||y<0||x>=S||y>=S) return null; return {x,y}; }
  function nodeMove(n,S){ if(!n) return null; if(n.B){ const p=xy(n.B,S); if(p) return {x:p.x,y:p.y,color:'B'}; } if(n.W){ const p=xy(n.W,S); if(p) return {x:p.x,y:p.y,color:'W'}; } return null; }
  function listCoords(prop,S){ const arr=Array.isArray(prop)?prop:(prop?[prop]:[]); const out=[]; for(const v of arr){ const p=xy(v,S); if(p) out.push(p); } return out; }
  
  function parseTree(str,i){
    const seq=[]; let node=null; if(str[i]!=='(') return {seq:[],n:i}; i++;
    function rb(str,i){ let out='',k=i; while(k<str.length){ const ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; } if(ch===']') break; out+=ch; } return {t:out,n:k}; }
    while(i<str.length){
      const ch=str[i];
      if(ch===';'){ node={}; seq.push(node); i++; }
      else if(/[A-Za-z]/.test(ch)){
        let key=''; while(/[A-Za-z]/.test(str[i]||'')) key+=str[i++]; const vals=[];
        while(str[i]==='['){ const r=rb(str,i+1); vals.push(r.t); i=r.n; }
        if(!node){ node={}; seq.push(node); } node[key]=vals.length>1?vals:vals[0];
      } else if(ch==='('){ const child=parseTree(str,i); i=child.n; if(seq.length){ const p=seq[seq.length-1]; (p.variations||(p.variations=[])).push(child.seq); } }
      else if(ch===')'){ i++; break; } else i++;
    }
    for(let k=0;k<seq.length-1;k++) seq[k].next=seq[k+1];
    return {seq,n:i};
  }

  function parseAllTrees(str){
    const trees=[]; let i=str.indexOf('(');
    if (str.charCodeAt && str.charCodeAt(0)===0xFEFF) str = str.slice(1);
    while(i>=0 && i<str.length){
      const r = parseTree(str,i);
      if (r.seq && r.seq.length) trees.push(r.seq);
      const nxt = str.indexOf('(', r.n);
      if (nxt === -1) break; i = nxt;
    }
    return trees;
  }
  
  function linkify(seq,parent){ for(let i=0;i<seq.length;i++){ const n=seq[i]; n.prev=(i===0?parent:seq[i-1]); n.next=(i<seq.length-1?seq[i+1]:null); if(n.variations) for(const v of n.variations) if(v&&v.length) linkify(v,n); } }

  function enumerateLines(seq,S){
    const lines=[]; let start=seq&&seq[0]; while(start && !nodeMove(start,S) && !start.variations) start=start.next;
    function dfs(node,acc){ if(!node){ lines.push(acc.slice()); return; }
      acc.push(node);
      if(node.variations && node.variations.length){
        for(const v of node.variations){
          let f=v&&v[0]; while(f && !nodeMove(f,S) && !f.variations) f=f.next;
          if(f) dfs(f,acc.slice());
        }
      }
      if(node.next){ let nx=node.next; while(nx && !nodeMove(nx,S) && !nx.variations) nx=nx.next;
        if(nx) dfs(nx,acc); else lines.push(acc.slice()); }
      else lines.push(acc.slice());
    }
    if(start) dfs(start,[]); 
    return lines.map(nodes=>nodes.map(n=>nodeMove(n,S)).filter(Boolean));
  }

  // --- TRANSFORMS ---
  function t_identity(p){ return {x:p.x,y:p.y}; }
  function t_swap(p){ return {x:p.y, y:p.x}; }
  function t_rot90(p,S){  return {x: S-1 - p.y, y: p.x}; }
  function t_rot180(p,S){ return {x: S-1 - p.x, y: S-1 - p.y}; }
  function t_rot270(p,S){ return {x: p.y, y: S-1 - p.x}; }
  function compose(a,b,S){ return function(p){ return a(b(p,S),S); }; }
  function ORIENT_FUNCS(S){
    return [
      p=>t_identity(p), p=>t_swap(p),
      p=>t_rot90(p,S), p=>compose(t_swap,t_rot90,S)(p),
      p=>t_rot180(p,S), p=>compose(t_swap,t_rot180,S)(p),
      p=>t_rot270(p,S), p=>compose(t_swap,t_rot270,S)(p)
    ];
  }
  const ROT_IDX_ONLY = [0,2,4,6];
  function makeTransformed(line, orientIdx, swap){
    const S = line.size || 19, ORS = ORIENT_FUNCS(S), o = ORS[orientIdx % ORS.length];
    const tf = p => { const t=o({x:p.x,y:p.y}, S); return {x:t.x,y:t.y}; };
    const AB = (line.rootAB||[]).map(tf), AW = (line.rootAW||[]).map(tf);
    const mv = (line.moves||[]).map(m=>{ const t=tf(m); const c = swap ? (m.color==='B'?'W':'B') : m.color; return { x:t.x, y:t.y, color:c }; });
    return { size:S, rootAB: swap ? AW : AB, rootAW: swap ? AB : AW, moves: mv };
  }

  // --- MAIN VARIABLES ---
  var SIZE = 19;
  var mount = document.getElementById('core-board');
  var wrap  = document.getElementById('core-board-wrap');
  var exitBtn = document.getElementById('zoom-exit-btn');
  var board = null;
  var grid = []; 

  // Drill State
  var slots = [], runPlan = {}, index = 0, remain = [], currentTransformed = null;
  var solvedCount = 0, failedCount = 0, locked = false;
  var blitzMode = false, timerMs = 0, timerId = null, blitzPlanned = 0, timeUp = false;
  var blitzCornerState = null;
  var MIN_MOVES = 10;
  
  // UI Elements
  var progEl = document.getElementById('drill-progress');
  var wrongM = document.getElementById('drill-wrong');
  var clearedM = document.getElementById('drill-cleared');
  var doneM = document.getElementById('drill-done');
  var timerEl = null;

  // Zoom State
  var scale = 1, minScale = 1, maxScale = 2.6;
  var offsetX = 0, offsetY = 0, baseW = 0; 
  var zoomLayer = null;
  var isFullscreen = false, isZoomAnimating = false, animId = 0;
  var returnAnchor = null; 
  var isPanning = false, panStart = null, tapStart = null;
  var TAP_SLOP2 = 64; 
  var isFlinging = false, flingId = 0, flingVX = 0, flingVY = 0, flingLastTime = 0;
  var panSamplePrev = null, panSampleCurr = null;

  // Prefs
  var zoomEnabled = (window.GoPrefs && typeof window.GoPrefs.josekiZoom !== 'undefined') ? !!window.GoPrefs.josekiZoom : true;
  var disableAutoZoomOut = (window.GoPrefs && typeof window.GoPrefs.disableAutoZoomOut !== 'undefined') ? !!window.GoPrefs.disableAutoZoomOut : false;

  // --- 2. BOARD INITIALIZATION (Zoom Engine + Drill Hook) ---
  
  function ensureTimerEl(){
    if (timerEl || !blitzMode) return;
    timerEl = document.createElement('div');
    timerEl.id = 'blitz-timer';
    timerEl.textContent = '0.0s';
    mount.appendChild(timerEl);
  }

  function initBoard(){
    if (!window.WGo) return setTimeout(initBoard, 40);
    if (board) return;

    board = new WGo.Board(mount, { size: SIZE });

    // Wood Background (Zoom Layer)
    (function ensureDrillWoodLayer(){
      if (mount.__woodLayerReady) return;
      const layer = document.createElement('div');
      layer.id = 'go-drill-wood';
      layer.style.position = 'absolute';
      layer.style.left = '0'; layer.style.top = '0'; layer.style.right = '0'; layer.style.bottom = '0';
      layer.style.backgroundImage = "url('https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1755870506985x437178801728222500/wood.jpg')";
      layer.style.backgroundSize = 'cover'; layer.style.backgroundPosition = 'center'; layer.style.backgroundRepeat = 'no-repeat';
      layer.style.willChange = 'left, top, width, height';
      mount.appendChild(layer);
      function moveChildrenIntoLayer(){
         const kids = Array.from(mount.childNodes).filter(n => n !== layer);
         for (const n of kids) layer.appendChild(n);
      }
      moveChildrenIntoLayer();
      const mo = new MutationObserver(moveChildrenIntoLayer);
      mo.observe(mount, { childList: true });
      mount.__woodLayerReady = true; mount.__woodLayer = layer; mount.__woodObserver = mo;
    })();

    mount.style.position = 'relative'; mount.style.overflow = 'hidden';
    zoomLayer = mount.__woodLayer || mount;
    
    // Safety delay for flexbox centering
    setTimeout(function(){ fitBoard(); }, 50);

    bindClicks();
    window.addEventListener('resize', () => setTimeout(fitBoard, 10));
    exitBtn.addEventListener('click', (e)=>{ e.stopPropagation(); smoothZoomOutAndExit(); });
    
    // Check if we need to auto-load
    autoStartStandalone();
  }

  // --- 3. ZOOM ENGINE ---
  function canvasCssScale(){
    var c = mount.querySelector('canvas');
    if (!c) return 1;
    return (c.clientWidth || 0) / (c.width || 1);
  }
  function getXcss(i){ return board.getX(i) * canvasCssScale(); }
  function getYcss(j){ return board.getY(j) * canvasCssScale(); }
  function viewportSize(){ return { vw: mount.clientWidth, vh: mount.clientHeight }; }
  
  function clampPan(){
    if (isZoomAnimating) return;
    const {vw, vh} = viewportSize();
    const bw = Math.round(baseW * scale);
    const bleedX = Math.ceil(vw * 0.5), bleedY = Math.ceil(vh * 0.5);
    const minOX = -bleedX, maxOX = Math.max(0, bw - vw) + bleedX;
    const minOY = -bleedY, maxOY = Math.max(0, bw - vh) + bleedY;
    offsetX = Math.max(minOX, Math.min(offsetX, maxOX));
    offsetY = Math.max(minOY, Math.min(offsetY, maxOY));
  }

  function applyPanAndSize(redrawAfter){
    if (board && board._lastW !== baseW) {
      board.setWidth(baseW);
      if (zoomLayer) { zoomLayer.style.width = baseW + 'px'; zoomLayer.style.height = baseW + 'px'; }
      board._lastW = baseW;
      if (!redrawAfter) redrawAfter = true;
    }
    clampPan();
    if (zoomLayer) zoomLayer.style.transform = 'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';
    if (redrawAfter) redrawBoard();
  }

  function animateTo(targetScale, pxWorld, pyWorld, sxTarget, syTarget){
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
    cancelFling();
    const s0 = scale, ox0 = offsetX, oy0 = offsetY;
    const t0 = performance.now(), dur = 300;
    cancelAnimationFrame(animId); isZoomAnimating = true;
    const targetOffsetX = (pxWorld * targetScale) - sxTarget;
    const targetOffsetY = (pyWorld * targetScale) - syTarget;
    (function step(now){
      let t = (now - t0) / dur; if (t > 1) t = 1;
      const e = 1 - Math.pow(1 - t, 3);
      scale = s0 + (targetScale - s0) * e;
      offsetX = ox0 + (targetOffsetX - ox0) * e;
      offsetY = oy0 + (targetOffsetY - oy0) * e;
      applyPanAndSize(false);
      if (t < 1) animId = requestAnimationFrame(step);
      else { isZoomAnimating = false; applyPanAndSize(true); }
    })(t0);
  }

  function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
    if (isFullscreen) return;
    cancelFling();
    returnAnchor = document.createElement('div');
    returnAnchor.style.width = mount.clientWidth + 'px'; returnAnchor.style.height = mount.clientHeight + 'px';
    mount.parentNode.insertBefore(returnAnchor, mount);
    document.body.appendChild(mount);
    mount.classList.add('is-fullscreen'); isFullscreen = true; exitBtn.style.display = 'flex';
    mount.style.width = '100vw'; mount.style.height = '100vh';
    scale = 1; offsetX = 0; offsetY = 0;
    const vw = window.innerWidth, vh = window.innerHeight;
    baseW = Math.floor(Math.min(vw, vh)); if (baseW % 2) baseW--;
    requestAnimationFrame(function(){
      applyPanAndSize(true);
      const initialFactor = 2.4;
      const px_curr = getXcss(i); const py_curr = getYcss(j);
      const rect = mount.getBoundingClientRect();
      let sx = rect.width / 2, sy = rect.height / 2;
      if (typeof tapClientX === 'number'){ sx = tapClientX - rect.left; sy = tapClientY - rect.top; }
      offsetX = px_curr * 1.0 - sx; offsetY = py_curr * 1.0 - sy;
      applyPanAndSize(false);
      animateTo(initialFactor, px_curr, py_curr, sx, sy);
    });
  }

  function exitFullscreen(){
    cancelFling(); cancelAnimationFrame(animId); isZoomAnimating = false;
    mount.classList.remove('is-fullscreen'); exitBtn.style.display = 'none'; isFullscreen = false;
    if (returnAnchor && returnAnchor.parentNode){
      returnAnchor.parentNode.insertBefore(mount, returnAnchor);
      returnAnchor.parentNode.removeChild(returnAnchor); returnAnchor = null;
    }
    mount.style.width = ''; mount.style.height = '';
    fitBoard(); resetViewLocal();
  }

  function fitBoard(){
    if (isFullscreen) return; 
    var w = wrap.getBoundingClientRect().width;
    w = Math.floor(w); if(w%2) w--;
    baseW = w; mount.style.width = w+'px'; mount.style.height = w+'px';
    applyPanAndSize(true);
  }
  function resetViewLocal(){ scale = 1; offsetX = 0; offsetY = 0; applyPanAndSize(true); }
  function smoothZoomOutAndExit(){ if (!zoomEnabled) return; cancelFling(); scale = 1; offsetX = 0; offsetY = 0; applyPanAndSize(true); if (isFullscreen) exitFullscreen(); }

  // --- 4. INPUT HANDLING (Drill-Aware) ---
  function bindClicks(){
    function getGridSpacing(){ var sX = Math.abs(getXcss(1)-getXcss(0)); var sY = Math.abs(getYcss(1)-getYcss(0)); return {x:sX, y:sY}; }

    mount.addEventListener('pointerdown', function(e){
      if (!zoomEnabled) return;
      if (e.pointerType !== 'touch' && e.button !== 0) return;
      cancelFling();
      const r = mount.getBoundingClientRect();
      const sx = e.clientX - r.left, sy = e.clientY - r.top;
      const boardX = (sx + offsetX) / scale, boardY = (sy + offsetY) / scale;
      
      let bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
      for (let i=0; i<SIZE; i++){ const dx = Math.abs(getXcss(i)-boardX); if (dx<bestDx){ bestDx=dx; bestI=i; } }
      for (let j=0; j<SIZE; j++){ const dy = Math.abs(getYcss(j)-boardY); if (dy<bestDy){ bestDy=dy; bestJ=j; } }
      
      const spacing = getGridSpacing();
      if (bestDx > spacing.x * 0.5 || bestDy > spacing.y * 0.5) { tapStart = null; return; }
      
      panStart = { x:e.clientX, y:e.clientY, ox:offsetX, oy:offsetY };
      try { mount.setPointerCapture(e.pointerId); } catch(_){}
      tapStart = { x:e.clientX, y:e.clientY, ox:offsetX, oy:offsetY, gridI:bestI, gridJ:bestJ };
    }, {passive:false});

    mount.addEventListener('pointermove', function(e){
      if (!zoomEnabled || !panStart) return;
      if (scale <= 1.01 && !isFullscreen) return;
      const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y;
      if (!isPanning && (dx*dx + dy*dy > TAP_SLOP2)) isPanning = true;
      if (isPanning) {
        offsetX = panStart.ox - dx; offsetY = panStart.oy - dy;
        applyPanAndSize(false); e.preventDefault();
        const now = performance.now();
        panSamplePrev = panSampleCurr; panSampleCurr = { ox:offsetX, oy:offsetY, t:now };
      }
    }, {passive:false});

    mount.addEventListener('pointerup', function(e){
      // CASE A: Zoom Disabled
      if (!zoomEnabled) {
         const r = mount.getBoundingClientRect();
         const bx = e.clientX - r.left, by = e.clientY - r.top;
         let bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
         for (let i=0; i<SIZE; i++){ const dx = Math.abs(getXcss(i)-bx); if (dx<bestDx){ bestDx=dx; bestI=i; } }
         for (let j=0; j<SIZE; j++){ const dy = Math.abs(getYcss(j)-by); if (dy<bestDy){ bestDy=dy; bestJ=j; } }
         const spacing = getGridSpacing();
         if (bestDx > spacing.x*0.5 || bestDy > spacing.y*0.5) return;
         e.preventDefault(); playAt(bestI, bestJ); return;
      }
      // CASE B: Zoom Enabled
      if (!tapStart) { if (panStart) try { mount.releasePointerCapture(e.pointerId); panStart=null; } catch(_){} return; }
      try { mount.releasePointerCapture(e.pointerId); } catch(_){}
      const dist2 = (e.clientX - tapStart.x)**2 + (e.clientY - tapStart.y)**2;
      const { gridI, gridJ } = tapStart; const tapX=tapStart.x, tapY=tapStart.y;
      tapStart=null; panStart=null;
      if (isPanning) {
        isPanning = false;
        if (panSamplePrev && panSampleCurr) {
          const dt = panSampleCurr.t - panSamplePrev.t;
          if (dt>0 && dt<120) startFling((panSampleCurr.ox - panSamplePrev.ox)/dt, (panSampleCurr.oy - panSamplePrev.oy)/dt);
        }
        return;
      }
      if (dist2 <= TAP_SLOP2) {
        e.preventDefault();
        if (scale <= 1.05 && !isFullscreen) enterFullscreenAtGrid(gridI, gridJ, tapX, tapY);
        else playAt(gridI, gridJ);
      }
    }, {passive:false});
  }

  function startFling(vx, vy){
    if (scale <= 1) return; cancelFling();
    var speed = Math.sqrt(vx*vx + vy*vy), MAX_SPEED = 0.50;
    if (speed > MAX_SPEED){ var s = MAX_SPEED/speed; vx*=s; vy*=s; speed=MAX_SPEED; }
    if (speed < 0.04) return;
    isFlinging = true; flingVX = vx; flingVY = vy; flingLastTime = performance.now();
    (function step(now){
      if (!isFlinging) return;
      var dt = now - flingLastTime; if (dt<=0){ flingId = requestAnimationFrame(step); return; }
      if (dt>50) dt=50; flingLastTime = now;
      offsetX += flingVX * dt; offsetY += flingVY * dt;
      var friction = 0.0010, currentSpeed = Math.sqrt(flingVX*flingVX + flingVY*flingVY), decel = friction*dt;
      if (currentSpeed <= 0.01 || decel >= currentSpeed){ cancelFling(); applyPanAndSize(true); return; }
      var scaleFactor = (currentSpeed - decel) / currentSpeed;
      flingVX *= scaleFactor; flingVY *= scaleFactor;
      applyPanAndSize(false); flingId = requestAnimationFrame(step);
    })(performance.now());
  }
  function cancelFling(){ isFlinging = false; if (flingId) { cancelAnimationFrame(flingId); flingId = 0; } }


  // --- 5. DRILL GAME LOGIC ---
  
  function resetGrid(){ grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null)); }
  function addStone(x,y,color){ grid[y][x]=color; }
  
  // Capture Helper
  function resolveCapturesAfterPlacing(x,y,color){
    function neigh4(x,y){ return [{x:x+1,y:y},{x:x-1,y:y},{x:x,y:y+1},{x:x,y:y-1}].filter(p=>p.x>=0&&p.x<SIZE&&p.y>=0&&p.y<SIZE); }
    function groupAndLibs(x,y){
       const c=grid[y][x]; if(!c) return {stones:[],libs:0};
       const stack=[{x,y}], seen=new Set(), libs=new Set(), stones=[]; seen.add(x+','+y);
       while(stack.length){
         const p=stack.pop(); stones.push(p);
         neigh4(p.x,p.y).forEach(n=>{
           const v=grid[n.y][n.x];
           if(v===null) libs.add(n.x+','+n.y);
           else if(v===c){ const k=n.x+','+n.y; if(!seen.has(k)){ seen.add(k); stack.push(n); } }
         });
       }
       return {stones, libs:libs.size};
    }
    const opp = color==='B'?'W':'B', seenOpp = new Set();
    neigh4(x,y).forEach(n=>{
       if(grid[n.y][n.x]===opp){
         const k=n.x+','+n.y; if(seenOpp.has(k)) return;
         const g=groupAndLibs(n.x,n.y);
         g.stones.forEach(s=>seenOpp.add(s.x+','+s.y));
         if(g.libs===0) g.stones.forEach(s=>grid[s.y][s.x]=null);
       }
    });
    // Self capture check? (omitted for drills, usually not needed if SGF is valid)
  }

  function playMove(x,y,color, silent=false){
    addStone(x,y,color);
    resolveCapturesAfterPlacing(x,y,color);
    if (!silent && window.StoneSFX) StoneSFX.play();
    redrawBoard();
  }

  function redrawBoard(){
    if (!board) return;
    board.removeAllObjects();
    for(var y=0; y<SIZE; y++) for(var x=0; x<SIZE; x++){
       var v = grid[y][x];
       if(v==='B') board.addObject({x:x, y:y, c:WGo.B});
       if(v==='W') board.addObject({x:x, y:y, c:WGo.W});
    }
    if(blitzMode) drawBlitzMarkers();
  }
  
  function drawBlitzMarkers(){
     if(!currentTransformed || !currentTransformed.moves || currentTransformed.moves.length<1) return;
     const m1 = currentTransformed.moves[0];
     board.addObject({ x:m1.x, y:m1.y, type:'LB', text:'A' });
     if(currentTransformed.moves.length>=2 && isCornerHoshi(m1)){
        const m2 = currentTransformed.moves[1];
        board.addObject({ x:m2.x, y:m2.y, type:'LB', text:'a' });
        if(currentTransformed.moves.length>=3){
           const below = corner33Below(m1);
           if(m2.x===below.x && m2.y===below.y){
              const m3 = currentTransformed.moves[2];
              board.addObject({ x:m3.x, y:m3.y, type:'LB', text:'A' });
           }
        }
     }
  }
  function isCornerHoshi(p){ return (p.x===3||p.x===SIZE-4) && (p.y===3||p.y===SIZE-4); }
  function corner33Below(p){ const dx=(p.x===3)?-1:1; const dy=(p.y===3)?-1:1; return {x:p.x+dx,y:p.y+dy}; }

  // --- CORE GAME LOOP (PLAYAT) ---
  function playAt(x, y){
    if (locked || timeUp) return;
    if (x<0 || y<0 || x>=SIZE || y>=SIZE) return;
    if (grid[y][x] !== null) return;
    if (!remain.length) return;

    const next = remain[0];
    if (next.x === x && next.y === y) {
      // Correct!
      playMove(x, y, next.color, false);
      remain.shift();
      
      // Check Auto-Zoom Out Preference
      if (!disableAutoZoomOut && scale > 1) setTimeout(smoothZoomOutAndExit, 10);

      if (!remain.length) {
         solvedCount++;
         if (blitzMode){ timerMs += blitzPlanned * 500; if (timerEl) timerEl.textContent = fmtMs(timerMs); }
         if (index >= (slots.length - 1)) showClearedThenDone();
         else showClearedAuto();
      }
    } else {
      // Wrong!
      failedCount++;
      if (blitzMode) showWrongThenRestart();
      else showWrongAuto();
    }
  }

  // --- DRILL LIFECYCLE ---
  function startDrill(i){
    index = i;
    if (index >= slots.length){ showDone(); return; }
    const slot = slots[index], base = slot.base, key = slot.key;
    SIZE = base.size || 19;
    if (!board) initBoard();
    clearTimers();

    if(!runPlan[key]) runPlan[key] = buildRunPlan(key, base, lineToSlotIdxs[key]||[]);
    const variant = runPlan[key].get(index);
    const tline = makeTransformed(base, variant.orientIdx, variant.swap);
    currentTransformed = tline;

    resetGrid();
    (tline.rootAB||[]).forEach(p=>addStone(p.x,p.y,'B'));
    (tline.rootAW||[]).forEach(p=>addStone(p.x,p.y,'W'));
    
    // Play setup moves
    const startIdx = Math.max(0, Math.min(variant.startIndex, tline.moves.length-2));
    for(let s=0; s<startIdx; s++){ const m=tline.moves[s]; playMove(m.x,m.y,m.color, true); }
    remain = tline.moves.slice(startIdx).map(m=>({x:m.x,y:m.y,color:m.color}));
    
    blitzPlanned = remain.length;
    if(blitzMode){
       ensureTimerEl(); timerEl.style.display='block';
       timerMs += blitzPlanned * 1500;
       if(!timerId) startTimer();
       timerEl.textContent = fmtMs(timerMs);
       blitzCornerState = { tline, startIdx, planned: blitzPlanned };
    } else {
       if(timerEl) timerEl.style.display='none';
       stopTimer();
    }
    
    if(progEl) progEl.textContent = (index+1) + ' / ' + slots.length;
    locked = false;
    redrawBoard();
  }
  
  // Drill Plan Helpers
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function buildRunPlan(key, line, slotIdxs){
     const L = line.moves.length;
     const startsPool = []; for(let i=Math.max(4,0); i<=Math.max(4,L-2); i++) startsPool.push(i);
     const k = slotIdxs.length;
     const orientIdxs = shuffle([0,1,2,3,4,5,6,7]).slice(0, k||1);
     const chosenStarts = shuffle(startsPool).slice(0, k||1);
     let swaps = Array(k).fill(false); for(let i=0; i<Math.round(k*0.5); i++) swaps[i]=true; swaps=shuffle(swaps);
     const plan = new Map();
     const shuffledSlots = shuffle(slotIdxs.slice());
     for(let i=0; i<k; i++){
        plan.set(shuffledSlots[i], {
           orientIdx: orientIdxs[i % orientIdxs.length],
           startIndex: (blitzMode ? 0 : chosenStarts[i % chosenStarts.length]),
           swap: swaps[i]
        });
     }
     return plan;
  }
  
  // Overlays
  function showWrongThenRestart(){ clearTimers(); wrongM.style.display='flex'; locked=true; wrongTimer=setTimeout(()=>{ wrongM.style.display='none'; restartBlitz(); }, 800); }
  function restartBlitz(){
     if(!blitzMode || !blitzCornerState) return;
     const { tline, startIdx } = blitzCornerState;
     resetGrid();
     (tline.rootAB||[]).forEach(p=>addStone(p.x,p.y,'B'));
     (tline.rootAW||[]).forEach(p=>addStone(p.x,p.y,'W'));
     for(let s=0; s<startIdx; s++){ const m=tline.moves[s]; playMove(m.x,m.y,m.color, true); }
     remain = tline.moves.slice(startIdx).map(m=>({x:m.x,y:m.y,color:m.color}));
     redrawBoard(); locked=false;
  }
  function showWrongAuto(){ clearTimers(); wrongM.style.display='flex'; locked=true; wrongTimer=setTimeout(()=>{ wrongM.style.display='none'; locked=false; if(index>=slots.length-1) showDone(); else startDrill(index+1); }, 1000); }
  function showClearedAuto(){ clearTimers(); clearedM.style.display='flex'; locked=true; clearedTimer=setTimeout(()=>{ clearedM.style.display='none'; locked=false; startDrill(index+1); }, 850); }
  function showClearedThenDone(){ clearTimers(); clearedM.style.display='flex'; locked=true; clearedTimer=setTimeout(()=>{ clearedM.style.display='none'; showDone(); }, 800); }
  function showDone(){
     clearTimers();
     document.getElementById('drill-stat-solved').textContent = solvedCount;
     document.getElementById('drill-stat-failed').textContent = failedCount;
     doneM.style.display='flex';
     if(blitzMode) stopTimer();
  }
  function clearTimers(){ if(wrongTimer) clearTimeout(wrongTimer); if(clearedTimer) clearTimeout(clearedTimer); }
  
  // Timer Utils
  function fmtMs(ms){ if(ms<0)ms=0; const s=ms/1000, m=Math.floor(s/60), r=s-m*60; return m>0 ? `${m}:${r.toFixed(1).padStart(4,'0')}` : `${r.toFixed(1)}s`; }
  function startTimer(){ stopTimer(); timeUp=false; timerId=setInterval(()=>{ timerMs-=100; if(timerEl)timerEl.textContent=fmtMs(timerMs); if(timerMs<=0){ stopTimer(); timeUp=true; showDone(); } }, 100); }
  function stopTimer(){ if(timerId) clearInterval(timerId); timerId=null; }

  // Controls
  document.getElementById('dbtn-menu').addEventListener('click', ()=>{ try{window.location.href='../drills/drills.html'}catch(e){} });
  document.getElementById('drill-done-back').addEventListener('click', ()=>{ doneM.style.display='none'; try{window.location.href='../drills/drills.html'}catch(e){} });
  document.getElementById('drill-done-retry').addEventListener('click', ()=>{ 
     doneM.style.display='none'; solvedCount=0; failedCount=0; index=0; 
     if(blitzMode){ timerMs=0; ensureTimerEl(); timerEl.textContent=fmtMs(timerMs); startTimer(); }
     startDrill(0); 
  });
  document.getElementById('dbtn-next').addEventListener('click', ()=>{ if(slots.length) startDrill(index+1); });


  // --- 6. AUTO START ---
  function getDrillSelections(){
    try {
      if (typeof sessionStorage !== 'undefined') {
        var raw = sessionStorage.getItem('go:drills_next_selection');
        if (raw) return JSON.parse(raw);
      }
    } catch(e){}
    return null;
  }
  
  function lineKey(line){ const s=line.size||19, seq=(line.moves||[]).map(m=>(m.color||'B')[0]+':'+m.x+','+m.y).join('|'); return `${s}|${seq}`; }
  
  function autoStartStandalone(){
     const sel = getDrillSelections();
     const PER = 3;
     blitzMode = (sel && sel.mode==='blitz');
     
     // Mock fetch logic (simplified for standalone demo - in real app, replace with actual fetch)
     // For now, we assume SGF_URL is correct or we have a way to get lines.
     // Here we just define a loader.
     const SGF_URL = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1756283064420x481184906507390100/game%20(1).sgf"; // from your snippet
     
     fetch(SGF_URL).then(r=>r.text()).then(txt=>{
        const trees = parseAllTrees(txt);
        const lines = [];
        for(const seq of trees){
           linkify(seq,null);
           const size = parseSZ(seq[0]?.SZ);
           const rootAB = listCoords(seq[0]?.AB, size);
           const rootAW = listCoords(seq[0]?.AW, size);
           const paths = enumerateLines(seq,size);
           for(const moves of paths){
              if((moves?.length||0)>=MIN_MOVES) lines.push({size, rootAB, rootAW, moves});
           }
        }
        
        // Filter selection
        let usable = lines;
        if(sel && (sel.library||[]).length){
           usable = lines.filter(l => sel.library.includes(lineKey(l)));
        }
        
        // Build slots
        slots = [];
        lineToSlotIdxs = {};
        runPlan = {}; // reset
        
        for(const base of usable){
           const key = lineKey(base);
           for(let k=0; k<PER; k++) slots.push({key, base});
        }
        slots = shuffle(slots); // Mix slots
        for(let i=0; i<slots.length; i++){
           const key = slots[i].key;
           if(!lineToSlotIdxs[key]) lineToSlotIdxs[key]=[];
           lineToSlotIdxs[key].push(i);
        }
        
        if(slots.length > 0) startDrill(0);
        else console.log("No matching drills found or SGF empty.");
     });
  }
  
  if (mount && !board) initBoard();
})();
</script>
</body>
</html>