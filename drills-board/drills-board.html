<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Master – Drills Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

  <style>
 html, body{
  margin:0;
  padding:0;
  height:100%;
  min-height:100%;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background-color:#1b1208;
  overscroll-behavior:none;
  touch-action: none; /* Critical for zoom */
}

/* Core-style fullscreen centering + wood background for Drills */
#drill-root{
  --wood:url('../img/wood.jpg');
  position:fixed;
  inset:0;
  background-color:#1b1208;
  background-image:
    linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)),
    var(--wood);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
}

#drill-inner{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%);
  width:100%;
  max-width:720px;
  box-sizing:border-box;
}

@media (max-width: 480px){
  #drill-inner{ padding:8px 12px 0; }
}

#go-board-drill canvas{ display:block; margin:0 auto; }

/* --- CORE BOARD STYLE FULLSCREEN FIX --- */
#go-board-drill.is-fullscreen {
  position: fixed;
  top: 0; left: 0;
  width: 100vw !important;
  height: 100vh !important;
  border-radius: 0 !important;
  box-shadow: none !important;
  z-index: 9999;
  margin: 0;
  background: none;
}

/* Buttons */
.pbtn{
  padding:12px 16px; border-radius:12px; border:1px solid #cbd5e1;
  background:#fff; font-weight:800; font-size:15px; color:#0f172a;
  cursor:pointer; box-shadow:0 2px 8px rgba(15,23,42,.06);
}
.pbtn:active{ transform:translateY(1px); }
.pbtn-strong{ background:#111827; color:#fff; border-color:#111827; }
.pbtn-alt{ background:#e7f0ff; color:#0b4aa2; border-color:#a7c1ff; }

/* Timer Chip */
#blitz-timer{
  margin-left:auto;
  display:inline-flex; align-items:center; justify-content:center;
  padding:6px 12px; border-radius:8px; min-width:7ch;
  white-space:nowrap; text-align:center;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  font-weight:900; font-size:14px; line-height:1.1; letter-spacing:0.5px;
  color:#fff3cf; text-shadow:0 1px 0 rgba(0,0,0,.35);
  background: linear-gradient(to bottom, rgba(255,255,255,.10), rgba(0,0,0,.18)), rgba(0,0,0,.28);
  border:1px solid rgba(255,255,255,.35);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.12), 0 4px 10px rgba(0,0,0,.35);
  cursor:default; user-select:none; -webkit-tap-highlight-color:transparent;
}

/* Topbar */
#drill-topbar{
  max-width:720px; width:100%; margin:16px auto 10px; padding:0;
  box-sizing:border-box; display:flex; align-items:center; justify-content:space-between; gap:10px;
}

/* Wood Back Button */
.s-back{
  position:relative; display:inline-flex; align-items:center; justify-content:center; gap:6px;
  padding:6px 12px; border-radius:8px; border:1px solid rgba(255,255,255,.40);
  font-size:14px; font-weight:800; line-height:1.1;
  color:#fff3cf; text-shadow:0 1px 0 rgba(120,60,20,.7); cursor:pointer;
  user-select:none; -webkit-tap-highlight-color:transparent;
  background-image: linear-gradient(to bottom, rgba(255,255,255,.12), rgba(255,255,255,.03) 38%, rgba(0,0,0,.14) 100%), url('../img/wood.jpg');
  background-size:100% 100%, cover; background-position:center; background-repeat:no-repeat;
  filter:brightness(1.08) saturate(.96);
  box-shadow: 0 3px 0 rgba(133,74,26,.85), 0 8px 14px rgba(0,0,0,.45);
  transition: transform .08s ease-out, box-shadow .08s ease-out, filter .12s ease-out;
}
.s-back:active{ transform:translateY(2px); box-shadow: 0 1px 0 rgba(120,60,20,.9), 0 4px 8px rgba(0,0,0,.55); }

/* Controls */
#drill-ctrls{
  max-width: 720px; width: 100%; box-sizing: border-box;
  margin: 14px auto 0; padding: 0 12px 18px;
  display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 0;
}
#drill-ctrls #dbtn-next{ grid-column: 2; justify-self: center; width: auto; }
#drill-ctrls #drill-progress{ grid-column: 3; justify-self: end; text-align: right; min-width: 60px; }

#drill-ctrls .pbtn-alt{
  position: relative; min-width: 90px; padding: 8px 24px;
  border-radius: 10px; border: 1px solid rgba(255,255,255,.40);
  font-size: 16px; font-weight: 800; color: #fff3cf;
  text-shadow: 0 1px 0 rgba(120,60,20,.7); cursor: pointer;
  background-image: linear-gradient(to bottom, rgba(255,255,255,.12), rgba(255,255,255,.03) 38%, rgba(0,0,0,.14) 100%), url('../img/wood.jpg');
  background-size: 100% 100%, cover; background-position: center; background-repeat: no-repeat;
  filter: brightness(1.08) saturate(.96);
  box-shadow: 0 3px 0 rgba(133,74,26,.85), 0 8px 14px rgba(0,0,0,.45);
}
#drill-ctrls .pbtn-alt:active{ transform: translateY(2px); box-shadow: 0 1px 0 rgba(120,60,20,.9), 0 4px 8px rgba(0,0,0,.55); }

/* --- ZOOM UI CONTAINERS (For Re-homing) --- */
#go-zoom-overlay-drill{
  position:fixed; inset:0; z-index:99998; display:none;
  align-items:center; justify-content:center;
  background:transparent; -webkit-tap-highlight-color:transparent; touch-action:none;
}
#go-zoom-top-drill{
  position:fixed; left:0; right:0; top:0; padding:12px 12px 0;
  display:none; justify-content:center; align-items:flex-start;
  pointer-events:none; z-index:99999;
}
#go-zoom-top-drill > *{ pointer-events:auto; }

#go-zoom-ui-drill{
  position:fixed; left:0; right:0; bottom:0; padding:0 12px 18px;
  display:none; flex-direction:column; align-items:center;
  pointer-events:none; z-index:99999;
}
#go-zoom-ui-drill > *{ pointer-events:auto; }

#go-zoom-exit-drill{
  position:fixed; left:14px; bottom:90px;
  width:120px; height:80px; border-radius:9px;
  background:rgba(148,163,184,.35); border:1px solid rgba(148,163,184,.85);
  box-shadow:0 6px 16px rgba(0,0,0,.55);
  display:none; cursor:pointer; z-index:99999; backdrop-filter:blur(2px);
}
#go-zoom-exit-drill::before{ content:""; }

/* Notifications */
.drill-notif{ position:fixed; inset:0; z-index:100000; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.55); }
.drill-notif-card{
  position:relative; border-radius:10px; border:1px solid #e2e8f0;
  box-shadow:0 12px 28px rgba(15,23,42,.18); padding:16px; text-align:center;
  font-family:system-ui, "Segoe UI", Arial, sans-serif; color:#fff3cf;
  background-image: linear-gradient(to bottom, rgba(0,0,0,.10), rgba(0,0,0,.25)), url('../img/notification.jpg');
  background-size:cover; background-position:center;
  min-width:280px; max-width:min(86vw, 460px); max-height:calc(100vh - 32px); overflow:auto;
}
.drill-notif-card > *{ color:inherit !important; }
.drill-notif-title{ font-weight:800; font-size:18px; margin-bottom:8px; }
.drill-notif-desc{ font-size:16px; margin-bottom:14px; opacity:.96; }
.drill-stats{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:6px 0 10px; }
.drill-stat-box{ border:1px solid rgba(255,255,255,.25); border-radius:10px; padding:10px 14px; min-width:140px; background:rgba(0,0,0,.18); box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); }
.drill-stat-label{ font-weight:800; opacity:.85; margin-bottom:2px; }
.drill-stat-value{ font-weight:900; font-size:22px; line-height:1; }

.drill-notif-btn{
  position:relative; display:inline-flex; align-items:center; justify-content:center; gap:6px;
  padding:8px 18px; border-radius:10px; border:1px solid rgba(255,255,255,.40);
  font-size:16px; font-weight:800; color:#fff3cf; text-shadow:0 1px 0 rgba(120,60,20,.7);
  cursor:pointer; background-image: linear-gradient(to bottom, rgba(255,255,255,.12), rgba(255,255,255,.03) 38%, rgba(0,0,0,.14) 100%), url('../img/wood.jpg');
  background-size:100% 100%, cover; filter:brightness(1.08) saturate(.96);
  box-shadow: 0 3px 0 rgba(133,74,26,.85), 0 8px 14px rgba(0,0,0,.45);
}
.drill-notif-btn:active{ transform:translateY(2px); box-shadow: 0 1px 0 rgba(120,60,20,.9), 0 4px 8px rgba(0,0,0,.55); }
.drill-notif-actions{ margin-top:10px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
</style>
</head>
<body>

<div id="drill-root">
  <div id="drill-inner">
    <div id="drill-topbar">
      <button id="dbtn-menu" class="s-back" type="button" aria-label="Back">← Back</button>
    </div>

    <div id="go-board-drill-wrap">
      <div id="go-board-drill" style="position:relative;width:100%;border-radius:6px;overflow:hidden;box-shadow:0 18px 40px rgba(0,0,0,.32), 0 6px 16px rgba(0,0,0,.22);">
         </div>
      
      <div id="drill-ctrls">
        <button id="dbtn-next" class="pbtn pbtn-alt" type="button">Skip</button>
        <div id="drill-progress" style="font-weight:800;opacity:.9;">1 / 1</div>
      </div>
    </div>
  </div>
</div>

<div id="go-zoom-overlay-drill"></div> 
<div id="go-zoom-top-drill"></div>
<div id="go-zoom-ui-drill"></div>
<div id="go-zoom-exit-drill" aria-label="Zoom out"></div>

<div id="drill-wrong" class="drill-notif" role="alert"><div class="drill-notif-card"><div class="drill-notif-title">Wrong</div></div></div>
<div id="drill-cleared" class="drill-notif" role="alert"><div class="drill-notif-card"><div class="drill-notif-title">Cleared</div></div></div>
<div id="drill-done" class="drill-notif" role="dialog" aria-modal="true">
  <div class="drill-notif-card">
    <div id="drill-done-title" class="drill-notif-title">All Drills Complete</div>
    <div id="drill-stats" class="drill-stats">
      <div class="drill-stat-box"><div class="drill-stat-label">Solved</div><div id="drill-stat-solved" class="drill-stat-value">0</div></div>
      <div class="drill-stat-box"><div class="drill-stat-label">Failed</div><div id="drill-stat-failed" class="drill-stat-value">0</div></div>
    </div>
    <div id="drill-done-msg" class="drill-notif-desc">Session finished.</div>
    <div class="drill-notif-actions">
      <button id="drill-done-back" class="drill-notif-btn" type="button">Back</button>
      <button id="drill-done-retry" class="drill-notif-btn" type="button">Retry</button>
    </div>
  </div>
</div>
<div id="drill-cap" class="drill-notif" role="dialog"><div class="drill-notif-card"><div class="drill-notif-title">Limit Reached</div><div class="drill-notif-actions"><button id="drill-cap-ok" class="drill-notif-btn" type="button">OK</button></div></div></div>

<script>
if (!window.WGo) {
  var s = document.createElement('script');
  s.src = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754893285939x971907393576095400/wgo.min.js";
  s.async = true;
  document.head.appendChild(s);
}
</script>

<script>
if (!window.StoneSFX) {
  window.StoneSFX = (() => {
    let pool = [], i = 0, unlocked = false;
    function init(url, voices = 5, volume = 0.35){
      pool = Array.from({ length: voices }, () => { const a = new Audio(url); a.preload='auto'; a.volume=volume; return a; });
      const unlock = () => { if (unlocked) return; pool.forEach(a=>{try{a.play().then(()=>a.pause()).catch(()=>{});a.currentTime=0;}catch(e){}}); unlocked=true; window.removeEventListener('touchstart',unlock); window.removeEventListener('mousedown',unlock); };
      window.addEventListener('touchstart', unlock, {once:true}); window.addEventListener('mousedown', unlock, {once:true});
    }
    function play(){ if(!pool.length)return; const a=pool[i++%pool.length]; try{a.currentTime=0; a.playbackRate=0.97+Math.random()*0.06; a.play();}catch(e){} }
    return { init, play };
  })();
  StoneSFX.init("https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754926303439x491369894441766600/klick.mp3");
}
(function bridgeSound(){
  if(window._drillSoundInit)return; window._drillSoundInit=true;
  if(typeof StoneSFX.play==='function' && !('_enabled' in StoneSFX)){
    StoneSFX._enabled = (window.GoPrefs ? !!window.GoPrefs.soundOn : true);
    const _orig=StoneSFX.play.bind(StoneSFX); StoneSFX.play=function(){if(StoneSFX._enabled)_orig();};
  }
})();
</script>

<script>
(function DrillBoardMount(){
  const SGF_URL = "../sgf/library-1.sgf";
  const MIN_MOVES = 10;

  /* === CORE-STYLE ZOOM VARIABLES === */
  let scale = 1, minScale = 1, maxScale = 2.6;
  let offsetX = 0, offsetY = 0;
  let baseW = 0; 
  let zoomLayer = null;
  let isFullscreen = false;
  let isZoomAnimating = false;
  let animId = 0;
  let returnAnchor = null; 
  let isPanning = false, panStart = null, tapStart = null;
  const TAP_SLOP2 = 64; 
  let isFlinging = false, flingId = 0, flingVX = 0, flingVY = 0, flingLastTime = 0;
  let panSamplePrev = null, panSampleCurr = null;
  
  // UI Re-homing vars
  let zoomTopUI = document.getElementById('go-zoom-top-drill');
  let zoomBottomUI = document.getElementById('go-zoom-ui-drill');
  let zoomOverlay = document.getElementById('go-zoom-overlay-drill');
  let zoomExitBtn = document.getElementById('go-zoom-exit-drill');
  const zoomUIStore = { topbar: { parent:null, next:null }, ctrls:  { parent:null, next:null } };

  // --- UI Elements ---
  const wrap    = document.getElementById('go-board-drill-wrap');
  const mount   = document.getElementById('go-board-drill');
  const btnMenu = document.getElementById('dbtn-menu');
  const btnNext = document.getElementById('dbtn-next');
  const progEl  = document.getElementById('drill-progress');
  const wrongM  = document.getElementById('drill-wrong');
  const clearedM= document.getElementById('drill-cleared');
  const doneM   = document.getElementById('drill-done');

  // --- State ---
  let SIZE = 19, board=null, grid=null;
  let index = 0, slots = [], lineToSlotIdxs = {}, runPlan = {};
  let remain = [], currentTransformed = null;
  let solvedCount=0, failedCount=0, locked=false, timeUp=false;
  let blitzMode=false, timerMs=0, timerId=null, blitzCornerPlannedMoves=0;
  let timerEl=null, blitzCornerState=null;

  // --- Preferences ---
  var GoPrefs = window.GoPrefs = window.GoPrefs || {};
  try { Object.assign(GoPrefs, JSON.parse(localStorage.getItem('go_prefs')||'{}')); }catch(e){}
  let zoomEnabled = (typeof GoPrefs.josekiZoom !== 'undefined') ? !!GoPrefs.josekiZoom : true;

  // ============================================
  //  CORE-STYLE ZOOM ENGINE (Transplanted)
  // ============================================

  function ensureZoomLayer(){
    if (zoomLayer) return;
    zoomLayer = document.createElement('div');
    zoomLayer.style.position = 'absolute';
    zoomLayer.style.left = '0px'; zoomLayer.style.top = '0px';
    zoomLayer.style.transformOrigin = '0 0';
    zoomLayer.style.willChange = 'transform';
    // Move children
    while (mount.firstChild) zoomLayer.appendChild(mount.firstChild);
    mount.appendChild(zoomLayer);
    // Background logic
    zoomLayer.style.backgroundImage = "url('https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1755870506985x437178801728222500/wood.jpg')";
    zoomLayer.style.backgroundSize = "cover";
    zoomLayer.style.backgroundPosition = "center";
    mount.style.background = "none"; 
  }

  function canvasCssScale(){
    const c = mount.querySelector('canvas');
    if (!c) return 1;
    const cssW = c.clientWidth || c.getBoundingClientRect().width || 0;
    const intW = c.width || 0;
    return (cssW && intW) ? cssW / intW : 1;
  }
  function getXcss(i){ return board.getX(i) * canvasCssScale(); }
  function getYcss(j){ return board.getY(j) * canvasCssScale(); }
  function getGridSpacing(){ return { x: Math.abs(getXcss(1)-getXcss(0)), y: Math.abs(getYcss(1)-getYcss(0)) }; }
  
  function viewportSize(){ return { vw: mount.clientWidth, vh: mount.clientHeight }; }

  function clampPan(){
    if (isZoomAnimating) return;
    const {vw, vh} = viewportSize();
    const bw = Math.round(baseW * scale);
    const bleedX = Math.ceil(vw * 0.5); 
    const bleedY = Math.ceil(vh * 0.5);
    const minOX = -bleedX;
    const maxOX = Math.max(0, bw - vw) + bleedX;
    const minOY = -bleedY;
    const maxOY = Math.max(0, bw - vh) + bleedY;
    offsetX = Math.max(minOX, Math.min(offsetX, maxOX));
    offsetY = Math.max(minOY, Math.min(offsetY, maxOY));
  }

  function applyPanAndSize(redrawAfter){
    const targetW = baseW;
    if (board && board._lastW !== targetW) {
      board.setWidth(targetW);
      if (zoomLayer) { zoomLayer.style.width = targetW + 'px'; zoomLayer.style.height = targetW + 'px'; }
      board._lastW = targetW;
      if (!redrawAfter) redrawAfter = true;
    }
    clampPan();
    if (zoomLayer) {
      zoomLayer.style.transform = 'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';
    }
    if (redrawAfter) redraw();
  }

  function animateTo(targetScale, pxWorld, pyWorld, sxTarget, syTarget, onDone){
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
    cancelFling();
    const s0 = scale;
    const ox0 = offsetX, oy0 = offsetY;
    const t0 = performance.now();
    const dur = 300; 
    cancelAnimationFrame(animId);
    isZoomAnimating = true;
    const targetOffsetX = (pxWorld * targetScale) - sxTarget;
    const targetOffsetY = (pyWorld * targetScale) - syTarget;

    (function step(now){
      let t = (now - t0) / dur; if (t > 1) t = 1;
      const e = 1 - Math.pow(1 - t, 3); 
      scale = s0 + (targetScale - s0) * e;
      offsetX = ox0 + (targetOffsetX - ox0) * e;
      offsetY = oy0 + (targetOffsetY - oy0) * e;
      applyPanAndSize(false);
      if (t < 1){ animId = requestAnimationFrame(step); } 
      else { isZoomAnimating = false; applyPanAndSize(true); if(onDone) onDone(); }
    })(t0);
  }

  /* === UI RE-HOMING LOGIC === */
  function stashAndMove(el, slot, container){
    if (!el || !container) return;
    if (!zoomUIStore[slot].parent){ zoomUIStore[slot].parent = el.parentNode; zoomUIStore[slot].next = el.nextSibling; }
    container.appendChild(el);
  }
  function restoreStashed(el, slot){
    if (!el) return;
    const store = zoomUIStore[slot];
    const p = store.parent, n = store.next;
    if (p){ if (n && n.parentNode === p) p.insertBefore(el, n); else p.appendChild(el); }
    store.parent = null; store.next = null;
  }
  function moveZoomUIIn(){
    if (blitzMode) ensureTimerEl();
    const tb = document.getElementById('drill-topbar');
    const bc = document.getElementById('drill-ctrls');
    stashAndMove(tb, 'topbar', zoomTopUI);
    stashAndMove(bc, 'ctrls',  zoomBottomUI);
    if(zoomTopUI) zoomTopUI.style.display='flex';
    if(zoomBottomUI) zoomBottomUI.style.display='flex';
    if(zoomOverlay) zoomOverlay.style.display='block';
    if(zoomExitBtn) zoomExitBtn.style.display='block';
  }
  function restoreZoomUIOut(){
    const tb = document.getElementById('drill-topbar');
    const bc = document.getElementById('drill-ctrls');
    restoreStashed(tb, 'topbar');
    restoreStashed(bc, 'ctrls');
    if(zoomTopUI) zoomTopUI.style.display='none';
    if(zoomBottomUI) zoomBottomUI.style.display='none';
    if(zoomOverlay) zoomOverlay.style.display='none';
    if(zoomExitBtn) zoomExitBtn.style.display='none';
  }

  function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
    if (isFullscreen) return;
    cancelFling();

    // 1. Create Placeholder & Move Mount to Body
    returnAnchor = document.createElement('div');
    returnAnchor.style.width = mount.clientWidth + 'px';
    returnAnchor.style.height = mount.clientHeight + 'px';
    mount.parentNode.insertBefore(returnAnchor, mount);
    document.body.appendChild(mount);

    // 2. Set Fullscreen State
    mount.classList.add('is-fullscreen');
    isFullscreen = true;
    moveZoomUIIn(); // Move controls to overlay

    // 3. Reset View
    scale = 1; offsetX = 0; offsetY = 0;
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    baseW = Math.floor(Math.min(vw, vh));
    if (baseW % 2) baseW--;

    // 4. Animate
    requestAnimationFrame(function(){
      applyPanAndSize(true);
      const initialFactor = 2.4; 
      const px_curr = getXcss(i); 
      const py_curr = getYcss(j);
      
      const rect = mount.getBoundingClientRect();
      let sx = rect.width / 2;
      let sy = rect.height / 2;
      if (typeof tapClientX === 'number' && typeof tapClientY === 'number'){
        sx = tapClientX - rect.left;
        sy = tapClientY - rect.top;
      }
      offsetX = px_curr * 1.0 - sx;
      offsetY = py_curr * 1.0 - sy;
      applyPanAndSize(false);
      animateTo(initialFactor, px_curr, py_curr, sx, sy);
    });
  }

  function exitFullscreen(){
    cancelFling(); cancelAnimationFrame(animId); isZoomAnimating = false;
    restoreZoomUIOut(); // Restore controls
    
    mount.classList.remove('is-fullscreen');
    isFullscreen = false;
    
    if (returnAnchor && returnAnchor.parentNode){
      returnAnchor.parentNode.insertBefore(mount, returnAnchor);
      returnAnchor.parentNode.removeChild(returnAnchor);
      returnAnchor = null;
    }
    mount.style.width = ''; mount.style.height = '';
    fitBoard(); 
    resetViewLocal();
  }

  function resetViewLocal(){ scale = 1; offsetX = 0; offsetY = 0; applyPanAndSize(true); }

  function startFling(vx, vy){
    if (scale <= 1) return;
    cancelFling();
    var speed = Math.sqrt(vx*vx + vy*vy);
    var MAX_SPEED = 0.50; 
    if (speed > MAX_SPEED){ var s = MAX_SPEED / speed; vx *= s; vy *= s; speed = MAX_SPEED; }
    if (speed < 0.04) return;
    isFlinging = true;
    flingVX = vx; flingVY = vy; flingLastTime = performance.now();
    (function step(now){
      if (!isFlinging) return;
      var dt = now - flingLastTime;
      if (dt <= 0){ flingId = requestAnimationFrame(step); return; }
      if (dt > 50) dt = 50;
      flingLastTime = now;
      offsetX += flingVX * dt;
      offsetY += flingVY * dt;
      var friction = 0.0010; 
      var currentSpeed = Math.sqrt(flingVX*flingVX + flingVY*flingVY);
      var decel = friction * dt;
      if (currentSpeed <= 0.01 || decel >= currentSpeed){ cancelFling(); applyPanAndSize(true); return; }
      var newSpeed = currentSpeed - decel;
      var scaleFactor = newSpeed / currentSpeed;
      flingVX *= scaleFactor; flingVY *= scaleFactor;
      applyPanAndSize(false);
      flingId = requestAnimationFrame(step);
    })(performance.now());
  }
  function cancelFling(){ isFlinging = false; if (flingId) { cancelAnimationFrame(flingId); flingId = 0; } }

  // --- TOUCH HANDLERS (The Core Logic) ---
  function bindTouch(){
    mount.addEventListener('pointerdown', function(e){
      if (!zoomEnabled) return;
      if (e.pointerType !== 'touch' && e.button !== 0) return;
      cancelFling();
      const r = mount.getBoundingClientRect();
      const sx = e.clientX - r.left, sy = e.clientY - r.top;
      const boardX = (sx + offsetX) / scale, boardY = (sy + offsetY) / scale;
      
      let bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
      for (let i = 0; i < SIZE; i++){ const dx = Math.abs(getXcss(i) - boardX); if (dx < bestDx){ bestDx = dx; bestI = i; } }
      for (let j = 0; j < SIZE; j++){ const dy = Math.abs(getYcss(j) - boardY); if (dy < bestDy){ bestDy = dy; bestJ = j; } }
      
      const spacing = getGridSpacing();
      if (bestDx > spacing.x * 0.5 || bestDy > spacing.y * 0.5) { tapStart = null; return; }
      
      panStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY };
      panSamplePrev = panSampleCurr = null;
      try { mount.setPointerCapture(e.pointerId); } catch(_){}
      tapStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY, gridI: bestI, gridJ: bestJ };
    }, {passive:false});

    mount.addEventListener('pointermove', function(e){
      if (!zoomEnabled || !panStart) return;
      if (scale <= 1.01 && !isFullscreen) return;
      const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y;
      if (!isPanning && (dx*dx + dy*dy > TAP_SLOP2)) isPanning = true;
      if (isPanning) {
        offsetX = panStart.ox - dx; offsetY = panStart.oy - dy;
        applyPanAndSize(false); e.preventDefault();
        const now = performance.now();
        panSamplePrev = panSampleCurr; panSampleCurr = { ox: offsetX, oy: offsetY, t: now };
      }
    }, {passive:false});

    mount.addEventListener('pointerup', function(e){
      if (!zoomEnabled) { /* handle click normally via WGo check later */ return; }
      if (!tapStart) { if (panStart) { try { mount.releasePointerCapture(e.pointerId); } catch(_){} panStart = null; } return; }
      try { mount.releasePointerCapture(e.pointerId); } catch(_){}
      
      const dist2 = (e.clientX - tapStart.x)**2 + (e.clientY - tapStart.y)**2;
      const { gridI, gridJ } = tapStart;
      const tapX = tapStart.x, tapY = tapStart.y;
      tapStart = null; panStart = null;

      if (isPanning) {
        isPanning = false;
        if (panSamplePrev && panSampleCurr) {
          const dt = panSampleCurr.t - panSamplePrev.t;
          if (dt > 0 && dt < 120) startFling((panSampleCurr.ox - panSamplePrev.ox)/dt, (panSampleCurr.oy - panSamplePrev.oy)/dt);
        }
        return;
      }

      if (dist2 <= TAP_SLOP2) {
        e.preventDefault();
        if (scale <= 1.05 && !isFullscreen) {
          enterFullscreenAtGrid(gridI, gridJ, tapX, tapY);
        } else {
          onBoardClick(gridI, gridJ);
          if (!GoPrefs.disableAutoZoomOut && scale > 1) setTimeout(function(){ if(isFullscreen) exitFullscreen(); }, 10);
        }
      }
    }, {passive:false});
  }

  function fitBoard(){
    if (isFullscreen) return; 
    var w = wrap.getBoundingClientRect().width;
    w = Math.floor(w); if(w%2) w--;
    baseW = w;
    mount.style.width = w+'px'; mount.style.height = w+'px';
    applyPanAndSize(true);
  }

  // ============================================
  //  DRILLS LOGIC
  // ============================================
  function initBoard(){
    if (!window.WGo) return setTimeout(initBoard, 40);
    if (board) return; 
    board = new WGo.Board(mount, { size: SIZE });
    ensureZoomLayer();
    bindTouch();
    fitBoard();
    if(zoomExitBtn) zoomExitBtn.addEventListener('click', function(e){ e.stopPropagation(); exitFullscreen(); });
    window.addEventListener('resize', fitBoard);
  }

  function resetGrid(){ grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null)); }
  function addStone(x,y,color){ grid[y][x]=color; }
  function playMove(x,y,color, silent=false){
    addStone(x,y,color);
    if (!silent && window.StoneSFX) StoneSFX.play();
    redraw();
  }
  function redraw(){
    if (!board) return;
    board.removeAllObjects();
    for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++){
      const v=grid[y][x];
      if (v==='B') board.addObject({x,y,c:WGo.B});
      else if (v==='W') board.addObject({x,y,c:WGo.W});
    }
    if (blitzMode && currentTransformed) drawBlitzMarkers();
  }

  /* ... (Existing Drills transform/game functions maintained) ... */
  function t_identity(p){ return {x:p.x,y:p.y}; }
  function t_swap(p){ return {x:p.y, y:p.x}; }
  function t_rot90(p,S){  return {x: S-1 - p.y, y: p.x}; }
  function t_rot180(p,S){ return {x: S-1 - p.x, y: S-1 - p.y}; }
  function t_rot270(p,S){ return {x: p.y, y: S-1 - p.x}; }
  function compose(a,b,S){ return function(p){ return a(b(p,S),S); }; }
  function ORIENT_FUNCS(S){ return [ p=>t_identity(p), p=>t_swap(p), p=>t_rot90(p,S), p=>compose(t_swap,t_rot90,S)(p), p=>t_rot180(p,S), p=>compose(t_swap,t_rot180,S)(p), p=>t_rot270(p,S), p=>compose(t_swap,t_rot270,S)(p) ]; }
  const ROT_IDX_ONLY = [0,2,4,6];

  function makeTransformed(line, orientIdx, swap){
    const S = line.size || 19, ORS = ORIENT_FUNCS(S), o = ORS[orientIdx % ORS.length];
    const tf = p => { const t=o({x:p.x,y:p.y}, S); return {x:t.x,y:t.y}; };
    const AB = (line.rootAB||[]).map(tf), AW = (line.rootAW||[]).map(tf);
    const mv = (line.moves||[]).map(m=>{ const t=tf(m); const c = swap ? (m.color==='B'?'W':'B') : m.color; return { x:t.x, y:t.y, color:c }; });
    return { size:S, rootAB: swap ? AW : AB, rootAW: swap ? AB : AW, moves: mv };
  }

  // --- Start & Plan ---
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function range(a,b){ const out=[]; for(let i=a;i<=b;i++) out.push(i); return out; }

  function startDrill(i, opts){
    opts = opts || {};
    index = i;
    if (index >= slots.length){ showDone(); return; }
    const slot = slots[index], base = slot.base, key = slot.key;
    SIZE = base.size || 19;
    if (!board) initBoard();
    
    // Ensure run plan
    if (!runPlan[key]){
      const k = lineToSlotIdxs[key].length;
      const orientIdxs = shuffle((blitzMode ? ROT_IDX_ONLY : range(0,7)).slice()).slice(0, k||1);
      let swaps = Array(k).fill(false);
      for(let j=0;j<Math.round(k*0.5);j++) swaps[j]=true;
      swaps = shuffle(swaps);
      const plan = new Map(), shuffledSlots = shuffle(lineToSlotIdxs[key].slice());
      const startsPool = range(Math.max(4,0), Math.max(4, base.moves.length-2));
      const chosenStarts = shuffle(startsPool.slice());
      for(let j=0;j<k;j++){
        plan.set(shuffledSlots[j], { 
          orientIdx: orientIdxs[j%orientIdxs.length], 
          swap: swaps[j],
          startIndex: blitzMode ? 0 : chosenStarts[j%chosenStarts.length] 
        });
      }
      runPlan[key] = plan;
    }

    const variant = runPlan[key].get(index);
    const tline = makeTransformed(base, variant.orientIdx, variant.swap);
    currentTransformed = tline;

    resetGrid();
    (tline.rootAB||[]).forEach(p=>addStone(p.x,p.y,'B'));
    (tline.rootAW||[]).forEach(p=>addStone(p.x,p.y,'W'));
    for (let s=0;s<variant.startIndex;s++){ const m = tline.moves[s]; playMove(m.x,m.y,m.color, true); }
    remain = tline.moves.slice(variant.startIndex).map(m=>({x:m.x,y:m.y,color:m.color}));
    redraw();

    blitzCornerPlannedMoves = remain.length;
    if (blitzMode){
      ensureTimerEl();
      if (!opts.fromSkip) timerMs += blitzCornerPlannedMoves * 1500;
      if (!timerId) timerId = setInterval(()=>{ timerMs-=100; if(timerEl)timerEl.textContent=fmtMs(timerMs); if(timerMs<=0){ clearInterval(timerId); timerId=null; timeUp=true; showDone('Time’s up!'); } }, 100);
      if (timerEl) timerEl.textContent = fmtMs(timerMs);
      blitzCornerState = { tline, startIndex: variant.startIndex };
    } else {
      if(timerId) clearInterval(timerId); timerId=null;
    }

    if (progEl) progEl.textContent = (slots.length ? (index+1) : 0) + ' / ' + (slots.length || 0);
    locked = false;
  }

  function ensureTimerEl(){
    if (timerEl || !blitzMode) return;
    timerEl = document.createElement('div'); timerEl.id = 'blitz-timer'; timerEl.textContent = '0.0s';
    const topbar = document.getElementById('drill-topbar');
    if (topbar) topbar.appendChild(timerEl);
  }
  function fmtMs(ms){ if (ms<0) ms=0; return (ms/1000).toFixed(1) + 's'; }
  function drawBlitzMarkers(){
    if (!currentTransformed || currentTransformed.moves.length<1) return;
    const m1=currentTransformed.moves[0]; board.addObject({ x:m1.x, y:m1.y, type:'LB', text:'A' });
  }

  function onBoardClick(x,y){
    if (locked || timeUp) return;
    if (x<0 || y<0 || x>=SIZE) return;
    if (grid[y][x] !== null) return;
    if (!remain.length) return;

    const next = remain[0];
    if (next.x === x && next.y === y){
      playMove(x,y,next.color, false);
      remain.shift();
      if (!remain.length){
        solvedCount++;
        if (blitzMode){ timerMs += blitzCornerPlannedMoves * 500; if(timerEl) timerEl.textContent=fmtMs(timerMs); }
        locked=true; clearedM.style.display='flex';
        setTimeout(()=>{ 
          clearedM.style.display='none'; locked=false; 
          if(index>=slots.length-1) showDone(); else startDrill(index+1); 
        }, 850);
      }
    } else {
      failedCount++;
      locked=true; wrongM.style.display='flex';
      setTimeout(()=>{ 
        wrongM.style.display='none'; 
        if(blitzMode){ 
            resetGrid(); 
            (blitzCornerState.tline.rootAB||[]).forEach(p=>addStone(p.x,p.y,'B'));
            (blitzCornerState.tline.rootAW||[]).forEach(p=>addStone(p.x,p.y,'W'));
            remain = blitzCornerState.tline.moves.slice(blitzCornerState.startIndex).map(m=>({x:m.x,y:m.y,color:m.color}));
            redraw(); locked=false; 
        } else {
            locked=false; if(index>=slots.length-1) showDone(); else startDrill(index+1);
        }
      }, 1000);
    }
  }

  function showDone(title){
    if(timerId) clearInterval(timerId); timerId=null;
    const el = document.getElementById('drill-done-title'); if(el) el.textContent = title || 'All Drills Complete';
    document.getElementById('drill-stat-solved').textContent = solvedCount;
    document.getElementById('drill-stat-failed').textContent = failedCount;
    doneM.style.display='flex';
  }

  // --- BOOTSTRAP ---
  // (Simplified SGF fetching logic for brevity - matches previous)
  window.DrillBoard = {
    load: function(lines, opts){
      // ... (Same fetching logic as before) ... 
      // Mockup for immediacy:
      fetch("../sgf/library-1.sgf").then(r=>r.text()).then(txt=>{
         // Parse SGF ...
         // For now, assuming you have the parse logic from before or the file is loaded
         // This block handles the "slots" array creation
         // ...
         // Call:
         // startDrill(0);
      }).catch(e=>{
         // fallback if fetching fails, mainly for testing
         // alert("Load error");
      });
      // In your real file, paste the parseSGF/fetch logic here.
      // Since it wasn't the broken part, I'm keeping the zoom engine focus.
    }
  };

  // Re-inserting the critical SGF Parsing logic needed to make it run:
  function rb(str,i){ let out='',k=i; while(k<str.length){ const ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; } if(ch===']') break; out+=ch; } return {t:out,n:k}; }
  function parseTree(str,i){ const seq=[]; let node=null; if(str[i]!=='(') return {seq:[],n:i}; i++; while(i<str.length){ const ch=str[i]; if(ch===';'){ node={}; seq.push(node); i++; } else if(/[A-Za-z]/.test(ch)){ let key=''; while(/[A-Za-z]/.test(str[i]||'')) key+=str[i++]; const vals=[]; while(str[i]==='['){ const r=rb(str,i+1); vals.push(r.t); i=r.n; } if(!node){ node={}; seq.push(node); } node[key]=vals.length>1?vals:vals[0]; } else if(ch==='('){ const child=parseTree(str,i); i=child.n; if(seq.length){ const p=seq[seq.length-1]; (p.variations||(p.variations=[])).push(child.seq); } } else if(ch===')'){ i++; break; } else i++; } for(let k=0;k<seq.length-1;k++) seq[k].next=seq[k+1]; return {seq,n:i}; }
  function parseAllTrees(str){ const trees=[]; let i=str.indexOf('('); if (str.charCodeAt && str.charCodeAt(0)===0xFEFF) str = str.slice(1); while(i>=0 && i<str.length){ const r = parseTree(str,i); if (r.seq && r.seq.length) trees.push(r.seq); const nxt = str.indexOf('(', r.n); if (nxt === -1) break; i = nxt; } return trees; }
  function parseSZ(sz){ if(!sz) return 19; const n=parseInt(sz.split(':')[0],10); return (n>=2&&n<=52)?n:19; }
  function xy(s,S){ if(!s||s.length<2) return null; const x=s.charCodeAt(0)-97,y=s.charCodeAt(1)-97; return (x<0||y<0||x>=S||y>=S)?null:{x,y}; }
  function listCoords(prop,S){ const arr=Array.isArray(prop)?prop:(prop?[prop]:[]); return arr.map(v=>xy(v,S)).filter(Boolean); }
  function linkify(seq,parent){ for(let i=0;i<seq.length;i++){ const n=seq[i]; n.prev=(i===0?parent:seq[i-1]); n.next=(i<seq.length-1?seq[i+1]:null); if(n.variations) for(const v of n.variations) if(v&&v.length) linkify(v,n); } }
  function nodeMove(n,S){ if(!n) return null; if(n.B){ const p=xy(n.B,S); if(p) return {x:p.x,y:p.y,color:'B'}; } if(n.W){ const p=xy(n.W,S); if(p) return {x:p.x,y:p.y,color:'W'}; } return null; }
  function enumerateLines(seq,S){ const lines=[]; let start=seq&&seq[0]; while(start && !nodeMove(start,S) && !start.variations) start=start.next; function dfs(node,acc){ if(!node){ lines.push(acc.slice()); return; } acc.push(node); if(node.variations && node.variations.length){ for(const v of node.variations){ let f=v&&v[0]; while(f && !nodeMove(f,S) && !f.variations) f=f.next; if(f) dfs(f,acc.slice()); } } if(node.next){ let nx=node.next; while(nx && !nodeMove(nx,S) && !nx.variations) nx=nx.next; if(nx) dfs(nx,acc); else lines.push(acc.slice()); } else lines.push(acc.slice()); } if(start) dfs(start,[]); return lines.map(nodes=>nodes.map(n=>nodeMove(n,S)).filter(Boolean)); }
  function lineKey(line){ const size = line.size || 19; const seq = (line.moves||[]).map(m => (m.color||'B')[0]+':'+m.x+','+m.y).join('|'); return `${size}|${seq}`; }
  function normalizeLineLike(obj){ return { size: obj.size || 19, rootAB: Array.isArray(obj.rootAB)?obj.rootAB:[], rootAW: Array.isArray(obj.rootAW)?obj.rootAW:[], moves: (obj.moves||[]).map(m => ({ x:m.x, y:m.y, color:(m.color==='W'?'W':'B') })) }; }
  
  function fetchLibraryLines(){
    return fetch(SGF_URL, { cache:'no-cache' }).then(r=>r.text()).then(txt=>{
      const trees = parseAllTrees(txt), lines=[];
      for (const seq of trees){
        linkify(seq,null); const size = parseSZ(seq[0]?.SZ);
        const rootAB = listCoords(seq[0]?.AB, size), rootAW = listCoords(seq[0]?.AW, size);
        const paths = enumerateLines(seq,size);
        for (const moves of paths){ if ((moves?.length||0) >= MIN_MOVES){ lines.push({ size, rootAB, rootAW, moves }); } }
      }
      return lines;
    });
  }

  // Overwrite the load function to actually work
  DrillBoard.load = function(linesOrNull, opts){
     var PER = Math.max(1, parseInt((opts && opts.perJoseki) || 3, 10) || 3);
     // ... (simplified selection logic for brevity, assuming standard fetch)
     fetchLibraryLines().then(lines => {
        const usable = lines.map(normalizeLineLike);
        // build slots
        slots = [];
        const buckets = new Map();
        usable.forEach(base => {
           const k = lineKey(base);
           for(let j=0; j<PER; j++) {
              if(!buckets.has(k)) buckets.set(k, []);
              buckets.get(k).push({key:k, base:base});
           }
        });
        // mix fairly
        const keys = Array.from(buckets.keys());
        while(slots.length < usable.length * PER){
           const k = keys[Math.floor(Math.random()*keys.length)];
           if(buckets.get(k).length) slots.push(buckets.get(k).pop());
           else keys.splice(keys.indexOf(k), 1);
           if(!keys.length) break;
        }
        
        lineToSlotIdxs = {};
        for(let i=0; i<slots.length; i++){
          const k = slots[i].key;
          if(!lineToSlotIdxs[k]) lineToSlotIdxs[k]=[];
          lineToSlotIdxs[k].push(i);
        }
        
        runPlan = {};
        startDrill(0);
     });
  };

  btnNext.addEventListener('click', function(){ if(slots.length) startDrill(index+1, {fromSkip:true}); });
  if (mount && !board) initBoard();
  window.addEventListener('DOMContentLoaded', ()=>DrillBoard.load(null, {perJoseki:3}));

})();
</script>
</body>
</html>