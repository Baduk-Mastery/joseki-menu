<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Master – Drills Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
 html, body{
  margin:0;
  padding:0;
  height:100%;
  min-height:100%;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
  background-color:#1b1208;
  overscroll-behavior:none;
  overflow: hidden;
  touch-action: none;
}
/* Fullscreen visual reset only (positioning handled by overlay + JS) */
#go-board-drill.is-fullscreen{
  border-radius: 0 !important;
  box-shadow: none !important;
  margin: 0 !important;
}
/* Reserve board space before JS so it doesn't "pop in" */
#go-board-drill-wrap{
  width: 100%;
}

#go-board-drill{
  width: 100%;
  aspect-ratio: 1 / 1;
  /* optional safety so tiny screens still show a block */
  min-height: 240px;
}

/* Placeholder background only when NOT in fullscreen zoom */
#go-board-drill:not(.is-fullscreen){
  background-image:
    linear-gradient(rgba(0,0,0,.10), rgba(0,0,0,.25)),
    url('../img/wood.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}

/* In fullscreen, let the page background show through */
#go-board-drill.is-fullscreen{
  background: transparent !important;
}


#go-board-drill{
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
}

#drill-root{
  --wood:url('../img/wood.jpg');
  position:fixed;
  inset:0;

  background-color:#1b1208;
  background-image:
    linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)),
    var(--wood);
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;
}

/* Practice-style centering of the whole drills block */
#drill-inner{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%, -50%);

  width:100%;
  max-width:720px;
  box-sizing:border-box;
}

/* Same mobile padding logic as Practice */
@media (max-width: 480px){
  #drill-inner{ padding:8px 12px 0; }
}


    /* we don’t hide the wrapper via data-hidden now, so it’s always visible */
    #go-board-drill canvas{ display:block; margin:0 auto; }

    .prac-ctrls{
      max-width:720px; margin:10px auto 0;
      padding:8px 12px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;
    }
    .pbtn{
      padding:12px 16px; border-radius:12px; border:1px solid #cbd5e1;
      background:#fff; font-weight:800; font-size:15px; color:#0f172a;
      cursor:pointer; box-shadow:0 2px 8px rgba(15,23,42,.06);
    }
    .pbtn:active{ transform:translateY(1px); }
    .pbtn-strong{ background:#111827; color:#fff; border-color:#111827; }
    .pbtn-alt{ background:#e7f0ff; color:#0b4aa2; border-color:#a7c1ff; }

#blitz-timer{
  margin-left:auto;
  display:inline-flex;
  align-items:center;
  justify-content:center;

  /* keep the size you wanted */
  padding:6px 12px;
  border-radius:8px;

  /* lock width so 10.0s -> 9.9s doesn't shrink */
  min-width:7ch;

  white-space:nowrap;
  text-align:center;

  /* chip styling (not a wood button) */
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  font-weight:900;
  font-size:14px;
  line-height:1.1;
  letter-spacing:0.5px;

  color:#fff3cf;
  text-shadow:0 1px 0 rgba(0,0,0,.35);

  background:
    linear-gradient(
      to bottom,
      rgba(255,255,255,.10),
      rgba(0,0,0,.18)
    ),
    rgba(0,0,0,.28);

  border:1px solid rgba(255,255,255,.35);

  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.12),
    0 4px 10px rgba(0,0,0,.35);

  cursor:default;
  user-select:none;
  -webkit-user-select:none;
  -webkit-tap-highlight-color:transparent;
}

/* class kept for clarity/future tweaks */
.blitz-chip{ }
/* =========================
   Blitz countdown overlay
   ========================= */
#blitz-countdown{
  position: fixed;
  inset: 0;
  z-index: 100001; /* above drill-notif */
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.55);
}

#blitz-countdown-card{
  min-width: 220px;
  padding: 24px 22px;
}

#blitz-countdown-number{
  font-weight: 900;
  font-size: 56px;
  line-height: 1;
  letter-spacing: 1px;
}


  </style>
<style>

#drill-topbar{
  max-width:720px;
  width:100%;
  margin:16px auto 10px;
  padding:0;
  box-sizing:border-box;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

body.drill-zoom-mode #drill-topbar{
  pointer-events: none;
}

body.drill-zoom-mode #drill-topbar > *{
  pointer-events: auto;
}



/* Wood-style Back button – copied from Practice */
.s-back{
  position:relative;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:6px;

  padding:6px 12px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,.40);

  font-size:14px;
  font-weight:800;
  line-height:1.1;
  color:#fff3cf;
  text-shadow:0 1px 0 rgba(120,60,20,.7);
  cursor:pointer;

  user-select:none;
  -webkit-user-select:none;
  -moz-user-select:none;
  -ms-user-select:none;
  -webkit-tap-highlight-color:transparent;

  background-image:
    linear-gradient(
      to bottom,
      rgba(255,255,255,.12),
      rgba(255,255,255,.03) 38%,
      rgba(0,0,0,.14) 100%
    ),
    url('../img/wood.jpg');
  background-size:100% 100%, cover;
  background-position:center;
  background-repeat:no-repeat;

  filter:brightness(1.08) saturate(.96);

  box-shadow:
    0 3px 0 rgba(133,74,26,.85),
    0 8px 14px rgba(0,0,0,.45);

  transition:
    transform .08s ease-out,
    box-shadow .08s ease-out,
    filter .12s ease-out;
}

.s-back:hover{
  filter:brightness(1.12) saturate(.98);
  transform:translateY(-1px);
  box-shadow:
    0 4px 0 rgba(133,74,26,.9),
    0 10px 16px rgba(0,0,0,.48);
}

.s-back:active{
  filter:brightness(.97) saturate(.96);
  transform:translateY(2px);
  box-shadow:
    0 1px 0 rgba(120,60,20,.9),
    0 4px 8px rgba(0,0,0,.55);
}

/* Drill controls container – match Practice spacing */
#drill-ctrls{
  max-width: 720px;
  width: 100%;
  box-sizing: border-box;
  margin: 14px auto 0;
  padding: 0 12px 18px;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
}

#drill-ctrls .pbtn,
#drill-ctrls .pbtn-strong,
#drill-ctrls .pbtn-alt{
  position: relative;
  min-width: 90px;
  padding: 8px 24px;

  /* Approx. same width as if there were 3 buttons on the line */
  flex: 0 1 calc((100% - 24px) / 3);
  max-width: 240px;

  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;

  text-align: center;

  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.40);

  font-size: 16px;
  font-weight: 800;
  line-height: 1.1;
  color: #fff3cf;
  text-shadow: 0 1px 0 rgba(120,60,20,.7);
  cursor: pointer;

  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-tap-highlight-color: transparent;

  background-image:
    linear-gradient(
      to bottom,
      rgba(255,255,255,.12),
      rgba(255,255,255,.03) 38%,
      rgba(0,0,0,.14) 100%
    ),
    url('../img/wood.jpg');
  background-size: 100% 100%, cover;
  background-position: center;
  background-repeat: no-repeat;

  filter: brightness(1.08) saturate(.96);

  box-shadow:
    0 3px 0 rgba(133,74,26,.85),
    0 8px 14px rgba(0,0,0,.45);

  transition:
    transform .08s ease-out,
    box-shadow .08s ease-out,
    filter .12s ease-out;
}


#drill-ctrls .pbtn:hover{
  filter: brightness(1.12) saturate(.98);
  transform: translateY(-1px);
  box-shadow:
    0 4px 0 rgba(133,74,26,.9),
    0 10px 16px rgba(0,0,0,.48);
}

#drill-ctrls .pbtn:active{
  filter: brightness(.97) saturate(.96);
  transform: translateY(2px);
  box-shadow:
    0 1px 0 rgba(120,60,20,.9),
    0 4px 8px rgba(0,0,0,.55);
}

#drill-ctrls .pbtn:focus-visible{
  outline: 2px solid rgba(255,255,255,.9);
  outline-offset: 2px;
}
/* === Drills bottom bar alignment fix ===
   Next stays dead-center, progress aligns to board-right */
#drill-ctrls{
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  align-items: center;
  gap: 0;

  /* keep your existing sizing/spacing intent */
  max-width: 720px;
  width: 100%;
  margin: 14px auto 0;
  padding: 0 12px 18px;
  box-sizing: border-box;
}

/* Center column */
#drill-ctrls #dbtn-next{
  grid-column: 2;
  justify-self: center;
  width: auto;
}

/* Right column */
#drill-ctrls #drill-progress{
  grid-column: 3;
  justify-self: end;
  text-align: right;
  min-width: 60px;
}

/* Neutralize the "3 buttons per row" sizing for this bar */
#drill-ctrls .pbtn,
#drill-ctrls .pbtn-strong,
#drill-ctrls .pbtn-alt{
  flex: initial;
  max-width: none;
  min-width: 0;
}

</style>

<style>
/* Fullscreen zoom overlay for drills (Practice-style zoom) */
#go-zoom-overlay-drill{
  position:fixed;
  inset:0;
  z-index:99998;
  display:none;
  align-items:center;
  justify-content:center;
  background:transparent;
  -webkit-tap-highlight-color:transparent;
  touch-action:none;

  /* NEW safety: cannot intercept taps unless we are in zoom-mode */
  pointer-events:none;
}

/* NEW: enable overlay hit-testing only in zoom mode */
body.drill-zoom-mode #go-zoom-overlay-drill{
  pointer-events:auto;
}


  #go-zoom-stage-drill{
    width:100vw;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    touch-action:none;
  }

#go-zoom-exit-drill{
  position:fixed;
  left:14px;
  bottom:90px;
  width:120px;
  height:80px;
  border-radius:9px;

  background:rgba(148,163,184,.35);
  border:1px solid rgba(148,163,184,.85);
  box-shadow:0 6px 16px rgba(0,0,0,.55);

  display:none;
  cursor:pointer;
  z-index:99999;
  backdrop-filter:blur(2px);
  -webkit-tap-highlight-color:transparent;

  /* NEW safety: default to non-interactive */
  pointer-events:none;
}

/* NEW: only interactive while in zoom mode */
body.drill-zoom-mode #go-zoom-exit-drill{
  pointer-events:auto;
}


  #go-zoom-exit-drill::before{
    content:"";
  }
</style>
<style>
#go-zoom-top-drill{
  position:fixed;
  left:0; right:0; top:0;
  padding:12px 12px 0;

  display:none;               /* toggled by JS */
  justify-content:center;
  align-items:flex-start;

  pointer-events:none;
  z-index:99999;
}
#go-zoom-top-drill > *{
  pointer-events:auto;
}

/* Bottom overlay container */
#go-zoom-ui-drill{
  position:fixed;
  left:0; right:0; bottom:0;

  /* Outer dock padding (same as Joseki dock) */
  padding:0 12px 18px;

  display:none;               /* toggled by JS */
  flex-direction:column;
  align-items:center;

  pointer-events:none;
  z-index:99999;
}
#go-zoom-ui-drill > *{
  pointer-events:auto;
}


/* IMPORTANT: restore inner padding for the docked bottom bar
   to match the Joseki “double padding” look */
#go-zoom-ui-drill #drill-ctrls{
  max-width:720px;
  width:100%;
  margin:0 auto;

  /* Inner padding restored (matches Joseki zoom mode) */
  padding:0 12px 18px;
  box-sizing:border-box;
}

/* =========================
   Drills dock: let board taps pass through empty space
   ========================= */

/* In zoom mode, don't let the whole controls bar capture taps */
body.drill-zoom-mode #go-zoom-ui-drill #drill-ctrls{
  pointer-events: none;
}

/* Re-enable only the real interactive element(s) */
body.drill-zoom-mode #go-zoom-ui-drill #dbtn-next{
  pointer-events: auto;
}

/* Progress text should not block board taps */
body.drill-zoom-mode #go-zoom-ui-drill #drill-progress{
  pointer-events: none;
}

body.drill-zoom-mode #drill-ctrls{
  max-width:720px;
  width:100%;
  margin:0 auto;
  padding:0 12px 18px;
  box-sizing:border-box;
}
</style>
</style>

<style>
/* =========================
   Drills notifications – match My Patterns notice/toast look
   ========================= */

.drill-notif{
  position:fixed;
  inset:0;
  z-index:100000;
  display:none;
  align-items:center;
  justify-content:center;
  padding:0;
  background:rgba(0,0,0,.55);
}

/* Card skin copied from My Patterns own-notice-card / own-toast-card */
.drill-notif-card{
  position:relative;
  border-radius:10px;
  border:1px solid #e2e8f0;
  box-shadow:0 12px 28px rgba(15,23,42,.18);
  padding:16px;
  text-align:center;
  font-family:system-ui, "Segoe UI", Arial, sans-serif;

  color:#fff3cf;

  background-image:
    linear-gradient(
      to bottom,
      rgba(0,0,0,.10),
      rgba(0,0,0,.25)
    ),
    url('../img/notification.jpg');
  background-size:cover;
  background-position:center;
  background-repeat:no-repeat;

  min-width:280px;
  max-width:min(86vw, 460px);
  max-height:calc(100vh - 32px);
  overflow:auto;
}

/* Ensure we don’t get random inline color clashes */
.drill-notif-card > *{
  color:inherit !important;
}

.drill-notif-title{
  font-weight:800;
  font-size:18px;
  line-height:1.35;
  margin-bottom:8px;
}

.drill-notif-desc{
  font-size:16px;
  line-height:1.4;
  margin-bottom:14px;
  opacity:.96;
}

/* Done stats styling to fit the notif skin */
.drill-stats{
  display:flex;
  gap:10px;
  justify-content:center;
  flex-wrap:wrap;
  margin:6px 0 10px;
}

.drill-stat-box{
  border:1px solid rgba(255,255,255,.25);
  border-radius:10px;
  padding:10px 14px;
  min-width:140px;
  background:rgba(0,0,0,.18);
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
}

.drill-stat-label{
  font-weight:800;
  opacity:.85;
  margin-bottom:2px;
}

.drill-stat-value{
  font-weight:900;
  font-size:22px;
  line-height:1;
}

/* Wood-style buttons for notif actions (mirrors My Patterns .s-btn) */
.drill-notif-btn{
  position:relative;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:6px;

  padding:8px 18px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.40);

  font-size:16px;
  font-weight:800;
  line-height:1.1;
  color:#fff3cf;
  text-shadow:0 1px 0 rgba(120,60,20,.7);
  cursor:pointer;

  user-select:none;
  -webkit-user-select:none;
  -moz-user-select:none;
  -ms-user-select:none;
  -webkit-tap-highlight-color:transparent;

  background-image:
    linear-gradient(
      to bottom,
      rgba(255,255,255,.12),
      rgba(255,255,255,.03) 38%,
      rgba(0,0,0,.14) 100%
    ),
    url('../img/wood.jpg');
  background-size:100% 100%, cover;
  background-position:center;
  background-repeat:no-repeat;

  filter:brightness(1.08) saturate(.96);

  box-shadow:
    0 3px 0 rgba(133,74,26,.85),
    0 8px 14px rgba(0,0,0,.45);

  transition:
    transform .08s ease-out,
    box-shadow .08s ease-out,
    filter .12s ease-out;
}

.drill-notif-btn:hover{
  filter:brightness(1.12) saturate(.98);
  transform:translateY(-1px);
  box-shadow:
    0 4px 0 rgba(133,74,26,.9),
    0 10px 16px rgba(0,0,0,.48);
}

.drill-notif-btn:active{
  filter:brightness(.97) saturate(.96);
  transform:translateY(2px);
  box-shadow:
    0 1px 0 rgba(120,60,20,.9),
    0 4px 8px rgba(0,0,0,.55);
}

.drill-notif-btn-lg{
  padding:10px 22px;
}

/* Container for action rows */
.drill-notif-actions{
  margin-top:10px;
  display:flex;
  gap:10px;
  justify-content:center;
  flex-wrap:wrap;
}
</style>

</head>
<body>

<!-- ================= DRILL BOARD (adds Blitz mode) ================= -->
<div id="drill-root">
  <div id="drill-inner">

 <!-- Top bar (Practice-style Back placement) -->
<div id="drill-topbar">
  <button id="dbtn-menu" class="s-back" type="button" aria-label="Back">← Back</button>
</div>

<div id="go-board-drill-wrap">
  <div id="go-board-drill"
       style="position:relative;width:100%;border-radius:6px;overflow:hidden;box-shadow:
        0 18px 40px rgba(0,0,0,.32),
        0 6px 16px rgba(0,0,0,.22);">

    <!-- Blitz timer (created by JS if needed) -->
  </div>

  <!-- Bottom controls: keep Next + progress -->
  <div id="drill-ctrls">
    <button id="dbtn-next" class="pbtn pbtn-alt" type="button">Skip</button>
    <div id="drill-progress" style="font-weight:800;opacity:.9;">1 / 1</div>
  </div>
</div>


  </div>
</div>

<!-- Wrong Move (drill) – My Patterns style -->
<div id="drill-wrong" class="drill-notif" role="alert" aria-live="polite">
  <div class="drill-notif-card">
    <div class="drill-notif-title">Wrong</div>
  </div>
</div>


<!-- Drill Cleared (auto-dismiss) – My Patterns style -->
<div id="drill-cleared" class="drill-notif" role="alert" aria-live="polite">
  <div class="drill-notif-card">
    <div class="drill-notif-title">Cleared</div>
  </div>
</div>


<!-- All Done – My Patterns style -->
<div id="drill-done" class="drill-notif" role="dialog" aria-modal="true">
  <div class="drill-notif-card">
    <div id="drill-done-title" class="drill-notif-title">All Drills Complete</div>

    <div id="drill-stats" class="drill-stats">
      <div class="drill-stat-box">
        <div class="drill-stat-label">Solved</div>
        <div id="drill-stat-solved" class="drill-stat-value">0</div>
      </div>
      <div class="drill-stat-box">
        <div class="drill-stat-label">Failed</div>
        <div id="drill-stat-failed" class="drill-stat-value">0</div>
      </div>
    </div>

    <div id="drill-done-msg" class="drill-notif-desc">
      Session finished. You can retry the set or go back to selection.
    </div>

    <div class="drill-notif-actions">
      <button id="drill-done-back" class="drill-notif-btn drill-notif-btn-lg" type="button">
        Back to selection
      </button>
      <button id="drill-done-retry" class="drill-notif-btn drill-notif-btn-lg" type="button">
        Retry set
      </button>
    </div>
  </div>
</div>

<!-- Blitz Countdown – My Patterns style -->
<div id="blitz-countdown" class="drill-notif" aria-live="assertive">
  <div id="blitz-countdown-card" class="drill-notif-card">
    <div id="blitz-countdown-number" class="drill-notif-title">3</div>
  </div>
</div>

<!-- Run Cap overlay – My Patterns style -->
<div id="drill-cap" class="drill-notif" role="dialog" aria-modal="true">
  <div class="drill-notif-card">
    <div class="drill-notif-title">Limit Reached</div>
    <div class="drill-notif-desc">You’ve reached your current drills limit.</div>
    <div class="drill-notif-actions">
      <button id="drill-cap-ok" class="drill-notif-btn drill-notif-btn-lg" type="button">OK</button>
    </div>
  </div>
</div>


<!-- WGo (if not already loaded) -->
<script>
if (!window.WGo) {
  var s = document.createElement('script');
  s.src = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754893285939x971907393576095400/wgo.min.js";
  s.async = true;
  document.head.appendChild(s);
}
</script>



<!-- Sound bridge (respects Settings → Sound) -->
<script>
if (!window.StoneSFX) {
  window.StoneSFX = (() => {
    let pool = [], i = 0, unlocked = false;
    function init(url, voices = 5, volume = 0.35){
      pool = Array.from({ length: voices }, () => {
        const a = new Audio(url); a.preload = 'auto'; a.volume = volume; return a;
      });
      const unlock = () => {
        if (unlocked) return;
        for (const a of pool) { try { a.play().then(()=>a.pause()).catch(()=>{}); a.currentTime = 0; } catch(e){} }
        unlocked = true;
        window.removeEventListener('touchstart', unlock);
        window.removeEventListener('mousedown',  unlock);
      };
      window.addEventListener('touchstart', unlock, { once:true });
      window.addEventListener('mousedown',  unlock, { once:true });
    }
    function play(){ if (!pool.length) return; const a = pool[i++ % pool.length]; try { a.currentTime=0; a.playbackRate=0.97+Math.random()*0.06; a.play(); } catch(e){} }
    return { init, play };
  })();
  StoneSFX.init("https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754926303439x491369894441766600/klick.mp3");
}
(function bridgeSoundSetting(){
  if (window._drillSoundInit) return;
  window._drillSoundInit = true;
  if (typeof StoneSFX.play === 'function' && !('_enabled' in StoneSFX)){
    StoneSFX._enabled = (window.GoPrefs ? !!window.GoPrefs.soundOn : true);
    const _orig = StoneSFX.play.bind(StoneSFX);
    StoneSFX.play = function(){ if (StoneSFX._enabled) _orig(); };
  }
  window.JosekiSound = window.JosekiSound || {
    isEnabled(){ return !!StoneSFX._enabled; },
    setEnabled(v){ StoneSFX._enabled = !!v; }
  };
})();

(function DrillBoardMount(){
  const SGF_URL = "../sgf/library-1.sgf";  // same as drills.html
  const MIN_MOVES = 10;

  /* ===== Plan helpers (match drills list) ===== */
  var Tier = window.Tier || {
    get: function(){
      try {
        return (localStorage.getItem('go_tier') || 'free').toLowerCase();
      } catch(e){
        return 'free';
      }
    }
  };

  function isPro(){
    try{
      if (window.GoLimits && typeof window.GoLimits.get === 'function'){
        var lim = window.GoLimits.get();
        if (lim && lim.drills){
          if (lim.drills.triesPerDay === Number.POSITIVE_INFINITY) return true;
          if (typeof lim.drills.plan === 'string' && lim.drills.plan.toLowerCase() === 'pro') return true;
        }
      }
    }catch(e){}
    var t = Tier && typeof Tier.get === 'function' ? Tier.get() : 'free';
    return (t || 'free').toLowerCase() === 'pro';
  }

 /* ===== Run cap (Start + Retry)
     - Disabled: limits are handled per mode/day on drills.html
  ================================= */
  const RUN_LIMIT_FREE = Infinity;
  // ---- Daily Drills limit: shared with drills.html (per mode) ----
  const FREE_DAILY_LIMIT_COMPLETE = 2;
  const FREE_DAILY_LIMIT_BLITZ    = 2;

  function getDailyLimitForMode(mode){
    if (isPro()) return Infinity;
    return (mode === 'blitz') ? FREE_DAILY_LIMIT_BLITZ : FREE_DAILY_LIMIT_COMPLETE;
  }

  function readDailyDrillBucket(mode){
    const m   = (mode === 'blitz') ? 'blitz' : 'complete';
    const key = 'go:drills_attempts_' + m + '_today_v1';
    try{
      const raw   = localStorage.getItem(key);
      const today = (new Date()).toISOString().slice(0,10); // UTC date YYYY-MM-DD
      let obj     = raw ? JSON.parse(raw) : null;

      // If nothing stored yet or from a previous day, start fresh
      if (!obj || obj.day !== today || typeof obj.count !== 'number'){
        obj = { day: today, count: 0 };
      }
      return { key, state: obj };
    }catch(_){
      // If localStorage is blocked or JSON is bad, fail open
      return { key, state: null };
    }
  }

  function getDrillsUsedToday(mode){
    const bucket = readDailyDrillBucket(mode);
    if (!bucket.state) return 0;
    return bucket.state.count || 0;
  }

  function hasDrillAttemptsLeft(mode){
    if (isPro()) return true;
    const limit = getDailyLimitForMode(mode);
    if (!Number.isFinite(limit)) return true;
    const used  = getDrillsUsedToday(mode);
    return used < limit;
  }

  function recordDrillAttempt(mode){
    if (isPro()) return;
    const limit = getDailyLimitForMode(mode);
    if (!Number.isFinite(limit)) return;

    const bucket = readDailyDrillBucket(mode);
    if (!bucket.state) return;

    bucket.state.count = (bucket.state.count || 0) + 1;
    try{
      localStorage.setItem(bucket.key, JSON.stringify(bucket.state));
    }catch(_){}
  }

  // Board-side helpers: use current mode (Complete vs Blitz)
  function currentModeForDaily(){
    return blitzMode ? 'blitz' : 'complete';
  }

  function dailyAttemptsLeftForCurrentMode(){
    const m     = currentModeForDaily();
    const limit = getDailyLimitForMode(m);
    if (!Number.isFinite(limit)) return Infinity;
    const used  = getDrillsUsedToday(m);
    return Math.max(0, limit - used);
  }

  function hasDailyAttemptsLeftForCurrentMode(){
    return hasDrillAttemptsLeft(currentModeForDaily());
  }

  function recordDailyAttemptForCurrentMode(){
    recordDrillAttempt(currentModeForDaily());
  }

  const RUNS_KEY = 'go:drill_runs_session_count';

  function getRunLimit(){
    // Pro → unlimited, Free → fixed cap
    return isPro() ? Infinity : RUN_LIMIT_FREE;
  }

  function getRuns(){
    try {
      return parseInt(sessionStorage.getItem(RUNS_KEY) || '0', 10) || 0;
    } catch(e){
      return 0;
    }
  }

  function setRuns(n){
    try {
      sessionStorage.setItem(RUNS_KEY, String(Math.max(0, n | 0)));
    } catch(e){}
  }

  function canStart(){
    const limit = getRunLimit();
    if (!Number.isFinite(limit)) return true;    // Pro: always allowed
    return getRuns() < limit;                    // Free: compare vs 2
  }

  function incRuns(){
    const limit = getRunLimit();
    if (!Number.isFinite(limit)) return;         // Pro: don't count runs
    setRuns(getRuns() + 1);
  }

  function runsLeft(){
    const limit = getRunLimit();
    if (!Number.isFinite(limit)) return Infinity;
    return Math.max(0, limit - getRuns());
  }


  // NEW overlay references
  const capM   = document.getElementById('drill-cap');
  const capOK  = document.getElementById('drill-cap-ok');
  function showCapMsg(){
    if (capM){
      capM.style.display = 'flex';
    } else {
      alert('You’ve reached your current drills limit.');
    }
  }

  if (capOK){
    capOK.addEventListener('click', ()=> capM.style.display='none');
    if (capM){
      capM.addEventListener('click', (e)=>{ if (e.target === capM) capM.style.display='none'; });
    }
  }

  // --- SGF utils ---
  function rb(str,i){ let out='',k=i; while(k<str.length){ const ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; } if(ch===']') break; out+=ch; } return {t:out,n:k}; }
  function parseTree(str,i){
    const seq=[]; let node=null; if(str[i]!=='(') return {seq:[],n:i}; i++;
    while(i<str.length){
      const ch=str[i];
      if(ch===';'){ node={}; seq.push(node); i++; }
      else if(/[A-Za-z]/.test(ch)){
        let key=''; while(/[A-Za-z]/.test(str[i]||'')) key+=str[i++]; const vals=[];
        while(str[i]==='['){ const r=rb(str,i+1); vals.push(r.t); i=r.n; }
        if(!node){ node={}; seq.push(node); } node[key]=vals.length>1?vals:vals[0];
      } else if(ch==='('){ const child=parseTree(str,i); i=child.n; if(seq.length){ const p=seq[seq.length-1]; (p.variations||(p.variations=[])).push(child.seq); } }
      else if(ch===')'){ i++; break; } else i++;
    }
    for(let k=0;k<seq.length-1;k++) seq[k].next=seq[k+1];
    return {seq,n:i};
  }
  function parseAllTrees(str){
    const trees=[]; let i=str.indexOf('(');
    if (str.charCodeAt && str.charCodeAt(0)===0xFEFF) str = str.slice(1);
    while(i>=0 && i<str.length){
      const r = parseTree(str,i);
      if (r.seq && r.seq.length) trees.push(r.seq);
      const nxt = str.indexOf('(', r.n);
      if (nxt === -1) break;
      i = nxt;
    }
    return trees;
  }
  function parseSZ(sz){ if(!sz) return 19; if(typeof sz==='string'){ const n=parseInt(sz.split(':')[0],10); return (n>=2&&n<=52)?n:19; } return 19; }
  function xy(s,S){ if(!s||s.length<2) return null; const x=s.charCodeAt(0)-97,y=s.charCodeAt(1)-97; if(x<0||y<0||x>=S||y>=S) return null; return {x,y}; }
  function nodeMove(n,S){ if(!n) return null; if(n.B){ const p=xy(n.B,S); if(p) return {x:p.x,y:p.y,color:'B'}; } if(n.W){ const p=xy(n.W,S); if(p) return {x:p.x,y:p.y,color:'W'}; } return null; }
  function listCoords(prop,S){ const arr=Array.isArray(prop)?prop:(prop?[prop]:[]); const out=[]; for(const v of arr){ const p=xy(v,S); if(p) out.push(p); } return out; }
  function linkify(seq,parent){ for(let i=0;i<seq.length;i++){ const n=seq[i]; n.prev=(i===0?parent:seq[i-1]); n.next=(i<seq.length-1?seq[i+1]:null); if(n.variations) for(const v of n.variations) if(v&&v.length) linkify(v,n); } }
  function enumerateLines(seq,S){
    const lines=[]; let start=seq&&seq[0]; while(start && !nodeMove(start,S) && !start.variations) start=start.next;
    function dfs(node,acc){ if(!node){ lines.push(acc.slice()); return; }
      acc.push(node);
      if(node.variations && node.variations.length){
        for(const v of node.variations){
          let f=v&&v[0]; while(f && !nodeMove(f,S) && !f.variations) f=f.next;
          if(f) dfs(f,acc.slice());
        }
      }
      if(node.next){ let nx=node.next; while(nx && !nodeMove(nx,S) && !nx.variations) nx=nx.next;
        if(nx) dfs(nx,acc); else lines.push(acc.slice()); }
      else lines.push(acc.slice());
    }
    if(start) dfs(start,[]); 
    return lines.map(nodes=>nodes.map(n=>nodeMove(n,S)).filter(Boolean));
  }
  function lineKey(line){
    const size = line.size || 19;
    const seq = (line.moves||[]).map(m => (m.color||'B')[0]+':'+m.x+','+m.y).join('|');
    return `${size}|${seq}`;
  }

  // --- transforms (8; for Blitz we restrict to 4 rotations = corners) ---
  function t_identity(p){ return {x:p.x,y:p.y}; }
  function t_swap(p){ return {x:p.y, y:p.x}; }
  function t_rot90(p,S){  return {x: S-1 - p.y, y: p.x}; }
  function t_rot180(p,S){ return {x: S-1 - p.x, y: S-1 - p.y}; }
  function t_rot270(p,S){ return {x: p.y, y: S-1 - p.x}; }
  function compose(a,b,S){ return function(p){ return a(b(p,S),S); }; }
  function ORIENT_FUNCS(S){
    return [
      p=>t_identity(p),
      p=>t_swap(p),
      p=>t_rot90(p,S),
      p=>compose(t_swap,t_rot90,S)(p),
      p=>t_rot180(p,S),
      p=>compose(t_swap,t_rot180,S)(p),
      p=>t_rot270(p,S),
      p=>compose(t_swap,t_rot270,S)(p)
    ];
  }
  const ROT_IDX_ONLY = [0,2,4,6]; // pure rotations (corners)

  // --- UI elements ---
  const wrap   = document.getElementById('go-board-drill-wrap');
  const mount  = document.getElementById('go-board-drill');
  const btnMenu= document.getElementById('dbtn-menu');
  const btnNext = document.getElementById('dbtn-next');
  const progEl  = document.getElementById('drill-progress');

  const wrongM   = document.getElementById('drill-wrong');
  const clearedM = document.getElementById('drill-cleared');
  const doneM    = document.getElementById('drill-done');
  const doneTitle= document.getElementById('drill-done-title');
  const doneBack = document.getElementById('drill-done-back');
  const doneRetry= document.getElementById('drill-done-retry');
  const statSolvedEl = document.getElementById('drill-stat-solved');
  const statFailedEl = document.getElementById('drill-stat-failed');
  const doneMsgEl    = document.getElementById('drill-done-msg');
  // Blitz countdown elements
  const blitzCdM   = document.getElementById('blitz-countdown');
  const blitzCdNum = document.getElementById('blitz-countdown-number');

  // --- board state ---
  let SIZE = 19, board=null, grid=null;
let lastMove = null; // {x,y,color}
  // Map grid indices -> CSS coordinates (used by zoom)
  function canvasCssScale(){
    const c = mount ? mount.querySelector('canvas') : null;
    if (!c) return 1;
    const cssW = c.clientWidth || c.getBoundingClientRect().width || 0;
    const intW = c.width || 0;
    if (!cssW || !intW) return 1;
    return cssW / intW;
  }

  function getXcss(i){
    if (!board) return 0;
    return board.getX(i) * canvasCssScale();
  }

  function getYcss(j){
    if (!board) return 0;
    return board.getY(j) * canvasCssScale();
  }
function getGridSpacing(){
    var sX = Math.abs(getXcss(1) - getXcss(0));
    var sY = Math.abs(getYcss(1) - getYcss(0));
    return { x: sX, y: sY };
  }
  // === Grid hit-test (prevents border/wood taps from snapping) ===
  const HIT_FACTOR = 0.45; // tighter than 0.5 to ignore outer wood border

  function pickNearestGrid(boardX, boardY){
    const spacing = getGridSpacing();

    let bestI = -1, bestJ = -1;
    let bestDx = 1e9, bestDy = 1e9;

    for (let i = 0; i < SIZE; i++){
      const dx = Math.abs(getXcss(i) - boardX);
      if (dx < bestDx){ bestDx = dx; bestI = i; }
    }
    for (let j = 0; j < SIZE; j++){
      const dy = Math.abs(getYcss(j) - boardY);
      if (dy < bestDy){ bestDy = dy; bestJ = j; }
    }

    const ok =
      bestI >= 0 && bestJ >= 0 &&
      bestDx <= spacing.x * HIT_FACTOR &&
      bestDy <= spacing.y * HIT_FACTOR;

    return { i: ok ? bestI : null, j: ok ? bestJ : null, ok, bestDx, bestDy };
  }

  // session control
  let solvedCount = 0;
  let failedCount = 0;
  let locked = false;
  let wrongTimer = null;
  let clearedTimer = null;

  // slots / planning
  let PER = 3;
  let slots = [];                 // [{ key, base }]
  let lineToSlotIdxs = {};        // key -> [slotIdx,...]
  let runPlan = {};               // key -> Map(slotIdx -> {orientIdx, swap, startIndex})
  let index  = 0;                 // current slot
  let remain = [];                // remaining transformed moves
  let currentTransformed = null;
let currentStartIndex = 0;
let blitzDirectionalIdx = null;

  // BLITZ flags + timer
  let blitzMode = false;
  let timerEl = null;
  let timerMs = 0;
  let timerId = null;
  let blitzCornerPlannedMoves = 0;
  let blitzInitialBudgetGranted = false; // NEW: only grant 1500ms-per-move once
  let timeUp = false;


function ensureTimerEl(){
  if (timerEl || !blitzMode) return;

  timerEl = document.createElement('div');
  timerEl.id = 'blitz-timer';
  timerEl.className = 'blitz-chip';
  timerEl.textContent = '0.0s';


  const topbar = document.getElementById('drill-topbar');

  if (topbar){
    topbar.appendChild(timerEl);
  } else {
    // fallback (shouldn't happen, but keeps it robust)
    mount.appendChild(timerEl);
  }
}

  function fmtMs(ms){
    if (ms < 0) ms = 0;
    const s = ms/1000;
    const m = Math.floor(s/60);
    const r = s - m*60;
    if (m>0) return `${m}:${r.toFixed(1).padStart(4,'0')}`;
    return `${r.toFixed(1)}s`;
  }
  function startTimer(){
    if (!blitzMode) return;
    ensureTimerEl();
    stopTimer();
    timeUp = false;

    // NEW safety: don't start a zero-length timer
    if (timerMs <= 0){
      timerMs = 0;
      if (timerEl) timerEl.textContent = fmtMs(timerMs);
      return;
    }

    timerId = setInterval(()=>{
      timerMs -= 100;
      if (timerEl) timerEl.textContent = fmtMs(timerMs);
      if (timerMs <= 0){
        stopTimer();
        timeUp = true;
        showDone('Time’s up!');
      }
    }, 100);
  }

  function stopTimer(){ if (timerId){ clearInterval(timerId); timerId=null; } }
  /* =========================
     Blitz countdown (3-2-1-Go)
     ========================= */
  const BLITZ_COUNTDOWN_SECONDS = 3;

  function runBlitzCountdown(){
    return new Promise(resolve => {
      if (!blitzCdM || !blitzCdNum){
        resolve();
        return;
      }

      let n = BLITZ_COUNTDOWN_SECONDS;
      blitzCdNum.textContent = String(n);
      blitzCdM.style.display = 'flex';

      const stepMs = 650;

      function tick(){
        n -= 1;

        if (n <= 0){
          blitzCdNum.textContent = 'Go!';
          setTimeout(() => {
            blitzCdM.style.display = 'none';
            resolve();
          }, 180);
          return;
        }

        blitzCdNum.textContent = String(n);
        setTimeout(tick, stepMs);
      }

      setTimeout(tick, stepMs);
    });
  }

  // board helpers
function initBoard(){
  if (!window.WGo) return setTimeout(initBoard, 40);
  if (board) return;

  // Ensure mount is a predictable zoom container
  mount.style.position = 'relative';
  mount.style.overflow = 'hidden';

  // Create a stable host for the WGo canvases + wood skin
  if (!mount.__boardHost){
    const host = document.createElement('div');
    host.id = 'go-drill-host';

    // Let JS own sizing; keep host anchored to top-left
    host.style.position = 'absolute';
    host.style.left = '0';
    host.style.top  = '0';

    // Visual wood layer (optional but matches your previous intent)
    host.style.backgroundImage =
      "url('https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1755870506985x437178801728222500/wood.jpg')";
    host.style.backgroundSize = 'cover';
    host.style.backgroundPosition = 'center';
    host.style.backgroundRepeat = 'no-repeat';

    // Match core zoom layer behavior
    host.style.transformOrigin = '0 0';
    host.style.willChange = 'transform';

    mount.appendChild(host);
    mount.__boardHost = host;
  }

  const host = mount.__boardHost;

  // Mount WGo into the host (not into mount directly)
  board = new WGo.Board(host, { size: SIZE });

  // This is what gets translated+scaled
  zoomLayer = host;

  // Initial sizing
  fitBoard();

  // Click handler – respect zoom touch handler's suppression flag
  board.addEventListener('click', function(x, y){
    if (suppressNextBoardClick){
      suppressNextBoardClick = false;
      return;
    }
    onBoardClick(x, y);
  });
}


function resetGrid(){
  grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null));
  lastMove = null;
}

  function addStone(x,y,color){ grid[y][x]=color; }

  function inside(x,y){ return x>=0 && y>=0 && x<SIZE && y<SIZE; }
  function neigh4(x,y){ return [{x:x+1,y:y},{x:x-1,y:y},{x:x,y:y+1},{x:x,y:y-1}].filter(p=>inside(p.x,p.y)); }
  function groupAndLiberties(x,y){
    const color = grid[y][x]; if (!color) return { stones:[], libs:0 };
    const seen = new Set(), libset = new Set(), stones=[];
    const key=(a,b)=>a+','+b; const stack=[{x,y}]; seen.add(key(x,y));
    while(stack.length){
      const p = stack.pop(); stones.push(p);
      for (const n of neigh4(p.x,p.y)){
        const v = grid[n.y][n.x];
        if (v === null) libset.add(key(n.x,n.y));
        else if (v === color){
          const k = key(n.x,n.y); if (!seen.has(k)){ seen.add(k); stack.push(n); }
        }
      }
    }
    return { stones, libs: libset.size };
  }
  function removeStones(stones){ for (const s of stones){ grid[s.y][s.x] = null; } }
  function resolveCapturesAfterPlacing(x,y,color){
    const opp = (color==='B'?'W':'B'), seenOpp = new Set();
    for (const n of neigh4(x,y)){
      if (grid[n.y][n.x] !== opp) continue;
      const k = n.x+','+n.y; if (seenOpp.has(k)) continue;
      const g = groupAndLiberties(n.x,n.y);
      g.stones.forEach(s=>seenOpp.add(s.x+','+s.y));
      if (g.libs === 0) removeStones(g.stones);
    }
    if (grid[y][x] === color){
      const gSelf = groupAndLiberties(x,y);
      if (gSelf.libs === 0) removeStones(gSelf.stones);
    }
  }
function playMove(x,y,color, silent=false){
  addStone(x,y,color);
  resolveCapturesAfterPlacing(x,y,color);

  lastMove = { x, y, color };

  if (!silent && window.StoneSFX) StoneSFX.play();
  redraw();
}


function redraw(){
  if (!board) return;
  board.removeAllObjects();

  for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++){
    const v=grid[y][x];
    if (v==='B') board.addObject({x,y,c:WGo.B});
    else if (v==='W') board.addObject({x,y,c:WGo.W});
  }

  // Show last move marker if enabled
  try{
    if (GoPrefs && GoPrefs.highlightLast && lastMove){
      const v = grid[lastMove.y] && grid[lastMove.y][lastMove.x];
      if (v){ // only mark if the stone still exists
        board.addObject({ x:lastMove.x, y:lastMove.y, type:'CR' });
      }
    }
  }catch(_){}

  if (blitzMode) drawBlitzMarkers();
}



function cornerEdgesForFirstMove(m1, S){
  const dL = m1.x;
  const dR = (S - 1) - m1.x;
  const dT = m1.y;
  const dB = (S - 1) - m1.y;

  return {
    edgeX: (dL <= dR) ? 'left'  : 'right',
    edgeY: (dT <= dB) ? 'top'   : 'bottom'
  };
}

function cornerCoords(m, edges, S){
  const cx = (edges.edgeX === 'left') ? (m.x + 1) : (S - m.x);
  const cy = (edges.edgeY === 'top')  ? (m.y + 1) : (S - m.y);
  return { cx, cy };
}

function findFirstDirectionalIndex(moves, S){
  if (!moves || moves.length < 2) return null;

  const edges = cornerEdgesForFirstMove(moves[0], S);

  for (let i = 1; i < moves.length; i++){
    const { cx, cy } = cornerCoords(moves[i], edges, S);
    if (cx !== cy) return i;
  }
  return null;
}

function drawBlitzMarkers(){
  if (!blitzMode) return;
  if (!board) return;
  if (!currentTransformed) return;
  if (!remain || !remain.length) return;

  const moves = currentTransformed.moves || [];
  const total = moves.length;
  if (!total) return;

  const next = remain[0];
  if (!next) return;
  if (!inside(next.x, next.y)) return;

  const startIdx = currentStartIndex || 0;

  // How many moves we have already played inside this drill sequence
  const playedCount = Math.max(0, total - startIdx - remain.length);

  // Absolute index of the next expected move in the full line
  const nextAbsIdx = startIdx + playedCount;

  const dirIdx =
    (typeof blitzDirectionalIdx === 'number')
      ? blitzDirectionalIdx
      : null;

  const shouldLabel =
    (nextAbsIdx === 0) ||
    (dirIdx != null && nextAbsIdx === dirIdx);

  if (!shouldLabel) return;

  // Only draw if the point is empty
  if (grid && grid[next.y] && grid[next.y][next.x] === null){
    board.addObject({ x: next.x, y: next.y, type: 'LB', text: 'A' });
  }
}


  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function range(a,b){ const out=[]; for(let i=a;i<=b;i++) out.push(i); return out; }

  function mixSlotsFairly(slotList){
    const buckets = new Map();
    for (const s of slotList){
      if (!buckets.has(s.key)) buckets.set(s.key, []);
      buckets.get(s.key).push(s);
    }
    for (const arr of buckets.values()) shuffle(arr);
    const keys = Array.from(buckets.keys());
    let lastKey = null;
    const out = [];
    function pickKey(){
      const candidates = keys.filter(k => (buckets.get(k)||[]).length && k !== lastKey);
      const pool = candidates.length ? candidates : keys.filter(k => (buckets.get(k)||[]).length);
      if (!pool.length) return null;
      return pool[Math.floor(Math.random()*pool.length)];
    }
    while (out.length < slotList.length){
      const k = pickKey();
      if (k == null) break;
      out.push(buckets.get(k).pop());
      lastKey = k;
    }
    return out;
  }

  function makeTransformed(line, orientIdx, swap){
    const S = line.size || 19, ORS = ORIENT_FUNCS(S), o = ORS[orientIdx % ORS.length];
    const tf = p => { const t=o({x:p.x,y:p.y}, S); return {x:t.x,y:t.y}; };
    const AB = (line.rootAB||[]).map(tf), AW = (line.rootAW||[]).map(tf);
    const mv = (line.moves||[]).map(m=>{ const t=tf(m); const c = swap ? (m.color==='B'?'W':'B') : m.color; return { x:t.x, y:t.y, color:c }; });
    return { size:S, rootAB: swap ? AW : AB, rootAW: swap ? AB : AW, moves: mv };
  }

  function buildRunPlanForLine(key, line, slotIdxs){
    const L = line.moves.length, k = slotIdxs.length;
    if (blitzMode){
      const orientIdxs = shuffle(ROT_IDX_ONLY.slice()).slice(0, k || 1);
      let swaps = Array(k).fill(false);
      let nSwap = Math.round(k * 0.5);
      for (let i=0;i<nSwap;i++) swaps[i]=true;
      swaps = shuffle(swaps);
      const plan = new Map(), shuffledSlots = shuffle(slotIdxs.slice());
      for (let i=0;i<k;i++){
        plan.set(shuffledSlots[i], { orientIdx: orientIdxs[i % orientIdxs.length], startIndex: 0, swap: swaps[i] });
      }
      return plan;
    }

    const startsPool = (function allowedStartRange(L){ const min = Math.max(4,0); const max = Math.max(min, L-2); return range(min,max); })(L);
    const orientIdxs = shuffle(range(0,7)).slice(0, slotIdxs.length || 1);
    const chosenStarts = shuffle(startsPool.slice());
    let swaps = Array(slotIdxs.length).fill(false);
    let nSwap = Math.round(slotIdxs.length * 0.5);
    for (let i=0;i<nSwap;i++) swaps[i]=true;
    swaps = shuffle(swaps);

    const plan = new Map(), shuffledSlots = shuffle(slotIdxs.slice());
    for (let i=0;i<slotIdxs.length;i++){
      plan.set(shuffledSlots[i], {
        orientIdx: orientIdxs[i % orientIdxs.length],
        startIndex: chosenStarts[i % chosenStarts.length],
        swap: swaps[i]
      });
    }
    return plan;
  }
  function ensureRunPlanFor(key,line){
    if (!runPlan[key]){
      const idxs = lineToSlotIdxs[key] || [];
      runPlan[key] = buildRunPlanForLine(key, line, idxs);
    }
  }
  function newRunPlan(){
    runPlan = {};
    const seen = new Set();
    for (const s of slots){
      if (seen.has(s.key)) continue;
      seen.add(s.key);
      ensureRunPlanFor(s.key, s.base);
    }
  }

  function setProgress(){
    if (progEl) progEl.textContent = (slots.length ? (index+1) : 0) + ' / ' + (slots.length || 0);
  }

  function resetStats(){
    solvedCount = 0;
    failedCount = 0;
    if (statSolvedEl) statSolvedEl.textContent = '0';
    if (statFailedEl) statFailedEl.textContent = '0';
  }

  function clearTimers(){
    if (wrongTimer){ clearTimeout(wrongTimer); wrongTimer=null; }
    if (clearedTimer){ clearTimeout(clearedTimer); clearedTimer=null; }
  }

  let blitzCornerState = null;
  // ===== Practice-style Zoom & Pan for Drills =====

  // ===== Shared preferences (Fix: Load from storage so zoom setting is respected) =====
  var STORAGE_KEY = 'go_prefs';
  var GoPrefs = (window.GoPrefs = window.GoPrefs || {});
  try {
    var saved = localStorage.getItem(STORAGE_KEY);
    if (saved) Object.assign(GoPrefs, JSON.parse(saved) || {});
  } catch (e) {}

  // Defaults
  if (typeof GoPrefs.josekiZoom === 'undefined') GoPrefs.josekiZoom = true;
  if (typeof GoPrefs.soundOn === 'undefined') GoPrefs.soundOn = true;
  if (typeof GoPrefs.highlightLast === 'undefined') GoPrefs.highlightLast = true;
  if (typeof GoPrefs.disableAutoZoomOut === 'undefined') GoPrefs.disableAutoZoomOut = false;

  // Now set the local variable based on the loaded prefs
  let zoomEnabled = !!GoPrefs.josekiZoom;

  // Zoom / pan state
  let scale = 1;
  const minScale = 1;
  const maxScale = 2.6;
  let baseW = 0;
  let offsetX = 0;
  let offsetY = 0;

  let isFullscreen = false;
let isZoomAnimating = false;
  let zoomLayer = null;

  let overlay = null;
  let stage = null;
  let zoomExitBtn = null;
  let returnAnchor = null;
  let prevOverflow = "";
  // ===== NEW: Practice-style UI re-homing for fullscreen =====
  let zoomTopUI = null;
  let zoomBottomUI = null;

  const zoomUIStore = {
    topbar: { parent:null, next:null },
    ctrls:  { parent:null, next:null }
  };

  function ensureZoomUIContainers(){
    if (!zoomTopUI){
      zoomTopUI = document.getElementById('go-zoom-top-drill');
      if (!zoomTopUI){
        zoomTopUI = document.createElement('div');
        zoomTopUI.id = 'go-zoom-top-drill';
        document.body.appendChild(zoomTopUI);
      }
    }
    if (!zoomBottomUI){
      zoomBottomUI = document.getElementById('go-zoom-ui-drill');
      if (!zoomBottomUI){
        zoomBottomUI = document.createElement('div');
        zoomBottomUI.id = 'go-zoom-ui-drill';
        document.body.appendChild(zoomBottomUI);
      }
    }
  }

  function stashAndMove(el, slot, container){
    if (!el || !container) return;
    if (!zoomUIStore[slot].parent){
      zoomUIStore[slot].parent = el.parentNode;
      zoomUIStore[slot].next   = el.nextSibling;
    }
    container.appendChild(el);
  }

  function restoreStashed(el, slot){
    if (!el) return;
    const store = zoomUIStore[slot];
    const p = store.parent;
    const n = store.next;
    if (p){
      if (n && n.parentNode === p) p.insertBefore(el, n);
      else p.appendChild(el);
    }
    store.parent = null;
    store.next   = null;
  }

  function moveZoomUIIn(){
    ensureZoomUIContainers();

    // Ensure timer exists before moving topbar if we're in blitz
    if (blitzMode) ensureTimerEl();

    const tb = document.getElementById('drill-topbar');
    const bc = document.getElementById('drill-ctrls');

    stashAndMove(tb, 'topbar', zoomTopUI);
    stashAndMove(bc, 'ctrls',  zoomBottomUI);

    if (zoomTopUI)    zoomTopUI.style.display = 'flex';
    if (zoomBottomUI) zoomBottomUI.style.display = 'flex';
  }

  function restoreZoomUIOut(){
    const tb = document.getElementById('drill-topbar');
    const bc = document.getElementById('drill-ctrls');

    restoreStashed(tb, 'topbar');
    restoreStashed(bc, 'ctrls');

    if (zoomTopUI)    zoomTopUI.style.display = 'none';
    if (zoomBottomUI) zoomBottomUI.style.display = 'none';
  }

  // Kinetic pan / fling
  let flingId = 0;
  let isFlinging = false;
  let flingVX = 0;
  let flingVY = 0;
  let flingLastTime = 0;

  // Pointer tracking
  let isPanning = false;
  let panStart = null;
  let activePointerId = null;
  let panSamplePrev = null;
  let panSampleCurr = null;
  let tapStart = null;
  let suppressNextBoardClick = false;
  const TAP_SLOP2 = 64; // squared px (~8px movement)

  function cancelFling(){
    isFlinging = false;
    if (flingId){
      cancelAnimationFrame(flingId);
      flingId = 0;
    }
  }

function viewportSize(){
  if (isFullscreen){
    const vw = window.innerWidth  || document.documentElement.clientWidth  || 800;
    const vh = window.innerHeight || document.documentElement.clientHeight || 800;
    return { vw, vh };
  }

  const rect = mount.getBoundingClientRect();
  const wrapRect = wrap ? wrap.getBoundingClientRect() : rect;
  const wrapW =
    (wrapRect && wrapRect.width) ||
    (wrap && wrap.clientWidth) ||
    rect.width ||
    400;

  // board area is square
  return { vw: wrapW, vh: wrapW };
}


function clampPan(){
  if (!board) return;

  const { vw, vh } = viewportSize();
  const bw = Math.round(baseW * scale);
  const bleedX = Math.ceil(vw * 0.5);
  const bleedY = Math.ceil(vh * 0.5);

  const minOX = -bleedX;
  const maxOX = Math.max(0, bw - vw) + bleedX;
  const minOY = -bleedY;
  const maxOY = Math.max(0, bw - vh) + bleedY;

  if (offsetX < minOX) offsetX = minOX;
  else if (offsetX > maxOX) offsetX = maxOX;

  if (offsetY < minOY) offsetY = minOY;
  else if (offsetY > maxOY) offsetY = maxOY;
}

  function applyPanAndSize(redrawAfter){
    if (!board || !mount) return;

    const { vw, vh } = viewportSize();
    let targetW;

    if (isFullscreen){
      targetW = Math.floor(Math.min(vw, vh));
      if (targetW % 2) targetW--;
      baseW = targetW;
      mount.style.width  = '100vw';
      mount.style.height = '100vh';
    } else {
  targetW = Math.floor(vw);
  if (targetW % 2) targetW--;
  baseW = targetW;

  /* core-style: mount is an explicit square */
  mount.style.width  = targetW + 'px';
  mount.style.height = targetW + 'px';
}


    if (targetW <= 0) return;

    if (board._lastW !== targetW){
      board.setWidth(targetW);
      if (zoomLayer){
        zoomLayer.style.width  = targetW + 'px';
        zoomLayer.style.height = targetW + 'px';
      }
      board._lastW = targetW;
    }

    clampPan();

    if (zoomLayer){
      zoomLayer.style.transform =
        'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';
    }

    if (redrawAfter) redraw();
  }

  function resetViewLocal(){
    cancelFling();
    scale = 1;
    offsetX = 0;
    offsetY = 0;
    applyPanAndSize(true);
  }

// Hard reset for outcome/state transitions.
// Ignores disableAutoZoomOut and does not depend on zoomEnabled.
function forceZoomOutForOutcome(){
  try{
    if (isFullscreen){
      exitFullscreen();
      return;
    }
    if (scale > 1.01){
      resetViewLocal();
    }
  }catch(_){}
}


  function ensureOverlay(){
    if (overlay) return;

    overlay = document.getElementById('go-zoom-overlay-drill');
    if (!overlay){
      overlay = document.createElement('div');
      overlay.id = 'go-zoom-overlay-drill';
      overlay.innerHTML =
        '<div id="go-zoom-stage-drill"></div>' +
        '<div id="go-zoom-exit-drill" aria-label="Zoom out"></div>';
      document.body.appendChild(overlay);
    }

    stage       = overlay.querySelector('#go-zoom-stage-drill');
    zoomExitBtn = overlay.querySelector('#go-zoom-exit-drill');
// NEW safety: ensure hidden state never captures taps
if (overlay) overlay.style.pointerEvents = 'none';
if (zoomExitBtn) zoomExitBtn.style.pointerEvents = 'none';

if (zoomExitBtn && !zoomExitBtn._bound){
      zoomExitBtn._bound = true;
      zoomExitBtn.addEventListener('click', function(e){
        e.stopPropagation();
        e.preventDefault();
        
        // BLOCKER: Ignore clicks while zooming
        if (isZoomAnimating) return; 

        exitFullscreen();
      });
    }
  }

function animateTo(targetScale, pxBoard, pyBoard, sxTarget, syTarget){
  // Turn flag ON
  isZoomAnimating = true;

  targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
  cancelFling();

  const s0  = scale;
  const ox0 = offsetX;
  const oy0 = offsetY;
  const t0  = performance.now();
  const dur = 260;

  // match core: keep chosen board point under target screen point
  const targetOX = pxBoard * targetScale - sxTarget;
  const targetOY = pyBoard * targetScale - syTarget;

  function step(now){
    let t = (now - t0) / dur;
    if (t > 1) t = 1;
    const ease = 1 - Math.pow(1 - t, 3);

    scale   = s0  + (targetScale - s0) * ease;
    offsetX = ox0 + (targetOX - ox0) * ease;
    offsetY = oy0 + (targetOY - oy0) * ease;

    applyPanAndSize(false);

if (t < 1){
      requestAnimationFrame(step);
    } else {
      applyPanAndSize(true);
      // Turn flag OFF
      isZoomAnimating = false;
    }
  }

  requestAnimationFrame(step);
}

function centerZoomAtGrid(i, j, factor, tapClientX, tapClientY){
  const targetScale = Math.max(minScale, Math.min(maxScale, scale * factor));

  // Board-space coordinates of the grid point (independent of zoom)
  const pxBoard = getXcss(i);
  const pyBoard = getYcss(j);

  const rect = mount.getBoundingClientRect();
  let sxTarget = rect.width  / 2;
  let syTarget = rect.height / 2;

  // If we know the tap position, keep that spot under the finger
  if (typeof tapClientX === 'number' && typeof tapClientY === 'number'){
    sxTarget = tapClientX - rect.left;
    syTarget = tapClientY - rect.top;
  }

  animateTo(targetScale, pxBoard, pyBoard, sxTarget, syTarget);
}


function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
  if (isFullscreen) return;
  if (!zoomLayer) zoomLayer = mount.__woodLayer || mount;

  ensureOverlay();
  prevOverflow = document.documentElement.style.overflow || "";
  document.documentElement.style.overflow = 'hidden';

  returnAnchor = document.createElement('div');
  returnAnchor.style.display = 'none';
  mount.parentNode.insertBefore(returnAnchor, mount);

  stage.appendChild(mount);

   overlay.style.display = 'flex';

  // IMPORTANT: do NOT show/enable the exit box in the same tap frame
  if (zoomExitBtn){
    zoomExitBtn.style.display = 'none';
    zoomExitBtn.style.pointerEvents = 'none';
  }

  isFullscreen = true;
  mount.classList.add('is-fullscreen');

  document.body.classList.add('drill-zoom-mode');

  // Keep overlay non-blocking until we’re fully in zoom mode
  if (overlay) overlay.style.pointerEvents = 'auto';

  // Reset baseline sizing/state
  resetViewLocal();
  moveZoomUIIn();

  // Enable the exit box only on the next frame
  requestAnimationFrame(function(){
    if (!isFullscreen) return;
    if (zoomExitBtn){
      zoomExitBtn.style.display = 'block';
      zoomExitBtn.style.pointerEvents = 'auto';
    }
  });

  // Your existing zoom-in animation frame
  requestAnimationFrame(function(){
    const initialFactor = 2.0;

    const px_curr = getXcss(i);
    const py_curr = getYcss(j);

    const rect = mount.getBoundingClientRect();
    let sx = rect.width  / 2;
    let sy = rect.height / 2;

    if (typeof tapClientX === 'number' && typeof tapClientY === 'number'){
      sx = tapClientX - rect.left;
      sy = tapClientY - rect.top;
    }

    scale = 1;
    offsetX = px_curr * 1.0 - sx;
    offsetY = py_curr * 1.0 - sy;

    applyPanAndSize(false);

    animateTo(initialFactor, px_curr, py_curr, sx, sy);
  });
}


  function exitFullscreen(){
    if (!isFullscreen) return;
    cancelFling();
mount.classList.remove('is-fullscreen');
    restoreZoomUIOut();
  document.body.classList.remove('drill-zoom-mode');
// NEW safety: explicitly disable hit-testing outside zoom mode
if (overlay) overlay.style.pointerEvents = 'none';
if (zoomExitBtn) zoomExitBtn.style.pointerEvents = 'none';

    isFullscreen = false;

    if (overlay) overlay.style.display = 'none';

    if (zoomExitBtn){
      zoomExitBtn.style.display = 'none';
      zoomExitBtn.style.pointerEvents = 'none';
    }


    if (returnAnchor && returnAnchor.parentNode){
      returnAnchor.parentNode.insertBefore(mount, returnAnchor);
      returnAnchor.parentNode.removeChild(returnAnchor);
      returnAnchor = null;
    }

document.documentElement.style.overflow = prevOverflow;

// important: remove fullscreen inline sizing first
mount.style.width = '';
mount.style.height = '';

scale = 1;
offsetX = 0;
offsetY = 0;

applyPanAndSize(true);

  }

  function beginPan(e){
    isPanning = false;
    panStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY };
    activePointerId = e.pointerId;
    panSamplePrev = null;
    panSampleCurr = null;
    try { mount.setPointerCapture(e.pointerId); } catch(_){}
  }

  function updatePan(e){
    if (!isFullscreen || scale <= 1 || !panStart) return;

    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    const dist2 = dx*dx + dy*dy;

    if (!isPanning && dist2 > TAP_SLOP2){
      isPanning = true;
      suppressNextBoardClick = true;
    }
    if (!isPanning) return;

    offsetX = panStart.ox - dx;
    offsetY = panStart.oy - dy;

    applyPanAndSize(false);

    const now = performance.now();
    panSamplePrev = panSampleCurr;
    panSampleCurr = { ox: offsetX, oy: offsetY, t: now };

    e.preventDefault();
  }

  function endPan(e){
    const wasPanning = isPanning;

    if (activePointerId != null){
      try { mount.releasePointerCapture(activePointerId); } catch(_){}
    }
    activePointerId = null;
    panStart = null;
    isPanning = false;

    if (!wasPanning || !isFullscreen || scale <= 1) return;
    if (!panSamplePrev || !panSampleCurr) return;

    let dt = panSampleCurr.t - panSamplePrev.t;
    if (dt <= 0 || dt > 120) return;

    const vx = (panSampleCurr.ox - panSamplePrev.ox) / dt;
    const vy = (panSampleCurr.oy - panSamplePrev.oy) / dt;

    startFling(vx, vy);
  }

  function startFling(vx, vy){
    if (!isFullscreen || scale <= 1) return;

    const MAX_SPEED = 0.50;
    let speed = Math.hypot(vx, vy);
    if (speed > MAX_SPEED){
      const s = MAX_SPEED / speed;
      vx *= s;
      vy *= s;
      speed = MAX_SPEED;
    }
    if (speed < 0.04) return;

    cancelFling();
    isFlinging = true;
    flingVX = vx;
    flingVY = vy;
    flingLastTime = performance.now();

    function step(now){
      if (!isFlinging) return;

      let dt = now - flingLastTime;
      if (dt <= 0){
        flingId = requestAnimationFrame(step);
        return;
      }
      if (dt > 50) dt = 50;
      flingLastTime = now;

      offsetX += flingVX * dt;
      offsetY += flingVY * dt;

      const friction = 0.0010;
      let speed = Math.hypot(flingVX, flingVY);
      const decel = friction * dt;

      if (speed <= 0.01 || decel >= speed){
        cancelFling();
        applyPanAndSize(true);
        return;
      }

      const newSpeed = speed - decel;
      const s = newSpeed / speed;
      flingVX *= s;
      flingVY *= s;

      applyPanAndSize(false);
      flingId = requestAnimationFrame(step);
    }

    flingId = requestAnimationFrame(step);
  }

  function getBoardBounds(){
    const firstX = getXcss(0);
    const lastX  = getXcss(SIZE - 1);
    const firstY = getYcss(0);
    const lastY  = getYcss(SIZE - 1);

const spacingX = SIZE > 1 ? Math.abs(getXcss(1) - firstX) : 0;
const spacingY = SIZE > 1 ? Math.abs(getYcss(1) - firstY) : 0;

    const halfX = (spacingX || spacingY || 16) * 0.5;
    const halfY = (spacingY || spacingX || 16) * 0.5;

    return {
      minX: firstX - halfX,
      maxX: lastX  + halfX,
      minY: firstY - halfY,
      maxY: lastY  + halfY
    };
  }

  // Tap/drag handling on the drills board mount (touch only)
  mount.addEventListener('pointerdown', function(e){
    if (!zoomEnabled) return;
    if (e.pointerType && e.pointerType !== 'touch') return;
    if (isZoomAnimating){
      suppressNextBoardClick = true;
      e.preventDefault();
      return;
    }

    cancelFling();
    e.preventDefault();

const rect = mount.getBoundingClientRect();
const sx = e.clientX - rect.left;
const sy = e.clientY - rect.top;

// match core math (offset is treated in screen-space)
const boardX = (sx + offsetX) / scale;
const boardY = (sy + offsetY) / scale;



      const hit = pickNearestGrid(boardX, boardY);
    const gridI = hit.i;
    const gridJ = hit.j;


    tapStart = {
      x: e.clientX,
      y: e.clientY,
      t: performance.now(),
      gridI,
      gridJ
    };

    beginPan(e);
  }, { passive:false });

// Use capture so we intercept before WGo's own click handler
  mount.addEventListener('pointerup', function(e){
    // --- CASE A: Zoom Disabled (Match Core Board behavior) ---
    if (!zoomEnabled) {
      if (e.pointerType && e.pointerType !== 'touch') return; // Let mouse use WGo default

      const r = mount.getBoundingClientRect();
      const bx = e.clientX - r.left;
      const by = e.clientY - r.top;

      let bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
      for (let i = 0; i < SIZE; i++){
        const dx = Math.abs(getXcss(i) - bx);
        if (dx < bestDx){ bestDx = dx; bestI = i; }
      }
      for (let j = 0; j < SIZE; j++){
        const dy = Math.abs(getYcss(j) - by);
        if (dy < bestDy){ bestDy = dy; bestJ = j; }
      }

      // Threshold Check (Ignore clicks in the gutter/border)
      const spacing = getGridSpacing();
      if (bestDx > spacing.x * 0.5 || bestDy > spacing.y * 0.5) {
        return; 
      }

      e.preventDefault();
      // Use the Drills board move handler
      onBoardClick(bestI, bestJ);
      return;
    }

    // --- CASE B: Zoom Enabled ---
    if (!tapStart){
      endPan(e);
      return;
    }
    if (isZoomAnimating){
      e.preventDefault();
      e.stopPropagation();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      suppressNextBoardClick = true;
      tapStart = null;
      endPan(e);
      return;
    }

    if (e.pointerType && e.pointerType !== 'touch'){
      endPan(e);
      tapStart = null;
      return;
    }

    const dx = e.clientX - tapStart.x;
    const dy = e.clientY - tapStart.y;
    const dist2 = dx*dx + dy*dy;

    const gi = tapStart.gridI;
    const gj = tapStart.gridJ;
    const tapClientX = tapStart.x;
    const tapClientY = tapStart.y;

    tapStart = null;
    const wasPanning = isPanning;
    endPan(e);

    if (wasPanning) return;

    if (dist2 <= TAP_SLOP2){
const baseView = (!isFullscreen && scale <= 1.05);


       if (baseView){
        let ti = gi;
        let tj = gj;

        // If we didn’t get a valid grid from pointerdown, try once more with threshold
        if (ti == null || tj == null){
          const rect = mount.getBoundingClientRect();
          const sx = tapClientX - rect.left;
          const sy = tapClientY - rect.top;

          const bx = (sx + offsetX) / scale;
          const by = (sy + offsetY) / scale;

          const hit = pickNearestGrid(bx, by);
          ti = hit.i;
          tj = hit.j;
        }

        // If still no valid grid: this was the outer wood/border → swallow tap
        if (ti == null || tj == null){
          e.preventDefault();
          e.stopPropagation();
          if (e.stopImmediatePropagation) e.stopImmediatePropagation();
          suppressNextBoardClick = true;
          return;
        }

        e.preventDefault();
        e.stopPropagation();
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();

        suppressNextBoardClick = true;
        enterFullscreenAtGrid(ti, tj, tapClientX, tapClientY);
        return;
      }


      e.preventDefault();
      e.stopPropagation();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();

      suppressNextBoardClick = true;
      onBoardClick(gi, gj);

      // Auto-zoom out check (Match Core Board behavior)
      if (GoPrefs && !GoPrefs.disableAutoZoomOut && scale > 1) {
         setTimeout(function(){
            if(isFullscreen) exitFullscreen();
            else resetViewLocal();
         }, 10);
      }
    }
  }, { passive:false, capture:true });

  mount.addEventListener('pointermove', function(e){
    if (!zoomEnabled) return;
    if (e.pointerType && e.pointerType !== 'touch') return;
    updatePan(e);
  }, { passive:false });

  mount.addEventListener('pointercancel', function(e){
    if (e.pointerType && e.pointerType !== 'touch') return;
    endPan(e);
  }, { passive:true });

  // Zoom-aware sizing on resize
  function fitBoard(){
    applyPanAndSize(true);
  }
  window.addEventListener('resize', function(){
    setTimeout(fitBoard, 10);
  });

  // Optional: let Settings toggle zoom
  window.DrillZoom = {
    isEnabled(){ return zoomEnabled; },
    setEnabled(v){
      zoomEnabled = !!v;
      if (!zoomEnabled){
        if (isFullscreen) exitFullscreen();
        else resetViewLocal();
      }
    },
    resetView(){
      if (isFullscreen) exitFullscreen();
      else resetViewLocal();
    },
    isFullscreen(){
      return isFullscreen;
    }
  };

window.addEventListener('go:prefs-changed', function(e){
  const d = e.detail || {};
  if (!d || typeof d.key === 'undefined') return;

  if (d.key === 'josekiZoom'){
    zoomEnabled = !!d.value;
    if (!zoomEnabled){
      if (isFullscreen) exitFullscreen();
      else resetViewLocal();
    }
    return;
  }

  if (d.key === 'highlightLast'){
    GoPrefs.highlightLast = !!d.value;
    redraw();
    return;
  }
});


  function prepareCorner(tline, startIndex){
    resetGrid();
    (tline.rootAB||[]).forEach(p=>addStone(p.x,p.y,'B'));
    (tline.rootAW||[]).forEach(p=>addStone(p.x,p.y,'W'));
    for (let s=0;s<startIndex;s++){ const m = tline.moves[s]; playMove(m.x,m.y,m.color, true); }
    remain = tline.moves.slice(startIndex).map(m=>({x:m.x,y:m.y,color:m.color}));
    redraw();
  }

function startDrill(i, opts){
  opts = opts || {};
  forceZoomOutForOutcome();
  const fromSkip = !!opts.fromSkip;

  index = i;
  if (index >= slots.length){ showDone(); return; }

  const slot = slots[index], base = slot.base, key  = slot.key;

  SIZE = base.size || 19;
  if (!board) initBoard();
  clearTimers();

  ensureRunPlanFor(key, base);
  const variant = runPlan[key].get(index);
  const tline = makeTransformed(base, variant.orientIdx, variant.swap);
  currentTransformed = tline;

  currentStartIndex = variant.startIndex || 0;
  blitzDirectionalIdx = blitzMode
    ? findFirstDirectionalIndex(tline.moves, SIZE)
    : null;

  prepareCorner(tline, currentStartIndex);


  blitzCornerPlannedMoves = remain.length;

    if (blitzMode){
    ensureTimerEl();

    // Grant the initial pool ONCE per blitz session
    // based on the first corner's planned moves.
    if (!blitzInitialBudgetGranted){
      timerMs = blitzCornerPlannedMoves * 1500;
      blitzInitialBudgetGranted = true;
    }

    if (!timerId) startTimer();
    if (timerEl) timerEl.textContent = fmtMs(timerMs);

    blitzCornerState = {
      tline,
      startIndex: variant.startIndex,
      plannedN: blitzCornerPlannedMoves
    };
  }


  setProgress();
  locked = false;
}


  function restartSameCornerBlitz(){
    if (!blitzMode || !blitzCornerState) return;
    prepareCorner(blitzCornerState.tline, blitzCornerState.startIndex);
    locked = false;
  }

  function onBoardClick(x,y){
    if (isZoomAnimating) return; // NEW: block board clicks during zoom-in anim
    if (locked || timeUp) return;
    if (x<0 || y<0 || x>=SIZE) return;
    if (grid[y][x] !== null) return;
    if (!remain.length) return;

    if (x<0 || y<0 || x>=SIZE) return;
    if (grid[y][x] !== null) return;
    if (!remain.length) return;

    const next = remain[0];
    if (next.x === x && next.y === y){
      playMove(x,y,next.color, false);
      remain.shift();
  if (blitzMode && remain.length){
    redraw();
  }

      if (!remain.length){
        solvedCount++;
        if (blitzMode){
          timerMs += blitzCornerPlannedMoves * 500;
          if (timerEl) timerEl.textContent = fmtMs(timerMs);
        }
        if (index >= (slots.length - 1)) {
          showClearedThenDone();
        } else {
          showClearedAuto();
        }
      }
    } else {
      failedCount++;
      if (blitzMode){
        showWrongThenRestart();
      } else {
        showWrongAuto();
      }
    }
  }

  function showWrongThenRestart(){
    clearTimers();

    // NEW: always zoom out when a variation is done wrong (Blitz too)
    forceZoomOutForOutcome();

    wrongM.style.display='flex';
    locked = true;
    wrongTimer = setTimeout(() => {
      wrongM.style.display='none';
      restartSameCornerBlitz();
    }, 800);
  }

  function showWrongAuto(){
    clearTimers();

    // NEW: always zoom out when a variation is done wrong
    forceZoomOutForOutcome();

    wrongM.style.display='flex';
    locked = true;
    wrongTimer = setTimeout(() => {
      wrongM.style.display='none';
      locked = false;
      if (index >= (slots.length - 1)) showDone(); else startDrill(index+1);
    }, 1000);
  }


  function showClearedAuto(){
    clearTimers();

    // NEW: always zoom out when a variation finishes
    forceZoomOutForOutcome();

    clearedM.style.display='flex';
    locked = true;
    clearedTimer = setTimeout(() => {
      clearedM.style.display='none';
      locked = false;
      startDrill(index+1);
    }, 850);
  }

  function showClearedThenDone(){
    clearTimers();

    // NEW: always zoom out when the final variation finishes
    forceZoomOutForOutcome();

    clearedM.style.display='flex';
    locked = true;
    clearedTimer = setTimeout(() => {
      clearedM.style.display='none';
      showDone();
    }, 800);
  }


    function showDone(customTitle){
    clearTimers();
    forceZoomOutForOutcome();
    if (statSolvedEl) statSolvedEl.textContent = String(solvedCount);
    if (statFailedEl) statFailedEl.textContent = String(failedCount);
    if (doneTitle)    doneTitle.textContent   = customTitle || 'All Drills Complete';

    const left = dailyAttemptsLeftForCurrentMode();

    if (left <= 0){
      if (doneMsgEl) doneMsgEl.textContent = 'You reached your drills limit.';
      doneRetry.disabled = true;
      doneRetry.style.opacity = '.6';
      doneRetry.style.cursor = 'not-allowed';
    } else {
      if (doneMsgEl) {
        doneMsgEl.textContent = customTitle
          ? 'Session ended.'
          : 'Session finished. You can retry the set or go back to selection.';
      }
      doneRetry.disabled = false;
      doneRetry.style.opacity = '1';
      doneRetry.style.cursor = 'pointer';
    }

    doneM.style.display = 'flex';
    if (blitzMode) stopTimer();
  }

  doneBack.addEventListener('click', function(){
    doneM.style.display='none';
    try{ window.location.href = '../drills/drills.html'; }catch(e){}
  });

  function reshuffleSlots(){
    if (!slots.length) return;
    slots = mixSlotsFairly(slots.slice());
    lineToSlotIdxs = {};
    for (let i=0;i<slots.length;i++){
      const key = slots[i].key;
      if (!lineToSlotIdxs[key]) lineToSlotIdxs[key] = [];
      lineToSlotIdxs[key].push(i);
    }
  }

 doneRetry.addEventListener('click', function(){
  // Use the shared per-day counter (same as drills.html)
  if (!hasDailyAttemptsLeftForCurrentMode()){
    showCapMsg();
    if (doneMsgEl) doneMsgEl.textContent = 'You reached your drills limit.';
    doneRetry.disabled = true;
    doneRetry.style.opacity = '.6';
    doneRetry.style.cursor = 'not-allowed';
    return;
  }

  // Consume one daily attempt for this mode (Complete / Blitz)
  recordDailyAttemptForCurrentMode();
  forceZoomOutForOutcome();
  doneM.style.display = 'none';
  resetStats();
  reshuffleSlots();
  newRunPlan();
  blitzCornerState = null;
  timeUp = false;

  if (blitzMode){
    // Reset timer visuals, but do NOT start timer yet.
    // startDrill() will add the first corner budget and start the timer.
blitzInitialBudgetGranted = false;
timerMs = 0;

    ensureTimerEl();
    if (timerEl){
      timerEl.style.display = 'block';
      timerEl.textContent = fmtMs(timerMs);
    }
    stopTimer();

    // Lock input during countdown
    locked = true;

    runBlitzCountdown().then(() => {
      locked = false;
      timeUp = false;
      if (slots.length){
        startDrill(0);
      }
    });

    // Prevent the non-blitz start below
    return;
  } else {
    if (timerEl) timerEl.style.display = 'none';
    stopTimer();
  }

  if (slots.length){
    startDrill(0);
  }
});


btnNext.addEventListener('click', function(){
  if (!slots.length) return;
  if (locked || timeUp) return; // safety

  // Count a skipped pattern as failed
  failedCount++;

  // If stats are ever visible mid-run, keep them in sync
  if (statFailedEl) statFailedEl.textContent = String(failedCount);

  // NEW: always zoom out when a variation is skipped
  forceZoomOutForOutcome();

  // Skip should not grant Blitz time for the next corner.
  startDrill(index + 1, { fromSkip: true });
});




  btnMenu.addEventListener('click',  function(){
    try{ window.location.href = '../drills/drills.html'; }catch(e){}
  });

  const OWN_STORE_KEY = 'go:ownpatterns';
  const FAV_KEY       = 'go_favorites';

  function loadOwnPatterns(){ try { return JSON.parse(localStorage.getItem(OWN_STORE_KEY) || '[]'); } catch(_){ return []; } }
  function readFavs(){ try { return JSON.parse(localStorage.getItem(FAV_KEY) || '{}') || {}; } catch(_){ return {}; } }

  function normalizeLineLike(obj){
    return {
      size: obj.size || 19,
      rootAB: Array.isArray(obj.rootAB)?obj.rootAB:[],
      rootAW: Array.isArray(obj.rootAW)?obj.rootAW:[],
      moves:  (obj.moves||[]).map(m => ({ x:m.x, y:m.y, color:(m.color==='W'?'W':'B') }))
    };
  }

  function fetchLibraryLines(){
    return fetch(SGF_URL, { cache:'no-cache' }).then(r=>r.text()).then(txt=>{
      const trees = parseAllTrees(txt);
      const lines=[];
      for (const seq of trees){
        linkify(seq,null);
        const size = parseSZ(seq[0]?.SZ);
        const rootAB = listCoords(seq[0]?.AB, size);
        const rootAW = listCoords(seq[0]?.AW, size);
        const paths  = enumerateLines(seq,size);
        for (const moves of paths){
          if ((moves?.length||0) >= MIN_MOVES){
            lines.push({ size, rootAB, rootAW, moves });
          }
        }
      }
      return lines;
    });
  }
  // Helper: get selections either from GoDrills (inline/Bubble)
  // or from sessionStorage (drills.html → drills-board.html bridge)
  function getDrillSelections(){
    // 1) If GoDrills exists (same-page integration), use it
    if (window.GoDrills && typeof window.GoDrills.getSelections === 'function') {
      try {
        return window.GoDrills.getSelections();
      } catch (e) {}
    }

    // 2) Otherwise, use the bridge from the list page
    try {
      if (typeof sessionStorage === 'undefined') return null;
      var raw = sessionStorage.getItem('go:drills_next_selection');
      if (!raw) return null;
      var obj = JSON.parse(raw);
      if (!obj || typeof obj !== 'object') return null;
      return obj;
    } catch (e) {
      return null;
    }
  }

  const DrillBoard = {
    load: function(linesOrNull, opts){
      PER = Math.max(1, parseInt((opts && opts.perJoseki) || 3, 10) || 3);

      // Read selections via helper (GoDrills on same page OR sessionStorage bridge)
      const sel = getDrillSelections();
      const selMode = (sel && sel.mode === 'blitz') ? 'blitz' : 'complete';
      blitzMode = (selMode === 'blitz');
      blitzInitialBudgetGranted = false;


      function buildSlots(baseLines){
        const raw = [];
        for (const base of baseLines){
          const key = lineKey(base);
          for (let k=0;k<PER;k++){
            raw.push({ key, base });
          }
        }
        slots = mixSlotsFairly(raw);
        lineToSlotIdxs = {};
        for (let i=0;i<slots.length;i++){
          const key = slots[i].key;
          if (!lineToSlotIdxs[key]) lineToSlotIdxs[key] = [];
          lineToSlotIdxs[key].push(i);
        }
      }

      function go(lines){
        const usable = (lines||[]).filter(l => Array.isArray(l.moves) && l.moves.length >= MIN_MOVES).map(normalizeLineLike);
        if (!usable.length){
          alert('No eligible drills (need patterns with 10+ moves).');
          return;
        }
        buildSlots(usable);
        newRunPlan();

        resetStats();
        index=0;
        forceZoomOutForOutcome();
        blitzCornerState = null;
        timeUp = false;

                if (blitzMode){
          // Reset timer visuals, but do NOT start timer yet.
          // startDrill() will add the first corner budget and start the timer.
blitzInitialBudgetGranted = false;
timerMs = 0;

          ensureTimerEl();
          if (timerEl){
            timerEl.style.display = 'block';
            timerEl.textContent = fmtMs(timerMs);
          }
          stopTimer();

          // Lock input during countdown
          locked = true;

          runBlitzCountdown().then(() => {
            locked = false;
            timeUp = false;
            startDrill(0);
          });

        } else {
          if (timerEl) timerEl.style.display = 'none';
          stopTimer();

          startDrill(0);
        }

        try{ (wrap).scrollIntoView({behavior:'smooth',block:'start'});}catch(_){}
      }

      if (Array.isArray(linesOrNull)){
        go(linesOrNull);
        return;
      }

      // If we have a selection (from GoDrills or from sessionStorage),
      // use ONLY those lines instead of the full library.
      if (sel && (
          (sel.library && sel.library.length) ||
          (sel.favorites && sel.favorites.length) ||
          (sel.own && sel.own.length)
        )){

        const favMap   = readFavs();
        const favLines = Object.values(favMap).map(normalizeLineLike);
        const favPick  = favLines.filter(l => (sel.favorites || []).includes(lineKey(l)));

        const ownAll   = loadOwnPatterns();
        const ownPick  = ownAll
          .filter(p => (sel.own || []).includes(p.id))
          .map(normalizeLineLike);

        if ((sel.library || []).length){
          fetchLibraryLines().then(allLib => {
            const libPick = allLib.filter(l => (sel.library || []).includes(lineKey(l)));
            go([ ...libPick, ...favPick, ...ownPick ]);
          }).catch(() => {
            go([ ...favPick, ...ownPick ]);
          });
        } else {
          go([ ...favPick, ...ownPick ]);
        }
        return;
      }

      // Fallback: no selection info → load full library (old behavior)
      fetchLibraryLines().then(go).catch(() => alert('Could not load drills.'));

    },

    exit: function(){
      stopTimer();
    }
  };
  window.DrillBoard = DrillBoard;

  if (mount && !board) initBoard();

  function hookStart(){
    const s = document.getElementById('drills-start');
    if (!s) return setTimeout(hookStart, 150);
    if (s.__dbHooked) return;
    s.__dbHooked = true;

    function ensureDrillWins(){
      try{
        const gj = document.getElementById('group-joseki');
        if (gj) gj.setAttribute('data-hidden','1');
      }catch(_){}
    }

    function startNow(e){
      if (s.disabled || s.getAttribute('aria-hidden') === 'true' || s.style.display === 'none') return;

      if (!canStart()){
        if (e){ e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); }
        showCapMsg();
        return;
      }
      incRuns();

      if (e){
        e.preventDefault();
        e.stopImmediatePropagation();
        e.stopPropagation();
      }

      if (window.GoDrills && typeof GoDrills.close === 'function'){
        GoDrills.close();
      } else {
        const over = document.getElementById('drills-overlay');
        if (over) over.style.display = 'none';
      }

      setTimeout(()=>{ DrillBoard.load(null, { perJoseki: 3 }); }, 30);
      setTimeout(ensureDrillWins, 120);
      setTimeout(ensureDrillWins, 350);
    }

    s.addEventListener('click',     startNow, true);
    s.addEventListener('pointerup', startNow, true);
    s.addEventListener('touchend',  startNow, { capture:true, passive:false });

    document.addEventListener('click', function docCap(e){
      const t = e.target && e.target.closest ? e.target.closest('#drills-start') : null;
      if (!t) return;
      startNow(e);
    }, true);
  }
  hookStart();

  // Auto-start when used as standalone page (no drills overlay present)
  function autoStartStandalone(){
    const over = document.getElementById('drills-overlay');
    const startBtn = document.getElementById('drills-start');
    const isStandalone = !over && !startBtn;
    if (!isStandalone) return;

    if (!canStart()){
      showCapMsg();
      return;
    }
    incRuns();
    DrillBoard.load(null, { perJoseki: 3 });
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', autoStartStandalone);
  } else {
    autoStartStandalone();
  }
})();
</script>

</body>
</html>