<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    min-height: 100%;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  /* Page wood background (no flex here anymore) */
/* Page wood background + centering */
body {
  background-image:
    linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)),
    url('../img/wood.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: fixed;

  /* center the whole joseki block */
  display: flex;
  align-items: center;      /* vertical center */
  justify-content: center;  /* horizontal center */
  padding: 16px 0;
  box-sizing: border-box;
}


  /* Simple wrapper inside the centered body */
  #page-wrap {
    width: 100%;
    max-width: 720px;
    margin: 0 auto;
  }

  /* Board wrapper */
  #go-board-wrap {
    width: 100%;
    max-width: 720px;
    margin: 0 auto;
    box-sizing: border-box;
  }

  @media (max-width: 480px){
    #go-board-wrap { padding:8px 12px 0; }
  }

  #go-board-wrap #desc-wrap{ max-width:720px; width:100%; }
  #desc-box::-webkit-scrollbar { display: none; }
  #desc-box.grabbing { cursor: grabbing; }

  .j-ctrls{
    width:100%; max-width:720px; margin:10px auto 0;
    padding:8px 12px; gap:10px; justify-content:center; flex-wrap:wrap;
    display:flex; box-sizing:border-box;
  }
  .jbtn{
    padding:12px 16px; border-radius:12px; border:1px solid #cbd5e1;
    background:#fff; font-weight:800; font-size:15px; color:#0f172a;
    cursor:pointer; box-shadow:0 2px 8px rgba(15,23,42,.06);
    -webkit-tap-highlight-color: transparent;
  }
  .jbtn:active{ transform:translateY(1px); }
  .jbtn-alt{ background:#e7f0ff; color:#0b4aa2; border-color:#a7c1ff; }
  .jbtn-strong{ background:#111827; color:#fff; border-color:#111827; }

  /* Board drop shadow */
  #go-board{
    box-shadow:
      0 18px 40px rgba(0,0,0,.32),
      0 6px 16px rgba(0,0,0,.22) !important;
    border-radius: 10px;
  }
</style>
  <style>
    /* Make the description box's width include its border so edges align */
    #desc-box { box-sizing: border-box; }

    /* Let the button row use the full width (no side padding),
       so it lines up exactly with #desc-box */
    #joseki-ctrls{
      padding-left: 0 !important;
      padding-right: 0 !important;
    }

    /* Keep one-line layout while allowing each button to stretch evenly */
    #joseki-ctrls .jbtn,
    #joseki-ctrls .jbtn-strong,
    #joseki-ctrls .jbtn-alt{
      flex: 1 1 0;
      min-width: 0;
      white-space: nowrap;
    }
  </style>

  <style>
  /* Joseki Board buttons – same wood style as Practice Board */
  #joseki-ctrls{
    max-width: 720px;
    width: 100%;
    box-sizing: border-box;
    margin: 14px auto 0;
    padding: 0 12px 18px;
    display: flex;
    justify-content: center;
    gap: 12px;
    flex-wrap: wrap;
  }

  #joseki-ctrls .jbtn,
  #joseki-ctrls .jbtn-strong,
  #joseki-ctrls .jbtn-alt{
    position: relative;
    min-width: 90px;
    padding: 8px 24px;

    /* same layout idea as Practice buttons */
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    text-align: center;

    border-radius: 10px;
    border: 1px solid rgba(255,255,255,.40);

    font-size: 16px;
    font-weight: 800;
    line-height: 1.1;
    color: #fff3cf;
    text-shadow: 0 1px 0 rgba(120,60,20,.7);
    cursor: pointer;

    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;

    background-image:
      linear-gradient(
        to bottom,
        rgba(255,255,255,.12),
        rgba(255,255,255,.03) 38%,
        rgba(0,0,0,.14) 100%
      ),
      url('../img/wood.jpg');
    background-size: 100% 100%, cover;
    background-position: center;
    background-repeat: no-repeat;

    filter: brightness(1.08) saturate(.96);

    box-shadow:
      0 3px 0 rgba(133,74,26,.85),
      0 8px 14px rgba(0,0,0,.45);

    transition:
      transform .08s ease-out,
      box-shadow .08s ease-out,
      filter .12s ease-out;
  }

  #joseki-ctrls .jbtn:hover,
  #joseki-ctrls .jbtn-strong:hover,
  #joseki-ctrls .jbtn-alt:hover{
    filter: brightness(1.12) saturate(.98);
    transform: translateY(-1px);
    box-shadow:
      0 4px 0 rgba(133,74,26,.9),
      0 10px 16px rgba(0,0,0,.48);
  }

  #joseki-ctrls .jbtn:active,
  #joseki-ctrls .jbtn-strong:active,
  #joseki-ctrls .jbtn-alt:active{
    filter: brightness(.97) saturate(.96);
    transform: translateY(2px);
    box-shadow:
      0 1px 0 rgba(120,60,20,.9),
      0 4px 8px rgba(0,0,0,.55);
  }

  #joseki-ctrls .jbtn:focus-visible,
  #joseki-ctrls .jbtn-strong:focus-visible,
  #joseki-ctrls .jbtn-alt:focus-visible{
    outline: 2px solid rgba(255,255,255,.9);
    outline-offset: 2px;
  }

  /* Disabled state – match Practice behavior */
  #joseki-ctrls .jbtn[disabled],
  #joseki-ctrls .jbtn-strong[disabled],
  #joseki-ctrls .jbtn-alt[disabled]{
    opacity: .45;
    cursor: default;
    box-shadow: none;
    transform: none;
    filter: brightness(1) saturate(.9);
  }
  </style>

  <style>
    /* In-app "Back to menu" dialog (slate/blue skin) */
    #menu-confirm-overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(15,23,42,.78);
      z-index:99999;
      -webkit-tap-highlight-color:transparent;
    }
    #menu-confirm-overlay.is-open{
      display:flex;
    }

    .menu-confirm-dialog{
      width:min(92vw,360px);
      border-radius:16px;
      padding:18px 16px 14px;
      background:#020617;
      border:1px solid rgba(148,163,184,.75);
      box-shadow:0 18px 40px rgba(15,23,42,.7);
      color:#e5edff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    .menu-confirm-title{
      font-size:18px;
      font-weight:700;
      margin-bottom:6px;
    }
    .menu-confirm-text{
      font-size:14px;
      opacity:.9;
      margin-bottom:12px;
    }
    .menu-confirm-actions{
      display:flex;
      gap:10px;
      margin-top:4px;
    }

    .mc-btn{
      flex:1 1 0;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.9);
      font-size:14px;
      font-weight:600;
      cursor:pointer;
      background:rgba(15,23,42,.9);
      color:#e5edff;
      -webkit-tap-highlight-color:transparent;
      transition:background .12s, transform .06s, box-shadow .12s;
    }
    .mc-btn:active{
      transform:translateY(1px);
    }

    .mc-btn-primary{
      background:rgba(37,99,235,.26);
      border-color:rgba(37,99,235,.85);
      box-shadow:0 8px 20px rgba(15,23,42,.65), inset 0 0 0 1px rgba(255,255,255,.05);
    }
    .mc-btn-primary:hover{
      background:rgba(37,99,235,.32);
    }

    .mc-btn-secondary{
      background:rgba(15,23,42,.85);
    }
  </style>

</head>
<body>

<div id="page-wrap">
  <!-- Joseki Board -->
  <div id="go-board-wrap">
    <!-- Board -->
    <div id="go-board"
         style="width:100%;border-radius:6px;overflow:hidden;box-shadow:0 1px 3px rgba(0,0,0,.08);"></div>

    <!-- Integrated description -->
    <div id="desc-wrap" style="width:100%;display:flex;justify-content:center;margin:10px auto 0;">
      <div id="desc-box"
           style="
             max-width:720px;width:100%;height:120px;
             padding:12px;border:1px solid #ddd;border-radius:8px;
             overflow-y:auto;-webkit-overflow-scrolling:touch;touch-action:pan-y;
             background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.06);
             line-height:1.6;font-size:15px;text-align:center;
             scrollbar-width:none;
             cursor:grab;">
        <div id="descText">Move description will appear here.</div>
      </div>
    </div>

    <!-- Buttons -->
    <div id="joseki-ctrls" class="j-ctrls">
      <button id="jbtnMenu"    class="jbtn jbtn-strong" type="button">Menu</button>
      <button id="jbtnBack"    class="jbtn"             type="button">Back</button>
      <button id="jbtnForward" class="jbtn"             type="button">Next</button>
      <button id="jbtnPass"    class="jbtn"             type="button" disabled>Pass</button>
      <button id="jbtnReset"   class="jbtn jbtn-alt"    type="button">Reset</button>
    </div>
  </div>
</div>


<!-- In-app "Back to menu" confirmation -->
<div id="menu-confirm-overlay" aria-hidden="true">
  <div class="menu-confirm-dialog" role="dialog" aria-modal="true" aria-labelledby="menuConfirmTitle">
    <div class="menu-confirm-title" id="menuConfirmTitle">Back to menu?</div>
    <div class="menu-confirm-text">
      Do you want to leave this joseki view and return to the main menu?
    </div>
    <div class="menu-confirm-actions">
      <button type="button" id="menuConfirmCancel" class="mc-btn mc-btn-secondary">Stay here</button>
      <button type="button" id="menuConfirmOk" class="mc-btn mc-btn-primary">Yes, go to menu</button>
    </div>
  </div>
</div>

<!-- Simple click sound (local file) -->
<script>
  window.StoneSFX = (function () {
    var audio = new Audio("../sound/click.mp3");
    audio.preload = "auto";
    return {
      play: function () {
        try {
          audio.currentTime = 0;
          audio.play();
        } catch (e) {}
      }
    };
  })();
</script>

<!-- Local WGo library -->
<script src="../lib/wgo.min.js"></script>

<script>
/* Prevent double-mount */
if (!window._mainBoardMounted) {
window._mainBoardMounted = true;

(function mountBoard(){
  if (!window.WGo) return setTimeout(mountBoard, 50);

  var wrap  = document.getElementById('go-board-wrap');
  var mount = document.getElementById('go-board');
  var MENU_URL = '../joseki-menu/index.html';

  if (!wrap || mount.clientWidth === 0) return setTimeout(mountBoard, 50);

  /* ====================== PAGE BACKGROUND ====================== */
  (function(){
    if (!document.getElementById('site-bg-wood')){
      var css = `
:root{ --wood-url: url('../img/wood.jpg'); }
html.bg-wood, body.bg-wood{
  background-image: linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)), var(--wood-url);
  background-size: cover; background-position: center; background-repeat: no-repeat; background-attachment: fixed; min-height:100%;
}
body.bg-wood #bubble,
body.bg-wood .bubble-r-container,
body.bg-wood #page,
body.bg-wood .page,
body.bg-wood #root,
body.bg-wood [data-visual-element="Page"],
body.bg-wood .bubble-element.Page{
  background: transparent !important;
}
html.no-wood, body.no-wood{ background: none !important; }

body.bg-wood .modal-backdrop,
body.bg-wood .bubble-overlay,
body.bg-wood .overlay,
body.bg-wood .popup-dim,
body.bg-wood .s-dim,
body.bg-wood .dim,
body.bg-wood .backdrop{
  background: transparent !important;
  backdrop-filter: none !important;
  filter: none !important;
}
body.bg-wood .blur,
body.bg-wood .blurry,
body.bg-wood .frost,
body.bg-wood .frosted,
body.bg-wood [class*="blur"]{
  filter: none !important;
  backdrop-filter: none !important;
}
      `;
      var st = document.createElement('style');
      st.id = 'site-bg-wood';
      st.textContent = css;
      document.head.appendChild(st);
    }
    function addBG(){
      document.documentElement.classList.remove('no-wood');
      document.body.classList.remove('no-wood');
      document.documentElement.classList.add('bg-wood');
      document.body.classList.add('bg-wood');
    }
    function removeBG(){
      document.documentElement.classList.remove('bg-wood');
      document.body.classList.remove('bg-wood');
      document.documentElement.classList.add('no-wood');
      document.body.classList.add('no-wood');
    }
    window.PageBG = window.PageBG || { add: addBG, remove: removeBG };

    try { PageBG.add(); } catch(e){}

    (function keepBackgroundCrisp(){
      const SEL = '.modal-backdrop, .bubble-overlay, .overlay, .popup-dim, .s-dim, .dim, .backdrop';
      function undim(){
        if (!document.body.classList.contains('bg-wood')) return;
        document.querySelectorAll(SEL).forEach(el=>{
          el.style.background = 'transparent';
          el.style.backdropFilter = 'none';
          el.style.filter = 'none';
        });
      }
      const mo = new MutationObserver(undim);
      mo.observe(document.body, { childList:true, subtree:true, attributes:true, attributeFilter:['class','style'] });
      undim();
    })();

    function isShown(el){
      if (!el) return false;
      var cs = getComputedStyle(el);
      return cs.display !== 'none' && el.offsetWidth > 0 && el.offsetHeight > 0;
    }
    var targets = [ document.getElementById('group-joseki'), wrap ].filter(Boolean);
    if (targets.length){
      var mo2 = new MutationObserver(function(){
        for (var i=0;i<targets.length;i++){
          if (isShown(targets[i])) { try { PageBG.add(); } catch(e){} break; }
        }
      });
      targets.forEach(function(t){
        mo2.observe(t, { attributes:true, attributeFilter:['style','class','data-hidden'] });
      });
    }
  })();
  /* ==================== /PAGE BACKGROUND ==================== */

  /* ===== Remove duplicate description boxes & button rows (static page safety) ===== */
  (function dedupeUI(){
    function keepOnlyFirst(selector){
      const all = Array.from(document.querySelectorAll(selector));
      if (!all.length) return;
      let keeper = all.find(el => wrap.contains(el)) || all[0];
      all.forEach(el => { if (el !== keeper && el.parentNode) el.parentNode.removeChild(el); });
    }
    keepOnlyFirst('#desc-wrap');
    keepOnlyFirst('#joseki-ctrls');
  })();

  /* Description drag-to-scroll */
  (function(){
    var box = document.getElementById('desc-box');
    if (!box) return;
    let isDown=false, startY=0, startScroll=0;
    box.addEventListener('mousedown', (e) => {
      isDown = true; box.classList.add('grabbing'); startY = e.clientY; startScroll = box.scrollTop; e.preventDefault();
    });
    box.addEventListener('mousemove', (e) => { if (!isDown) return; const dy = e.clientY - startY; box.scrollTop = startScroll - dy; });
    ['mouseup','mouseleave'].forEach(ev => box.addEventListener(ev, () => { isDown=false; box.classList.remove('grabbing'); }));
    box.addEventListener('touchstart', (e) => { startY = e.touches[0].clientY; startScroll = box.scrollTop; }, {passive:true});
    box.addEventListener('touchmove',  (e) => { const dy = e.touches[0].clientY - startY; box.scrollTop = startScroll - dy; }, {passive:true});
  })();

  var SIZE = 19, B='B', W='W';
  // ===== shared preferences with settings page =====
  var STORAGE_KEY = 'go_prefs';
  var GoPrefs = (window.GoPrefs = window.GoPrefs || {});

  try {
    Object.assign(GoPrefs, JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}') || {});
  } catch (e) {}

  // No more josekiZoom preference here – only sound + highlight
  if (typeof GoPrefs.soundOn       === 'undefined') GoPrefs.soundOn       = true;
  if (typeof GoPrefs.highlightLast === 'undefined') GoPrefs.highlightLast = true;

  // ---------- state ----------
  var board = new WGo.Board(mount, { size: SIZE });
  // Wood texture under the board (replaces old zoomLayer background)
  mount.style.backgroundImage = "url('../img/wood.jpg')";
  mount.style.backgroundSize = "cover";
  mount.style.backgroundPosition = "center";
  mount.style.backgroundRepeat = "no-repeat";

  var grid  = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null));
  var history = [];
  var current = 0;
  var turn    = B;  // side to move

  // Simple responsive sizing (no zoom, no fullscreen)
  function fitBoard(){
    var w = mount.clientWidth || 400;
    w = Math.floor(w);
    if (w % 2) w--;
    if (w <= 0) return;
    board.setWidth(w);
    mount.style.height = w + 'px';
  }
  window.addEventListener('resize', fitBoard);
  window.addEventListener('orientationchange', function(){ setTimeout(fitBoard, 200); });
  fitBoard();

  // SGF state
  var hasSGF = false, sgfRootSeq = null, currentNode = null;
  var rootLabels = [], rootNote = '', rootAB = [], rootAW = [];

  // Free-play divergence
  var freeMode = false, josekiAnchor = null;

  // Sound preference (initial from prefs)
  var soundEnabled = !!GoPrefs.soundOn;
  function setSoundEnabled(v){
    soundEnabled = !!v;
  }

  // Highlight last move (initial from prefs)
  var highlightLastEnabled = !!GoPrefs.highlightLast;

  // Pass button helpers
  var passBtn = null;
  function getPassBtn(){
    if (!passBtn) passBtn = document.getElementById('jbtnPass');
    return passBtn;
  }
  function setPassEnabled(on){
    var b = getPassBtn();
    if (!b) return;
    b.disabled = !on;
  }

  function addLB(x,y,text){ board.addObject({ x:x, y:y, type:'LB', text:text }); }

  function redraw(){
    board.removeAllObjects();

    // Stones
    for (var y=0;y<SIZE;y++){
      for (var x=0;x<SIZE;x++){
        var v=grid[y][x];
        if (v===B) board.addObject({x:x,y:y,c:WGo.B});
        else if (v===W) board.addObject({x:x,y:y,c:WGo.W});
      }
    }

    // Labels and candidate markers
    if (hasSGF && !freeMode){
      var allCand = getNextCandidates(currentNode || null) || [];
      var turnCand = allCand.filter(function(c){ return c.color === turn; });

      // Map of all candidate intersections (any color)
      var candMap = {};
      for (var i=0;i<allCand.length;i++){
        var key = allCand[i].xy.x + ':' + allCand[i].xy.y;
        candMap[key] = true;
      }

      // Static LB labels, but skip those on any candidate intersection.
      var nodeLabels = [];
      if (!currentNode) nodeLabels = rootLabels;
      else if (currentNode.LB_) nodeLabels = currentNode.LB_;

      for (var j=0;j<nodeLabels.length;j++){
        var lab = nodeLabels[j];
        var lkey = lab.x + ':' + lab.y;
        if (!candMap[lkey]) addLB(lab.x, lab.y, lab.text);
      }

      // Dynamic candidate letters only for side to move
      for (var k=0;k<turnCand.length;k++){
        addLB(turnCand[k].xy.x, turnCand[k].xy.y, String.fromCharCode(65+k));
      }
    } else if (hasSGF && freeMode){
      // In free mode, show only static labels (no candidate letters)
      var nodeLabels2 = [];
      if (!currentNode) nodeLabels2 = rootLabels;
      else if (currentNode.LB_) nodeLabels2 = currentNode.LB_;
      for (var m=0;m<nodeLabels2.length;m++){
        addLB(nodeLabels2[m].x, nodeLabels2[m].y, nodeLabels2[m].text);
      }
    }

    if (highlightLastEnabled && current > 0) {
      var lm = history[current - 1];
      if (lm) board.addObject({ x: lm.x, y: lm.y, type: 'CR' });
    }
  }

  var descEl = document.getElementById('descText');
  function updateDesc(){
    if (!descEl) return;
    if (freeMode){
      descEl.innerHTML =
        '<div style="font-weight:600;margin-bottom:8px;">Free Play Mode</div>' +
        '<button id="backToJosekiBtn" style="display:inline-block;padding:8px 12px;border-radius:8px;border:1px solid #ccc;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer;">Back to Joseki</button>';
      var btn = document.getElementById('backToJosekiBtn');
      if (btn){
        btn.onclick = function(){
          freeMode = false;
          currentNode = josekiAnchor;
          buildPositionTo(currentNode);
        };
      }
      return;
    }
    if (hasSGF){
      if (!currentNode){ descEl.textContent = rootNote || ''; return; }
      descEl.textContent = currentNode.comment || '';
      return;
    }
    descEl.textContent = '';
  }

  function neighbors(x,y){ var ns=[]; if(x>0)ns.push([x-1,y]); if(x<SIZE-1)ns.push([x+1,y]); if(y>0)ns.push([x,y-1]); if(y<SIZE-1)ns.push([x,y+1]); return ns; }
  function groupAndLiberties(x,y){
    var color=grid[y][x]; if(!color) return {stones:[],liberties:0};
    var st=[[x,y]], seen={}, stones=[], libs=0;
    while(st.length){
      var p=st.pop(), cx=p[0], cy=p[1], k=cx+':'+cy; if(seen[k]) continue;
      seen[k]=1; stones.push([cx,cy]);
      var ns=neighbors(cx,cy);
      for(var i=0;i<ns.length;i++){
        var nx=ns[i][0], ny=ns[i][1], v=grid[ny][nx];
        if(v===null) libs++; else if(v===color && !seen[nx+':'+ny]) st.push([nx,ny]);
      }
    }
    return {stones:stones, liberties:libs};
  }
  function attemptPlay(x,y,color){
    if(grid[y][x]!==null) return {ok:false, captures:[]};
    grid[y][x]=color;
    var opp=(color===B?W:B), captures=[], ns=neighbors(x,y);
    for(var i=0;i<ns.length;i++){
      var nx=ns[i][0], ny=ns[i][1];
      if(grid[ny][nx]===opp){
        var g=groupAndLiberties(nx,ny);
        if(g.liberties===0){
          for(var j=0;j<g.stones.length;j++){ var s=g.stones[j]; grid[s[1]][s[0]]=null; captures.push([s[0],s[1]]); }
        }
      }
    }
    var self=groupAndLiberties(x,y);
    if(captures.length===0 && self.liberties===0){ grid[y][x]=null; return {ok:false, captures:[]}; }
    return {ok:true, captures:captures};
  }

  function rebuildFromHistory(){
    if (current < 0) current = 0;
    if (current > history.length) current = history.length;

    for (var y = 0; y < SIZE; y++) grid[y].fill(null);

    if (hasSGF){
      for (var i = 0; i < rootAB.length; i++){
        var p = rootAB[i];
        grid[p.y][p.x] = B;
      }
      for (var j = 0; j < rootAW.length; j++){
        var q = rootAW[j];
        grid[q.y][q.x] = W;
      }
    }

    var lastMove = null;
    for (var k = 0; k < current; k++){
      var m = history[k];
      attemptPlay(m.x, m.y, m.color);
      lastMove = m;
    }

    if (!lastMove){
      turn = B;
    } else {
      turn = (lastMove.color === B ? W : B);
    }

    redraw();
    updateDesc();
    updatePassButtonState();
  }

  // ---------- SGF parsing ----------
  function readBracket(str, i){
    var out='', k=i;
    while(k<str.length){
      var ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; }
      if(ch===']') break; out+=ch;
    }
    return { text: out, next: k };
  }
  function parseGameTree(str, i){
    var seq=[], node=null;
    if (str[i] !== '(') return { seq:[], next:i };
    i++;
    while (i<str.length){
      var ch=str[i];
      if (ch===';'){ node={}; seq.push(node); i++; }
      else if ((ch>='A'&&ch<='Z')||(ch>='a'&&ch<='z')){
        var key=''; while(i<str.length){ var c=str[i]; if((c>='A'&&c<='Z')||(c>='a'&&c<='z')){ key+=c; i++; } else break; }
        var vals=[]; while(i<str.length && str[i]==='['){ var r=readBracket(str,i+1); vals.push(r.text); i=r.next; }
        if(!node){ node={}; seq.push(node); }
        node[key] = vals.length>1 ? vals : vals[0];
      }
      else if (ch==='('){
        var child = parseGameTree(str, i);
        i = child.next;
        if (seq.length){
          var parent = seq[seq.length-1];
          parent.variations = parent.variations || [];
          parent.variations.push(child.seq);
        }
      }
      else if (ch===')'){ i++; break; }
      else { i++; }
    }
    return { seq: seq, next: i };
  }
  function sgfCoordToXY(s){
    if(!s||s.length<2) return null;
    var x=s.charCodeAt(0)-97, y=s.charCodeAt(1)-97;
    if(x<0||y<0||x>=SIZE||y>=SIZE) return null;
    return {x:x,y:y};
  }
  function parseLB(lb){
    var out=[], list = Array.isArray(lb) ? lb : (lb ? [lb] : []);
    for (var i=0;i<list.length;i++){
      var t=list[i]||'', colon=t.indexOf(':');
      var a=t.substring(0, colon>=0?colon:t.length);
      var label = colon>=0 ? t.substring(colon+1) : '•';
      var xy=sgfCoordToXY(a); if(xy) out.push({x:xy.x,y:xy.y,text:label});
    }
    return out;
  }
  function listCoords(prop){
    var out=[], list = Array.isArray(prop)? prop : (prop?[prop]:[]);
    for (var i=0;i<list.length;i++){ var xy=sgfCoordToXY(list[i]); if(xy) out.push(xy); }
    return out;
  }
  function linkify(seq, parent){
    for (var i=0;i<seq.length;i++){
      var n=seq[i];
      n.prev = (i===0? parent : seq[i-1]);
      n.next = (i<seq.length-1? seq[i+1] : null);
      if (n.C) n.comment = Array.isArray(n.C)? n.C[0] : n.C;
      if (n.LB) n.LB_ = parseLB(n.LB);
      if (n.AB) n.AB_ = listCoords(n.AB);
      if (n.AW) n.AW_ = listCoords(n.AW);
      if (n.variations && n.variations.length){
        for (var v=0; v<n.variations.length; v++){
          var childSeq = n.variations[v];
          if (childSeq && childSeq.length) linkify(childSeq, n);
        }
      }
    }
  }
  function extractRoot(seq){
    rootLabels = []; rootNote = ''; rootAB = []; rootAW = [];
    if (!seq || !seq.length) return;
    var n = seq[0];
    if (n && n.LB_) rootLabels = n.LB_;
    if (n && n.comment) rootNote = n.comment;
    if (n && n.AB_) rootAB = n.AB_;
    if (n && n.AW_) rootAW = n.AW_;
  }
  function nodeHasMove(n){ return !!(n && (n.B || n.W)); }
  function nodeMoveXY(n){
    var s = n.B || n.W; var xy = sgfCoordToXY(s);
    return xy ? {x:xy.x, y:xy.y, color: (n.B?B:W)} : null;
  }
  function candidatesDedup(list){
    var seen={}, out=[];
    for (var i=0;i<list.length;i++){
      var mv=list[i]; var key = mv.xy.x+':'+mv.xy.y+':'+mv.color;
      if (!seen[key]){ seen[key]=1; out.push(mv); }
    }
    return out;
  }

  // Helpers that are aware of pass nodes (B[] / W[])

  function nodeHasColorProp(n){
    return !!(n && (typeof n.B !== 'undefined' || typeof n.W !== 'undefined'));
  }

  function nodePassColor(n){
    if (!n) return null;
    if (typeof n.B !== 'undefined'){
      var v = Array.isArray(n.B) ? n.B[0] : n.B;
      if (v === '') return B;
    }
    if (typeof n.W !== 'undefined'){
      var v2 = Array.isArray(n.W) ? n.W[0] : n.W;
      if (v2 === '') return W;
    }
    return null;
  }

  function getRootCandidates(){
    var out=[];
    if (!sgfRootSeq || !sgfRootSeq.length) return out;
    var r = sgfRootSeq[0];

    var n = r;
    while(n && !nodeHasMove(n)) n = n.next;
    if (n && nodeHasMove(n)){ var mv = nodeMoveXY(n); if (mv) out.push({node:n, xy:{x:mv.x,y:mv.y}, color:mv.color}); }

    if (r && r.variations && r.variations.length){
      for (var v=0; v<r.variations.length; v++){
        var seq = r.variations[v];
        if (seq && seq.length){
          var first = seq[0];
          var m = first;
          while(m && !nodeHasMove(m)) m = m.next;
          if (m && nodeHasMove(m)){ var mv2=nodeMoveXY(m); if (mv2) out.push({node:m, xy:{x:mv2.x,y:mv2.y}, color:mv2.color}); }
        }
      }
    }
    return candidatesDedup(out);
  }

  function getNextCandidates(node){
    if (!node) return getRootCandidates();
    var arr=[];
    if (node.next){
      var n=node.next; while(n && !nodeHasMove(n)) n=n.next;
      if (n && nodeHasMove(n)){ var mv=nodeMoveXY(n); if (mv) arr.push({node:n, xy:{x:mv.x,y:mv.y}, color:mv.color}); }
    }
    if (node.variations && node.variations.length){
      for (var v=0; v<node.variations.length; v++){
        var seq = node.variations[v];
        if (seq && seq.length){
          var m = seq[0];
          while(m && !nodeHasMove(m)) m = m.next;
          if (m && nodeHasMove(m)){ var mv2=nodeMoveXY(m); if (mv2) arr.push({node:m, xy:{x:mv2.x,y:mv2.y}, color:mv2.color}); }
        }
      }
    }
    return candidatesDedup(arr);
  }

  // Color nodes for "next position" regardless of whether it is a pass or a board move
  function getNextColorNodes(node){
    var arr = [];
    if (!sgfRootSeq || !sgfRootSeq.length) return arr;

    if (!node){
      var r = sgfRootSeq[0];
      var n = r;
      while (n && !nodeHasColorProp(n)) n = n.next;
      if (n && nodeHasColorProp(n)) arr.push(n);

      if (r.variations && r.variations.length){
        for (var v = 0; v < r.variations.length; v++){
          var seq = r.variations[v];
          if (seq && seq.length){
            var m = seq[0];
            while (m && !nodeHasColorProp(m)) m = m.next;
            if (m && nodeHasColorProp(m)) arr.push(m);
          }
        }
      }
      return arr;
    }

    if (node.next){
      var n2 = node.next;
      while (n2 && !nodeHasColorProp(n2)) n2 = n2.next;
      if (n2 && nodeHasColorProp(n2)) arr.push(n2);
    }
    if (node.variations && node.variations.length){
      for (var vv = 0; vv < node.variations.length; vv++){
        var seq2 = node.variations[vv];
        if (seq2 && seq2.length){
          var m2 = seq2[0];
          while (m2 && !nodeHasColorProp(m2)) m2 = m2.next;
          if (m2 && nodeHasColorProp(m2)) arr.push(m2);
        }
      }
    }
    return arr;
  }

  // All pass-nodes reachable as immediate next positions from the given node (or root)
  function getPassCandidates(node){
    var colorNodes = getNextColorNodes(node || null);
    var out = [];
    for (var i = 0; i < colorNodes.length; i++){
      var c = nodePassColor(colorNodes[i]);
      if (c){
        out.push({ node: colorNodes[i], color: c });
      }
    }
    return out;
  }

  // Only candidates for current side to move (board moves, not passes)
  function getTurnCandidates(node){
    var all = getNextCandidates(node);
    if (!all || !all.length) return [];
    return all.filter(function(c){ return c.color === turn; });
  }

  // Decide when the Pass button should be enabled:
  // enabled only if there is at least one SGF pass node (B[] / W[]) for the current side to move.
  function computePassAvailability(){
    if (!hasSGF || freeMode) return false;

    var passList = getPassCandidates(currentNode || null);
    if (!passList || !passList.length) return false;

    for (var i = 0; i < passList.length; i++){
      if (passList[i].color === turn) return true;
    }
    return false;
  }

  function updatePassButtonState(){
    setPassEnabled(computePassAvailability());
  }

  function pathTo(node){
    var out=[]; var n=node;
    while(n){ out.push(n); n=n.prev; }
    out.reverse();
    return out;
  }

  // Apply a single SGF node (including pass) to the board; returns the move color if
  // this node represents a move or pass, otherwise null.
  function applyNodeToBoard(nd){
    if (!nd) return null;
    var colorProp, color;
    if (typeof nd.B !== 'undefined'){
      colorProp = nd.B;
      color = B;
    } else if (typeof nd.W !== 'undefined'){
      colorProp = nd.W;
      color = W;
    } else {
      return null; // no move/pass
    }

    var str;
    if (Array.isArray(colorProp)) str = colorProp[0];
    else str = colorProp;

    if (str === '' || str == null){
      // Pure pass: change only the side to move, no stones
      return color;
    }

    var xy = sgfCoordToXY(str);
    if (!xy) return color; // treat as "move" for color progression, even if coord is weird

    var r = attemptPlay(xy.x, xy.y, color);
    if (r.ok){
      history.push({ x: xy.x, y: xy.y, color: color, captures: r.captures });
      return color;
    }
    return color;
  }

  function buildPositionTo(node){
    for (var y=0;y<SIZE;y++) grid[y].fill(null);
    history.length = 0;

    for (var i=0;i<rootAB.length;i++){ var p=rootAB[i]; grid[p.y][p.x]=B; }
    for (var j=0;j<rootAW.length;j++){ var q=rootAW[j]; grid[q.y][q.x]=W; }

    if (!node){
      current = 0;
      turn = B;
      redraw();
      updateDesc();
      updatePassButtonState();
      return;
    }

    var path = pathTo(node);
    var lastColor = null;

    for (var k=0;k<path.length;k++){
      var nd = path[k];
      if (nd.AB_) for (var a=0;a<nd.AB_.length;a++){ var pb=nd.AB_[a]; grid[pb.y][pb.x]=B; }
      if (nd.AW_) for (var b=0;b<nd.AW_.length;b++){ var pw=nd.AW_[b]; grid[pw.y][pw.x]=W; }

      var c = applyNodeToBoard(nd);
      if (c) lastColor = c;
    }

    current = history.length;

    if (!lastColor){
      turn = B;
    } else {
      turn = (lastColor === B ? W : B);
    }

    redraw();
    updateDesc();
    updatePassButtonState();
  }

  function gotoPrev (){ if (!currentNode) return; currentNode = currentNode.prev || null; buildPositionTo(currentNode); }
  function gotoNext (){ var cand = getNextCandidates(currentNode); if (!cand.length) return; currentNode = cand[0].node; buildPositionTo(currentNode); }

  // No zoom logic in click handler anymore
  board.addEventListener('click', function(x,y){
    if (hasSGF && !freeMode){
      var opts = getTurnCandidates(currentNode); // filtered by turn
      for (var i=0;i<opts.length;i++){
        if (opts[i].xy.x===x && opts[i].xy.y===y){
          currentNode = opts[i].node;
          buildPositionTo(currentNode);
          try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
          return;
        }
      }
      if (grid[y][x] !== null) return;
      freeMode = true;
      josekiAnchor = currentNode;
    }

    if (current < history.length) history.splice(current);
    var r = attemptPlay(x,y,turn);
    if(!r.ok) return;
    history.push({ x:x, y:y, color: turn, captures: r.captures });
    current = history.length;
    turn = (turn===B?W:B);
    redraw();
    updateDesc();
    updatePassButtonState();
    try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
  });

  // ---------- controls ----------
  function hook(id, fn){
    var el = document.getElementById(id);
    if (el) el.addEventListener('click', fn);
    else setTimeout(function(){ hook(id, fn); }, 50);
  }

  hook('jbtnBack',    function(){
    if (hasSGF && !freeMode) {
      gotoPrev();
    } else if (current>0){
      current--;
      rebuildFromHistory();
    }
  });

  hook('jbtnForward', function(){
    if (hasSGF && !freeMode) {
      gotoNext();
    } else if (current<history.length){
      current++;
      rebuildFromHistory();
    }
  });

  // Pass: follow an SGF pass node (B[] / W[]) for the current side to move.
  hook('jbtnPass', function(){
    if (!hasSGF || freeMode) return;

    var passList = getPassCandidates(currentNode || null);
    if (!passList || !passList.length) return;

    var chosen = null;
    for (var i = 0; i < passList.length; i++){
      if (passList[i].color === turn){
        chosen = passList[i].node;
        break;
      }
    }
    if (!chosen) return;

    currentNode = chosen;
    buildPositionTo(currentNode);
    try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
  });

  hook('jbtnReset',   function(){
    if (hasSGF) {
      freeMode=false; josekiAnchor=null; currentNode=null;
      buildPositionTo(null);
    } else {
      current=0;
      rebuildFromHistory();
    }
  });

  // ====== In-app "Back to menu" dialog ======
  var menuConfirmOverlay = document.getElementById('menu-confirm-overlay');
  var menuConfirmCancel  = document.getElementById('menuConfirmCancel');
  var menuConfirmOk      = document.getElementById('menuConfirmOk');

  function closeMenuConfirm(){
    if (!menuConfirmOverlay) return;
    menuConfirmOverlay.classList.remove('is-open');
  }

  if (menuConfirmOverlay){
    menuConfirmOverlay.addEventListener('click', function(e){
      if (e.target === menuConfirmOverlay) {
        closeMenuConfirm();
      }
    });
  }

  if (menuConfirmCancel){
    menuConfirmCancel.addEventListener('click', function(e){
      e.stopPropagation();
      closeMenuConfirm();
    });
  }

  if (menuConfirmOk){
    menuConfirmOk.addEventListener('click', function(e){
      e.stopPropagation();
      closeMenuConfirm();
      window.location.href = MENU_URL;
    });
  }

  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape') {
      closeMenuConfirm();
    }
  });

  function openMenuWithConfirm(){
    if (menuConfirmOverlay){
      menuConfirmOverlay.classList.add('is-open');
    } else {
      window.location.href = MENU_URL;
    }
  }

  hook('jbtnMenu', openMenuWithConfirm);

  // public APIs
  window.JosekiBoard = window.JosekiBoard || {};
  window.JosekiBoard.reset = function(){
    freeMode = false; josekiAnchor = null; currentNode = null; current = 0; history.length = 0;
    buildPositionTo(null);
    try { document.getElementById('desc-box').scrollTop = 0; } catch(e){}
    try { window.dispatchEvent(new Event('resize')); } catch(e){}
    try { if (window.PageBG && typeof PageBG.add === 'function') PageBG.add(); } catch(e){}
  };

  window.JosekiSound = {
    isEnabled: function(){ return soundEnabled; },
    setEnabled: function(v){ setSoundEnabled(v); }
  };

  window.JosekiHighlight = {
    isEnabled: function(){ return highlightLastEnabled; },
    setEnabled: function(v){ highlightLastEnabled = !!v; redraw(); }
  };

  // No-op stub so settings page won't break if it calls JosekiZoom here.
  window.JosekiZoom = {
    isEnabled: function(){ return false; },
    setEnabled: function(){},
    resetView: function(){},
    isFullscreen: function(){ return false; }
  };

  // ---------- load SGF (local file) ----------
  var SGF_URL = "../sgf/library-1.sgf";

  function loadSGFText(txt){
    try{
      if (txt.charCodeAt && txt.charCodeAt(0)===0xFEFF) txt = txt.slice(1);
      var parsed = parseGameTree(txt, txt.indexOf('('));
      var rootSeq = parsed.seq && parsed.seq.length ? parsed.seq : [];
      if (!rootSeq.length){ hasSGF=false; freeMode=false; redraw(); updateDesc(); updatePassButtonState(); return; }
      linkify(rootSeq, null);
      sgfRootSeq = rootSeq;
      extractRoot(rootSeq);
      hasSGF = true;
      freeMode = false;
      josekiAnchor = null;
      currentNode = null;
      buildPositionTo(null);
      fitBoard();
      try { if (window.PageBG && typeof PageBG.add === 'function') PageBG.add(); } catch(e){}
    }catch(e){
      console.error('SGF parse error:', e);
      hasSGF=false; freeMode=false;
      redraw();
      updateDesc();
      updatePassButtonState();
    }
  }
  function fetchAndLoadSGF(url){
    fetch(url, { cache:'no-cache' })
      .then(function(r){ return r.text(); })
      .then(function(t){ loadSGFText(t); })
      .catch(function(err){ console.error('SGF load failed:', err); });
  }
  fetchAndLoadSGF(SGF_URL);

})(); // mountBoard
} // _mainBoardMounted
</script>

</body>
</html>
