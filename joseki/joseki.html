<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    min-height: 100%;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  /* Page wood background (no flex here anymore) */
/* Page wood background + centering */
body {
  background-image:
    linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)),
    url('../img/wood.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: fixed;

position: relative;
padding: 0;
box-sizing: border-box;
}


  /* Simple wrapper inside the centered body */
 #page-wrap {
  width: 100%;
  max-width: 720px;
  margin: 0 auto;

  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}


  /* Board wrapper */
  #go-board-wrap {
    width: 100%;
    max-width: 720px;
    margin: 0 auto;
    box-sizing: border-box;
  }

  @media (max-width: 480px){
    #go-board-wrap { padding:8px 12px 0; }
  }

  #go-board-wrap #desc-wrap{ max-width:720px; width:100%; }
  #desc-box::-webkit-scrollbar { display: none; }
  #desc-box.grabbing { cursor: grabbing; }

  /* Board drop shadow */
  #go-board{
    box-shadow:
      0 18px 40px rgba(0,0,0,.32),
      0 6px 16px rgba(0,0,0,.22) !important;
    border-radius: 10px;
  }
</style>
  <style>
/* Make the description box's width include its border so edges align */
#desc-box { box-sizing: border-box; }

/* Keep the same stretch behavior as Practice */
#joseki-ctrls .jbtn,
#joseki-ctrls .jbtn-strong,
#joseki-ctrls .jbtn-alt{
  flex: 1 1 0;
  min-width: 0;
  white-space: nowrap;
}
  </style>

  <style>
 /* Joseki Board buttons – match Practice Board */
#joseki-ctrls{
  max-width: 720px;
  width: 100%;
  box-sizing: border-box;
  margin: 14px auto 0;
  padding: 0 12px 18px;
  display: flex;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
}

#joseki-ctrls .jbtn,
#joseki-ctrls .jbtn-strong,
#joseki-ctrls .jbtn-alt{
  position: relative;
  min-width: 90px;
  padding: 8px 24px;

  flex: 1 1 0;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  text-align: center;

  border-radius: 10px;
  border: 1px solid rgba(255,255,255,.40);

  font-size: 16px;
  font-weight: 800;
  line-height: 1.1;
  color: #fff3cf;
  text-shadow: 0 1px 0 rgba(120,60,20,.7);
  cursor: pointer;

  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-tap-highlight-color: transparent;

  background-image:
    linear-gradient(
      to bottom,
      rgba(255,255,255,.12),
      rgba(255,255,255,.03) 38%,
      rgba(0,0,0,.14) 100%
    ),
    url('../img/wood.jpg');
  background-size: 100% 100%, cover;
  background-position: center;
  background-repeat: no-repeat;

  filter: brightness(1.08) saturate(.96);

  box-shadow:
    0 3px 0 rgba(133,74,26,.85),
    0 8px 14px rgba(0,0,0,.45);

  transition:
    transform .08s ease-out,
    box-shadow .08s ease-out,
    filter .12s ease-out;
}

#joseki-ctrls .jbtn:hover,
#joseki-ctrls .jbtn-strong:hover,
#joseki-ctrls .jbtn-alt:hover{
  filter: brightness(1.12) saturate(.98);
  transform: translateY(-1px);
  box-shadow:
    0 4px 0 rgba(133,74,26,.9),
    0 10px 16px rgba(0,0,0,.48);
}

#joseki-ctrls .jbtn:active,
#joseki-ctrls .jbtn-strong:active,
#joseki-ctrls .jbtn-alt:active{
  filter: brightness(.97) saturate(.96);
  transform: translateY(2px);
  box-shadow:
    0 1px 0 rgba(120,60,20,.9),
    0 4px 8px rgba(0,0,0,.55);
}

#joseki-ctrls .jbtn:focus-visible,
#joseki-ctrls .jbtn-strong:focus-visible,
#joseki-ctrls .jbtn-alt:focus-visible{
  outline: 2px solid rgba(255,255,255,.9);
  outline-offset: 2px;
}

#joseki-ctrls .jbtn[disabled],
#joseki-ctrls .jbtn-strong[disabled],
#joseki-ctrls .jbtn-alt[disabled]{
  opacity: .45;
  cursor: default;
  box-shadow: none;
  transform: none;
  filter: brightness(1) saturate(.9);
}
  </style>

   <style>
    /* In-app "Back to menu" dialog – same layout as Practice Board notifications */

    #menu-confirm-overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:99999;
      -webkit-tap-highlight-color:transparent;
    }
    #menu-confirm-overlay.is-open{
      display:flex;
    }

    /* Typography and layout inside the card */
    .menu-confirm-title{
      font-size:18px;
      font-weight:800;
      margin-bottom:8px;
    }
    .menu-confirm-text{
      margin-bottom:14px;
    }
    .menu-confirm-actions{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:10px;
    }

    /* Shared notification card background (same as Practice Board) */
    .notif-card{
      position:relative;
      z-index:1;

      border-radius:10px;
      border:1px solid #e2e8f0;
      box-shadow:0 12px 28px rgba(15,23,42,.18);

      padding:16px;
      text-align:center;
      font-family:system-ui,Segoe UI,Arial,sans-serif;
      color:#fff3cf;

      background-image:
        linear-gradient(
          to bottom,
          rgba(0,0,0,.10),
          rgba(0,0,0,.25)
        ),
        url('../img/notification.jpg');
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
    }
    .notif-card > div{
      color:inherit !important;
    }

    /* Notification action row helper (same as Practice Board) */
    .notif-actions{
      margin-top:10px;
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }

    /* Wood-style buttons inside notifications – same look as Practice Board .pbtn */
    .notif-actions .pbtn,
    .notif-actions .pbtn-strong,
    .notif-actions .pbtn-alt{
      position:relative;
      min-width:90px;
      padding:8px 24px;

      flex:1 1 0;
      display:flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
      text-align:center;

      border-radius:10px;
      border:1px solid rgba(255,255,255,.40);

      font-size:16px;
      font-weight:800;
      line-height:1.1;
      color:#fff3cf;
      text-shadow:0 1px 0 rgba(120,60,20,.7);
      cursor:pointer;

      user-select:none;
      -webkit-user-select:none;
      -moz-user-select:none;
      -ms-user-select:none;
      -webkit-tap-highlight-color:transparent;

      background-image:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.12),
          rgba(255,255,255,.03) 38%,
          rgba(0,0,0,.14) 100%
        ),
        url('../img/wood.jpg');
      background-size:100% 100%, cover;
      background-position:center;
      background-repeat:no-repeat;

      filter:brightness(1.08) saturate(.96);

      box-shadow:
        0 3px 0 rgba(133,74,26,.85),
        0 8px 14px rgba(0,0,0,.45);

      transition:
        transform .08s ease-out,
        box-shadow .08s ease-out,
        filter .12s ease-out;
    }

    .notif-actions .pbtn:hover,
    .notif-actions .pbtn-strong:hover,
    .notif-actions .pbtn-alt:hover{
      filter:brightness(1.12) saturate(.98);
      transform:translateY(-1px);
      box-shadow:
        0 4px 0 rgba(133,74,26,.9),
        0 10px 16px rgba(0,0,0,.48);
    }

    .notif-actions .pbtn:active,
    .notif-actions .pbtn-strong:active,
    .notif-actions .pbtn-alt:active{
      filter:brightness(.97) saturate(.96);
      transform:translateY(2px);
      box-shadow:
        0 1px 0 rgba(120,60,20,.9),
        0 4px 8px rgba(0,0,0,.55);
    }

    .notif-actions .pbtn:focus-visible,
    .notif-actions .pbtn-strong:focus-visible,
    .notif-actions .pbtn-alt:focus-visible{
      outline:2px solid rgba(255,255,255,.9);
      outline-offset:2px;
    }
  </style>

<style>
  /* Zoom support for Joseki Board */
  #go-board{
    position: relative;
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    transform-origin: 0 0;
  }

  /* Exit button (same visual as core) */
  #zoom-exit-btn{
    position:fixed;
    left:14px;
    bottom:90px;

    width:120px;
    height:80px;
    border-radius:9px;

    background:rgba(148,163,184,.35);
    border:1px solid rgba(148,163,184,.85);
    box-shadow:0 6px 16px rgba(0,0,0,.55);

    display:none;
    cursor:pointer;
    z-index:99999;

    backdrop-filter:blur(2px);
    -webkit-tap-highlight-color:transparent;

    color:#e5e7eb;
    font-size:18px;
    font-weight:600;

    align-items:center;
    justify-content:center;
  }

  #go-board.is-fullscreen{
    position: fixed;
    top: 0; left: 0;
    width: 100vw !important;
    height: 100vh !important;
    border-radius: 0 !important;
    box-shadow: none !important;
    z-index: 9999;
    margin: 0;
  }
</style>
<style>
  /* Bottom dock for Joseki controls while fullscreen zoom is active */
  #go-zoom-ui-joseki{
    position: fixed;
    left: 0;
    right: 0;
    bottom: 0;

    /* RESTORED padding: Match Practice Board's outer dock padding */
    padding: 0 12px 18px;

    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: flex-end;

    /* allow board gestures through gaps, but buttons clickable */
    pointer-events: none;

    /* above fullscreen board (9999) but below confirm overlay (99999+) */
    z-index: 99998;
  }
  #go-zoom-ui-joseki > *{
    pointer-events: auto;
  }

  /* When in zoom mode, tighten the control row for dock use */
  body.joseki-zoom-mode #joseki-ctrls{
    /* Keep margin auto to center, but remove top margin */
    margin: 0 auto !important;
    
    /* Match Practice: Padding ALSO on the inner controls (double padding creates the look) */
    padding: 0 12px 18px !important;
    
    width: 100%;
    max-width: 720px;
  }

  /* Hide the description box while zoomed to save space */
  body.joseki-zoom-mode #desc-wrap{
    display: none !important;
  }

  /* Show only the first 3 buttons while zoomed */
  body.joseki-zoom-mode #jbtnMenu,
  body.joseki-zoom-mode #jbtnReset{
    display: none !important;
  }
</style>
</style>

<style>
/* Black reveal overlay (covers page on show, then fades away) */
#page-fade{
  position: fixed;
  inset: 0;
  background: #000;
  z-index: 100000; /* above confirm overlay (99999) */
  opacity: 1;
  transition: opacity .9s ease;
}

/* Triggered by JS */
#page-fade.is-hidden{
  opacity: 0;
  pointer-events: none;
}

/* Accessibility */
@media (prefers-reduced-motion: reduce){
  #page-fade{
    transition: none;
  }
}
</style>

</head>
<body>
  <div id="page-fade" aria-hidden="true"></div>

  <div id="page-wrap">
  <!-- Joseki Board -->
  <div id="go-board-wrap">
    <!-- Board -->
    <div id="go-board"
         style="width:100%;border-radius:6px;overflow:hidden;box-shadow:0 1px 3px rgba(0,0,0,.08);"></div>

    <!-- Integrated description -->
    <div id="desc-wrap" style="width:100%;display:flex;justify-content:center;margin:10px auto 0;">
      <div id="desc-box"
           style="
             max-width:720px;width:100%;height:120px;
             padding:12px;border:1px solid #ddd;border-radius:8px;
             overflow-y:auto;-webkit-overflow-scrolling:touch;touch-action:pan-y;
             background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.06);
             line-height:1.6;font-size:15px;text-align:center;
             scrollbar-width:none;
             cursor:grab;">
        <div id="descText"></div>
      </div>
    </div>
<div id="joseki-ctrls-anchor"></div>
    <!-- Buttons -->
    <div id="joseki-ctrls" class="j-ctrls">
      <button id="jbtnBack"    class="jbtn"             type="button">Back</button>
      <button id="jbtnForward" class="jbtn"             type="button">Next</button>
      <button id="jbtnPass"    class="jbtn"             type="button" disabled>Pass</button>
      <button id="jbtnMenu"    class="jbtn" type="button">Menu</button>
      <button id="jbtnReset"   class="jbtn"    type="button">Reset</button>
    </div>
  </div>
</div>


<!-- In-app "Back to menu" confirmation – same layout as Practice Board -->
<div id="menu-confirm-overlay" aria-hidden="true">
  <div class="menu-confirm-dialog notif-card"
       style="width:min(86vw,420px);"
       role="dialog"
       aria-modal="true"
       aria-labelledby="menuConfirmTitle">
    <div class="menu-confirm-title" id="menuConfirmTitle">
      Back to menu?
    </div>
    <div class="menu-confirm-text">
      Do you want to leave this joseki view and return to the main menu?
    </div>
    <div class="menu-confirm-actions notif-actions">
      <button type="button" id="menuConfirmCancel" class="pbtn">No</button>
      <button type="button" id="menuConfirmOk" class="pbtn">Yes</button>
    </div>
  </div>
</div>
<div id="zoom-exit-btn"></div>
<div id="go-zoom-ui-joseki"></div>

<!-- Simple click sound (local file) -->
<script>
  window.StoneSFX = (function () {
    var audio = new Audio("../sound/click.mp3");
    audio.preload = "auto";
    return {
      play: function () {
        try {
          audio.currentTime = 0;
          audio.play();
        } catch (e) {}
      }
    };
  })();
</script>

<!-- Local WGo library -->
<script src="../lib/wgo.min.js"></script>

<script>
/* Prevent double-mount */
if (!window._mainBoardMounted) {
window._mainBoardMounted = true;

(function mountBoard(){
  if (!window.WGo) return setTimeout(mountBoard, 50);

  var wrap  = document.getElementById('go-board-wrap');
  var mount = document.getElementById('go-board');
  var MENU_URL = '../joseki-menu/index.html';

  if (!wrap || mount.clientWidth === 0) return setTimeout(mountBoard, 50);

  /* ====================== PAGE BACKGROUND ====================== */
  (function(){
    if (!document.getElementById('site-bg-wood')){
      var css = `
:root{ --wood-url: url('../img/wood.jpg'); }
html.bg-wood, body.bg-wood{
  background-image: linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)), var(--wood-url);
  background-size: cover; background-position: center; background-repeat: no-repeat; background-attachment: fixed; min-height:100%;
}
body.bg-wood #bubble,
body.bg-wood .bubble-r-container,
body.bg-wood #page,
body.bg-wood .page,
body.bg-wood #root,
body.bg-wood [data-visual-element="Page"],
body.bg-wood .bubble-element.Page{
  background: transparent !important;
}
html.no-wood, body.no-wood{ background: none !important; }

body.bg-wood .modal-backdrop,
body.bg-wood .bubble-overlay,
body.bg-wood .overlay,
body.bg-wood .popup-dim,
body.bg-wood .s-dim,
body.bg-wood .dim,
body.bg-wood .backdrop{
  background: transparent !important;
  backdrop-filter: none !important;
  filter: none !important;
}
body.bg-wood .blur,
body.bg-wood .blurry,
body.bg-wood .frost,
body.bg-wood .frosted,
body.bg-wood [class*="blur"]{
  filter: none !important;
  backdrop-filter: none !important;
}
      `;
      var st = document.createElement('style');
      st.id = 'site-bg-wood';
      st.textContent = css;
      document.head.appendChild(st);
    }
    function addBG(){
      document.documentElement.classList.remove('no-wood');
      document.body.classList.remove('no-wood');
      document.documentElement.classList.add('bg-wood');
      document.body.classList.add('bg-wood');
    }
    function removeBG(){
      document.documentElement.classList.remove('bg-wood');
      document.body.classList.remove('bg-wood');
      document.documentElement.classList.add('no-wood');
      document.body.classList.add('no-wood');
    }
    window.PageBG = window.PageBG || { add: addBG, remove: removeBG };

    try { PageBG.add(); } catch(e){}

    (function keepBackgroundCrisp(){
      const SEL = '.modal-backdrop, .bubble-overlay, .overlay, .popup-dim, .s-dim, .dim, .backdrop';
      function undim(){
        if (!document.body.classList.contains('bg-wood')) return;
        document.querySelectorAll(SEL).forEach(el=>{
          el.style.background = 'transparent';
          el.style.backdropFilter = 'none';
          el.style.filter = 'none';
        });
      }
      const mo = new MutationObserver(undim);
      mo.observe(document.body, { childList:true, subtree:true, attributes:true, attributeFilter:['class','style'] });
      undim();
    })();

    function isShown(el){
      if (!el) return false;
      var cs = getComputedStyle(el);
      return cs.display !== 'none' && el.offsetWidth > 0 && el.offsetHeight > 0;
    }
    var targets = [ document.getElementById('group-joseki'), wrap ].filter(Boolean);
    if (targets.length){
      var mo2 = new MutationObserver(function(){
        for (var i=0;i<targets.length;i++){
          if (isShown(targets[i])) { try { PageBG.add(); } catch(e){} break; }
        }
      });
      targets.forEach(function(t){
        mo2.observe(t, { attributes:true, attributeFilter:['style','class','data-hidden'] });
      });
    }
  })();
  /* ==================== /PAGE BACKGROUND ==================== */

  /* ===== Remove duplicate description boxes & button rows (static page safety) ===== */
  (function dedupeUI(){
    function keepOnlyFirst(selector){
      const all = Array.from(document.querySelectorAll(selector));
      if (!all.length) return;
      let keeper = all.find(el => wrap.contains(el)) || all[0];
      all.forEach(el => { if (el !== keeper && el.parentNode) el.parentNode.removeChild(el); });
    }
    keepOnlyFirst('#desc-wrap');
    keepOnlyFirst('#joseki-ctrls');
  })();

  /* Description drag-to-scroll */
  (function(){
    var box = document.getElementById('desc-box');
    if (!box) return;
    let isDown=false, startY=0, startScroll=0;
    box.addEventListener('mousedown', (e) => {
      isDown = true; box.classList.add('grabbing'); startY = e.clientY; startScroll = box.scrollTop; e.preventDefault();
    });
    box.addEventListener('mousemove', (e) => { if (!isDown) return; const dy = e.clientY - startY; box.scrollTop = startScroll - dy; });
    ['mouseup','mouseleave'].forEach(ev => box.addEventListener(ev, () => { isDown=false; box.classList.remove('grabbing'); }));
    box.addEventListener('touchstart', (e) => { startY = e.touches[0].clientY; startScroll = box.scrollTop; }, {passive:true});
    box.addEventListener('touchmove',  (e) => { const dy = e.touches[0].clientY - startY; box.scrollTop = startScroll - dy; }, {passive:true});
  })();

  var SIZE = 19, B='B', W='W';
  // ===== shared preferences with settings page =====
  var STORAGE_KEY = 'go_prefs';
  var GoPrefs = (window.GoPrefs = window.GoPrefs || {});

  try {
    Object.assign(GoPrefs, JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}') || {});
  } catch (e) {}

    if (typeof GoPrefs.josekiZoom         === 'undefined') GoPrefs.josekiZoom         = true;
  if (typeof GoPrefs.disableAutoZoomOut === 'undefined') GoPrefs.disableAutoZoomOut = false;

  if (typeof GoPrefs.soundOn       === 'undefined') GoPrefs.soundOn       = true;
  if (typeof GoPrefs.highlightLast === 'undefined') GoPrefs.highlightLast = true;


  // ---------- state ----------
  var board = new WGo.Board(mount, { size: SIZE });
  ensureZoomLayer();
  bindZoomPointerHandlers();

  var grid  = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null));
  var history = [];
  var current = 0;
  var turn    = B;  // side to move
  var koPoint = null; // {x,y} where immediate recapture is forbidden (simple ko)

  // Simple responsive sizing (no zoom, no fullscreen)
  // Zoom engine state
  var zoomLayer = null;
  var scale = 1, minScale = 1, maxScale = 2.6;
  var offsetX = 0, offsetY = 0;
  var baseW = 0;
  var isFullscreen = false;
  var isZoomAnimating = false;
  var animId = 0;
  var returnAnchor = null;

  var isPanning = false, panStart = null, tapStart = null;
  var TAP_SLOP2 = 64;
  var isFlinging = false, flingId = 0, flingVX = 0, flingVY = 0, flingLastTime = 0;
  var panSamplePrev = null, panSampleCurr = null;

var exitBtn = document.getElementById('zoom-exit-btn');

function lockExitBtn(){
  if (!exitBtn) return;
  exitBtn.dataset.locked = '1';
  exitBtn.style.pointerEvents = 'none';
}

function unlockExitBtn(){
  if (!exitBtn) return;
  exitBtn.dataset.locked = '';
  exitBtn.style.pointerEvents = '';
}

if (exitBtn){

  // extra safety: block any early pointer interaction while animating
  exitBtn.addEventListener('pointerdown', function(e){
    if (isZoomAnimating){
      e.preventDefault();
      e.stopPropagation();
    }
  }, { passive:false });

  exitBtn.addEventListener('click', function(e){
    if (isZoomAnimating){
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    e.stopPropagation();
    smoothZoomOutAndExit();
  });
}

  // ===== Zoom dock wiring (Joseki controls) =====
  var dock = document.getElementById('go-zoom-ui-joseki');
  var ctrls = document.getElementById('joseki-ctrls');
  var ctrlsAnchor = document.getElementById('joseki-ctrls-anchor');

  var ctrlsHomeParent = null;
  var ctrlsHomeNext = null;

  function enableDockMode(){
    if (!dock || !ctrls) return;

    document.body.classList.add('joseki-zoom-mode');
    dock.style.display = 'flex';

    // remember original position once
    if (!ctrlsHomeParent){
      ctrlsHomeParent = ctrls.parentNode;
      ctrlsHomeNext = ctrls.nextSibling;
    }

    // move controls into dock
    dock.appendChild(ctrls);
  }

  function disableDockMode(){
    document.body.classList.remove('joseki-zoom-mode');
    if (dock) dock.style.display = 'none';

    if (!ctrls) return;

    // restore to anchor if it exists, otherwise restore to remembered parent/next
    if (ctrlsAnchor && ctrlsAnchor.parentNode){
      ctrlsAnchor.parentNode.insertBefore(ctrls, ctrlsAnchor.nextSibling);
      return;
    }

    if (ctrlsHomeParent){
      if (ctrlsHomeNext && ctrlsHomeNext.parentNode === ctrlsHomeParent){
        ctrlsHomeParent.insertBefore(ctrls, ctrlsHomeNext);
      } else {
        ctrlsHomeParent.appendChild(ctrls);
      }
    }
  }

  // Settings
  var zoomEnabled = (typeof GoPrefs.josekiZoom !== 'undefined') ? !!GoPrefs.josekiZoom : true;
  var disableAutoZoomOut = (typeof GoPrefs.disableAutoZoomOut !== 'undefined') ? !!GoPrefs.disableAutoZoomOut : false;

  function ensureZoomLayer(){
    if (zoomLayer) return;

    zoomLayer = document.createElement('div');
    zoomLayer.style.position = 'absolute';
    zoomLayer.style.left = '0px';
    zoomLayer.style.top = '0px';
    zoomLayer.style.transformOrigin = '0 0';
    zoomLayer.style.willChange = 'transform';

    while (mount.firstChild) zoomLayer.appendChild(mount.firstChild);
    mount.appendChild(zoomLayer);

    zoomLayer.style.backgroundImage = "url('../img/wood.jpg')";
    zoomLayer.style.backgroundSize = "cover";
    zoomLayer.style.backgroundPosition = "center";
    zoomLayer.style.backgroundRepeat = "no-repeat";
    mount.style.background = "none";
  }

  function canvasCssScale(){
    var c = mount.querySelector('canvas');
    if (!c) return 1;
    var cssW = c.clientWidth || c.getBoundingClientRect().width || 0;
    var intW = c.width || 0;
    if (!cssW || !intW) return 1;
    return cssW / intW;
  }
  function getXcss(i){ return board.getX(i) * canvasCssScale(); }
  function getYcss(j){ return board.getY(j) * canvasCssScale(); }

  function viewportSize(){
    return { vw: mount.clientWidth, vh: mount.clientHeight };
  }

  function clampPan(){
    if (isZoomAnimating) return;
    const {vw, vh} = viewportSize();
    const bw = Math.round(baseW * scale);
    const bleedX = Math.ceil(vw * 0.5);
    const bleedY = Math.ceil(vh * 0.5);
    const minOX = -bleedX;
    const maxOX = Math.max(0, bw - vw) + bleedX;
    const minOY = -bleedY;
    const maxOY = Math.max(0, bw - vh) + bleedY;

    offsetX = Math.max(minOX, Math.min(offsetX, maxOX));
    offsetY = Math.max(minOY, Math.min(offsetY, maxOY));
  }

  function applyPanAndSize(redrawAfter){
    const targetW = baseW;

    if (board && board._lastW !== targetW) {
      board.setWidth(targetW);
      if (zoomLayer) {
        zoomLayer.style.width = targetW + 'px';
        zoomLayer.style.height = targetW + 'px';
      }
      board._lastW = targetW;
      if (!redrawAfter) redrawAfter = true;
    }

    clampPan();

    if (zoomLayer) {
      zoomLayer.style.transform =
        'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';
    }

    if (redrawAfter) redraw();
  }

  function cancelFling(){
    isFlinging = false;
    if (flingId) { cancelAnimationFrame(flingId); flingId = 0; }
  }

  function startFling(vx, vy){
    if (scale <= 1) return;
    cancelFling();

    var speed = Math.sqrt(vx*vx + vy*vy);
    var MAX_SPEED = 0.50;
    if (speed > MAX_SPEED){
      var s = MAX_SPEED / speed;
      vx *= s; vy *= s; speed = MAX_SPEED;
    }
    if (speed < 0.04) return;

    isFlinging = true;
    flingVX = vx; flingVY = vy;
    flingLastTime = performance.now();

    (function step(now){
      if (!isFlinging) return;
      var dt = now - flingLastTime;
      if (dt <= 0){
        flingId = requestAnimationFrame(step);
        return;
      }
      if (dt > 50) dt = 50;
      flingLastTime = now;

      offsetX += flingVX * dt;
      offsetY += flingVY * dt;

      var friction = 0.0010;
      var currentSpeed = Math.sqrt(flingVX*flingVX + flingVY*flingVY);
      var decel = friction * dt;

      if (currentSpeed <= 0.01 || decel >= currentSpeed){
        cancelFling();
        applyPanAndSize(true);
        return;
      }

      var newSpeed = currentSpeed - decel;
      var scaleFactor = newSpeed / currentSpeed;
      flingVX *= scaleFactor;
      flingVY *= scaleFactor;

      applyPanAndSize(false);
      flingId = requestAnimationFrame(step);
    })(performance.now());
  }

  function animateTo(targetScale, pxWorld, pyWorld, sxTarget, syTarget, onDone){
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
    cancelFling();

    const s0 = scale, ox0 = offsetX, oy0 = offsetY;
    const t0 = performance.now();
    const dur = 260;

    cancelAnimationFrame(animId);
    isZoomAnimating = true;
lockExitBtn();
    const targetOffsetX = (pxWorld * targetScale) - sxTarget;
    const targetOffsetY = (pyWorld * targetScale) - syTarget;

    (function step(now){
      let t = (now - t0) / dur;
      if (t > 1) t = 1;
      const e = 1 - Math.pow(1 - t, 3);

      scale = s0 + (targetScale - s0) * e;
      offsetX = ox0 + (targetOffsetX - ox0) * e;
      offsetY = oy0 + (targetOffsetY - oy0) * e;

      applyPanAndSize(false);

      if (t < 1){
        animId = requestAnimationFrame(step);
     } else {
  isZoomAnimating = false;
  unlockExitBtn();
  applyPanAndSize(true);
  if (typeof onDone === 'function') onDone();
}

    })(t0);
  }

 function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
    if (isFullscreen) return;
    cancelFling();

    returnAnchor = document.createElement('div');
    returnAnchor.style.width = mount.clientWidth + 'px';
    returnAnchor.style.height = mount.clientHeight + 'px';
    mount.parentNode.insertBefore(returnAnchor, mount);

    document.body.appendChild(mount);
    mount.classList.add('is-fullscreen');
    isFullscreen = true;
    if (exitBtn) exitBtn.style.display = 'flex';
    enableDockMode();


    mount.style.width = '100vw';
    mount.style.height = '100vh';

    scale = 1; offsetX = 0; offsetY = 0;

    const vw = window.innerWidth;
    const vh = window.innerHeight;
    baseW = Math.floor(Math.min(vw, vh));
    if (baseW % 2) baseW--;

    requestAnimationFrame(function(){
      applyPanAndSize(true);

      // --- CHANGED: Dynamic calculation to match Practice Board ---
      const needToCover = Math.max(vw, vh) / baseW;
      const initialFactor = Math.max(1.8, needToCover + 0.02);
      // -----------------------------------------------------------

      const px_curr = getXcss(i);
      const py_curr = getYcss(j);

      const rect = mount.getBoundingClientRect();
      let sx = rect.width / 2;
      let sy = rect.height / 2;

      if (typeof tapClientX === 'number' && typeof tapClientY === 'number'){
        sx = tapClientX - rect.left;
        sy = tapClientY - rect.top;
      }

      offsetX = px_curr * 1.0 - sx;
      offsetY = py_curr * 1.0 - sy;
      applyPanAndSize(false);

      animateTo(initialFactor, px_curr, py_curr, sx, sy);
    });
  }

  function exitFullscreen(){
cancelFling();
cancelAnimationFrame(animId);
isZoomAnimating = false;
unlockExitBtn();


    mount.classList.remove('is-fullscreen');
    if (exitBtn) exitBtn.style.display = 'none';
    isFullscreen = false;
    disableDockMode();

    if (returnAnchor && returnAnchor.parentNode){
      returnAnchor.parentNode.insertBefore(mount, returnAnchor);
      returnAnchor.parentNode.removeChild(returnAnchor);
      returnAnchor = null;
    }

    mount.style.width = '';
    mount.style.height = '';

    fitBoard();
    resetViewLocal();
  }

  function resetViewLocal(){
    scale = 1; offsetX = 0; offsetY = 0;
    applyPanAndSize(true);
  }

  function smoothZoomOutAndExit(){
cancelFling();
cancelAnimationFrame(animId);
isZoomAnimating = false;
unlockExitBtn();


    scale = 1; offsetX = 0; offsetY = 0;
    applyPanAndSize(true);

    if (isFullscreen) exitFullscreen();
  }

  function fitBoard(){
    if (isFullscreen) return;
    var w = mount.clientWidth || 400;
    w = Math.floor(w);
    if (w % 2) w--;
    if (w <= 0) return;

    baseW = w;
    mount.style.height = w + 'px';

    ensureZoomLayer();
    applyPanAndSize(true);
  }
  function getGridSpacing(){
    var sX = Math.abs(getXcss(1) - getXcss(0));
    var sY = Math.abs(getYcss(1) - getYcss(0));
    return { x: sX, y: sY };
  }

  function bindZoomPointerHandlers(){
    mount.addEventListener('pointerdown', function(e){
      if (!zoomEnabled) return;
      if (e.pointerType !== 'touch' && e.button !== 0) return;
      isPanning = false;   // reset per gesture
      tapStart = null;
      cancelFling();

      const r = mount.getBoundingClientRect();
      const sx = e.clientX - r.left;
      const sy = e.clientY - r.top;

      const boardX = (sx + offsetX) / scale;
      const boardY = (sy + offsetY) / scale;

      let bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;
      for (let i = 0; i < SIZE; i++){
        const dx = Math.abs(getXcss(i) - boardX);
        if (dx < bestDx){ bestDx = dx; bestI = i; }
      }
      for (let j = 0; j < SIZE; j++){
        const dy = Math.abs(getYcss(j) - boardY);
        if (dy < bestDy){ bestDy = dy; bestJ = j; }
      }

      const spacing = getGridSpacing();
      const limitX = spacing.x * 0.5;
      const limitY = spacing.y * 0.5;

      panStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY };
      panSamplePrev = panSampleCurr = null;
      try { mount.setPointerCapture(e.pointerId); } catch(_){}

      if (bestDx > limitX || bestDy > limitY) {
        tapStart = null;
        return;
      }

      tapStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY, gridI: bestI, gridJ: bestJ };
    }, {passive:false});

    mount.addEventListener('pointermove', function(e){
      if (!zoomEnabled) return;
      if (!panStart) return;
      if (scale <= 1.01 && !isFullscreen) return;

      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;

      if (!isPanning && (dx*dx + dy*dy > TAP_SLOP2)) isPanning = true;

      if (isPanning) {
        offsetX = panStart.ox - dx;
        offsetY = panStart.oy - dy;
        applyPanAndSize(false);
        e.preventDefault();

        const now = performance.now();
        panSamplePrev = panSampleCurr;
        panSampleCurr = { ox: offsetX, oy: offsetY, t: now };
      }
    }, {passive:false});

    mount.addEventListener('pointerup', function(e){
      if (!zoomEnabled) return;

      if (!tapStart) {
        if (panStart) {
          try { mount.releasePointerCapture(e.pointerId); } catch(_){}
          panStart = null;
        }
        return;
      }


      try { mount.releasePointerCapture(e.pointerId); } catch(_){}

      const dist2 = (e.clientX - tapStart.x)**2 + (e.clientY - tapStart.y)**2;
      const { gridI, gridJ } = tapStart;
      const tapX = tapStart.x;
      const tapY = tapStart.y;

      tapStart = null; panStart = null;

      if (isPanning) {
        isPanning = false;
        if (panSamplePrev && panSampleCurr) {
          const dt = panSampleCurr.t - panSamplePrev.t;
          if (dt > 0 && dt < 120) {
            startFling((panSampleCurr.ox - panSamplePrev.ox)/dt, (panSampleCurr.oy - panSamplePrev.oy)/dt);
          }
        }
        return;
      }

      if (dist2 <= TAP_SLOP2) {
        e.preventDefault();
        if (scale <= 1.05 && !isFullscreen) {
          enterFullscreenAtGrid(gridI, gridJ, tapX, tapY);
        } else {
          handleBoardTap(gridI, gridJ);
          if (!disableAutoZoomOut && scale > 1) {
            setTimeout(smoothZoomOutAndExit, 10);
          }
        }
      }
    }, {passive:false});
    mount.addEventListener('pointercancel', function(e){
      if (!zoomEnabled) return;

      try { mount.releasePointerCapture(e.pointerId); } catch(_){}

      // Reset gesture state
      tapStart = null;
      panStart = null;
      isPanning = false;
      panSamplePrev = null;
      panSampleCurr = null;

      // Stop momentum if a gesture was canceled mid-flight
      cancelFling();
    }, {passive:false});

  }

  window.addEventListener('resize', fitBoard);
  window.addEventListener('orientationchange', function(){ setTimeout(fitBoard, 200); });
  fitBoard();

  // SGF state
  var hasSGF = false, sgfRootSeq = null, currentNode = null;
  var rootLabels = [], rootNote = '', rootAB = [], rootAW = [];

// Free-play divergence
var freeMode = false, josekiAnchor = null, josekiAnchorIndex = 0;
  // ===== Favorites storage (shared with Practice List) =====
  var FAV_KEY = 'go_favorites';

  function favLineKey(line){
    var size = line.size || SIZE;
    var seq = (line.moves || []).map(function(m){
      return (m.color || 'B')[0] + ':' + m.x + ',' + m.y;
    }).join('|');
    return size + '|' + seq;
  }

  function favReadMap(){
    try {
      return JSON.parse(localStorage.getItem(FAV_KEY) || '{}') || {};
    } catch(e){
      return {};
    }
  }

  function favWriteMap(map){
    try {
      localStorage.setItem(FAV_KEY, JSON.stringify(map));
    } catch(e){}
  }

  function favIsSaved(line){
    var map = favReadMap();
    return !!map[favLineKey(line)];
  }

  function favAdd(line){
    var map = favReadMap();
    map[favLineKey(line)] = {
      size: line.size || SIZE,
      rootAB: Array.isArray(line.rootAB) ? line.rootAB : [],
      rootAW: Array.isArray(line.rootAW) ? line.rootAW : [],
      moves: (line.moves || []).map(function(p){
        return { x:p.x, y:p.y, color:p.color };
      })
    };
    favWriteMap(map);
  }

  // Build a favorite line from current node, respecting pass rules:
  // - up to 2 initial passes allowed if they are all same color as first stone move
  // - any later pass counts as "end"; favorite stops at last stone before that pass
  // Returns { size, rootAB, rootAW, moves[] } or null if not valid.
  function buildFavoriteLineFromNode(currentNode){
    if (!hasSGF || !currentNode || freeMode) return null;

    // If we are on a pass node, treat the favorite as ending at the last stone before it
    var isPassHere = !!nodePassColor(currentNode);
    var endNode = currentNode;

    if (isPassHere){
      var pathAll = pathTo(currentNode);
      var lastMoveNode = null;
      for (var i = 0; i < pathAll.length; i++){
        if (nodeMoveXY(pathAll[i])) lastMoveNode = pathAll[i];
      }
      if (!lastMoveNode) return null; // only passes, nothing to favorite
      endNode = lastMoveNode;
    }

    var path = pathTo(endNode);

    // Find first stone move, count initial passes before it
    var firstMoveIndex = -1;
    var firstMoveColor = null;
    var initialPassCount = 0;
    var initialPassColors = [];

    for (var idx = 0; idx < path.length; idx++){
      var n = path[idx];
      var mv = nodeMoveXY(n);
      if (mv){
        firstMoveIndex = idx;
        firstMoveColor = mv.color;
        break;
      }
      var pc = nodePassColor(n);
      if (pc){
        initialPassCount++;
        initialPassColors.push(pc);
      }
    }

    if (firstMoveIndex === -1) return null;            // no stones at all
    if (initialPassCount > 2) return null;             // too many initial passes

    // all initial passes must match the first stone's color
    for (var t = 0; t < initialPassColors.length; t++){
      if (initialPassColors[t] !== firstMoveColor) return null;
    }

    // Collect all stone moves from firstMoveIndex up to endNode (stones only)
    var moves = [];
    for (var k = firstMoveIndex; k < path.length; k++){
      var n2 = path[k];
      var mv2 = nodeMoveXY(n2);
      if (mv2){
        moves.push({ x: mv2.x, y: mv2.y, color: mv2.color });
      }
    }

    if (!moves.length) return null;

    return {
      size: SIZE,
      rootAB: rootAB.slice(),
      rootAW: rootAW.slice(),
      moves: moves
    };
  }

  // Decide if the current joseki position should offer "Add to favorites"
  function getCurrentFavoriteLineCandidate(){
    if (!hasSGF || freeMode || !currentNode) return null;

    var isPassHere = !!nodePassColor(currentNode);

    // If we are on a pass node, that itself counts as "end of line"
    if (isPassHere){
      return buildFavoriteLineFromNode(currentNode);
    }

    // Otherwise, only allow favorites at leaf positions that have no further SGF moves or passes
    var nextStones = getNextCandidates(currentNode) || [];
    var nextPasses = getPassCandidates(currentNode) || [];

    if (nextStones.length > 0 || nextPasses.length > 0){
      // There is still at least one SGF continuation (stone or pass) → no favorite button yet
      return null;
    }

    return buildFavoriteLineFromNode(currentNode);
  }


  // Sound preference (initial from prefs)
  var soundEnabled = !!GoPrefs.soundOn;
  function setSoundEnabled(v){
    soundEnabled = !!v;
  }

  // Highlight last move (initial from prefs)
  var highlightLastEnabled = !!GoPrefs.highlightLast;

  // Pass button helpers
  var passBtn = null;
  function getPassBtn(){
    if (!passBtn) passBtn = document.getElementById('jbtnPass');
    return passBtn;
  }
  function setPassEnabled(on){
    var b = getPassBtn();
    if (!b) return;
    b.disabled = !on;
  }

  function addLB(x,y,text){ board.addObject({ x:x, y:y, type:'LB', text:text }); }

function redraw(){
  board.removeAllObjects();

  // Stones
  for (var y=0; y<SIZE; y++){
    for (var x=0; x<SIZE; x++){
      var v = grid[y][x];
      if (v === B) board.addObject({ x:x, y:y, c: WGo.B });
      else if (v === W) board.addObject({ x:x, y:y, c: WGo.W });
    }
  }

  // Labels and candidate markers – ONLY when NOT in free play mode
  if (hasSGF && !freeMode){
    var allCand  = getNextCandidates(currentNode || null) || [];
    var turnCand = allCand.filter(function(c){ return c.color === turn; });

    // Map of all candidate intersections (any color)
    var candMap = {};
    for (var i=0; i<allCand.length; i++){
      var key = allCand[i].xy.x + ':' + allCand[i].xy.y;
      candMap[key] = true;
    }

    // Static LB labels, but skip those on any candidate intersection
    var nodeLabels = [];
    if (!currentNode) nodeLabels = rootLabels;
    else if (currentNode.LB_) nodeLabels = currentNode.LB_;

    for (var j=0; j<nodeLabels.length; j++){
      var lab  = nodeLabels[j];
      var lkey = lab.x + ':' + lab.y;
      if (!candMap[lkey]) addLB(lab.x, lab.y, lab.text);
    }

    // Dynamic candidate letters only for side to move
    for (var k=0; k<turnCand.length; k++){
      addLB(turnCand[k].xy.x, turnCand[k].xy.y, String.fromCharCode(65 + k));
    }
  }
  // else: hasSGF && freeMode → no SGF labels at all (clean board)

  // Last-move highlighting still works in both modes
  if (highlightLastEnabled && current > 0){
    var lm = history[current - 1];
    if (lm) board.addObject({ x: lm.x, y: lm.y, type: 'CR' });
  }
}


   var descEl = document.getElementById('descText');

  // Small helper: safely escape SGF comments for innerHTML
  function escHTML(s){
    if (s == null) return '';
    return String(s).replace(/[&<>"]/g, function(ch){
      if (ch === '&') return '&amp;';
      if (ch === '<') return '&lt;';
      if (ch === '>') return '&gt;';
      if (ch === '"') return '&quot;';
      return ch;
    });
  }

   function updateDesc(){
    if (!descEl) return;

    // Free-play description (unchanged)
    if (freeMode){
      descEl.innerHTML =
        '<div style="font-weight:600;margin-bottom:8px;">Free Play Mode</div>' +
        '<button id="backToJosekiBtn" ' +
          'style="display:inline-block;padding:8px 12px;border-radius:8px;' +
                 'border:1px solid #ccc;background:#fff;' +
                 'box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer;">' +
          'Back to Joseki' +
        '</button>';

      var btn = document.getElementById('backToJosekiBtn');
      if (btn){
        btn.onclick = function(){
          freeMode = false;
          currentNode = josekiAnchor;
          buildPositionTo(currentNode);
        };
      }
      return;
    }

    // No SGF loaded → nothing to show
    if (!hasSGF){
      descEl.textContent = '';
      return;
    }

    // Base comment text (root comment or node comment)
    var baseText = '';
    if (!currentNode){
      baseText = rootNote || '';
    } else {
      baseText = currentNode.comment || '';
    }

    // Check if this position is a favorite endpoint according to pass rules
    var favLine = getCurrentFavoriteLineCandidate();
    var html = '';

    if (baseText && String(baseText).trim().length){
      html += '<div>' + escHTML(baseText) + '</div>';
    }

    if (favLine){
      var already = favIsSaved(favLine);
      if (already){
        html += '<div style="margin-top:10px;font-weight:600;color:#047857;">' +
                  'Already in your favorites' +
                '</div>';
      } else {
        html += '<div style="margin-top:10px;">' +
                  '<button id="addFavBtn" ' +
                    'style="display:inline-block;padding:8px 12px;border-radius:8px;' +
                           'border:1px solid #ccc;background:#fff;' +
                           'box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer;">' +
                    'Add this joseki to Favorites' +
                  '</button>' +
                '</div>';
      }
    }

    if (!html){
      html = '&nbsp;';
    }

    descEl.innerHTML = html;

    // Wire up the "Add to favorites" button if present
    if (favLine && !favIsSaved(favLine)){
      var addBtn = document.getElementById('addFavBtn');
      if (addBtn){
        addBtn.addEventListener('click', function(){
          favAdd(favLine);
          addBtn.disabled = true;
          addBtn.textContent = 'Added to Favorites';
        });
      }
    }
  }


  function neighbors(x,y){ var ns=[]; if(x>0)ns.push([x-1,y]); if(x<SIZE-1)ns.push([x+1,y]); if(y>0)ns.push([x,y-1]); if(y<SIZE-1)ns.push([x,y+1]); return ns; }
  function groupAndLiberties(x,y){
    var color=grid[y][x]; if(!color) return {stones:[],liberties:0};
    var st=[[x,y]], seen={}, stones=[], libs=0;
    while(st.length){
      var p=st.pop(), cx=p[0], cy=p[1], k=cx+':'+cy; if(seen[k]) continue;
      seen[k]=1; stones.push([cx,cy]);
      var ns=neighbors(cx,cy);
      for(var i=0;i<ns.length;i++){
        var nx=ns[i][0], ny=ns[i][1], v=grid[ny][nx];
        if(v===null) libs++; else if(v===color && !seen[nx+':'+ny]) st.push([nx,ny]);
      }
    }
    return {stones:stones, liberties:libs};
  }
   function attemptPlay(x,y,color){
    if (grid[y][x] !== null) return {ok:false, captures:[]};

    // Simple KO check
    if (koPoint && koPoint.x === x && koPoint.y === y) {
      return {ok:false, captures:[]};
    }

    grid[y][x] = color;

    var opp = (color === B ? W : B);
    var captures = [];
    var ns = neighbors(x,y);

    for (var i=0; i<ns.length; i++){
      var nx = ns[i][0], ny = ns[i][1];
      if (grid[ny][nx] === opp){
        var g = groupAndLiberties(nx,ny);
        if (g.liberties === 0){
          for (var j=0; j<g.stones.length; j++){
            var s = g.stones[j];
            grid[s[1]][s[0]] = null;
            captures.push([s[0], s[1]]);
          }
        }
      }
    }

    var self = groupAndLiberties(x,y);

    // Suicide (only allowed if you captured something)
    if (captures.length === 0 && self.liberties === 0){
      grid[y][x] = null;
      return {ok:false, captures:[]};
    }

    // Determine next KO point (simple ko)
    // Condition: exactly one stone captured and the capturing group is a single stone
    // with exactly one liberty.
    if (captures.length === 1){
      var myGroup = groupAndLiberties(x,y);
      if (myGroup.stones.length === 1 && myGroup.liberties === 1){
        koPoint = { x: captures[0][0], y: captures[0][1] };
      } else {
        koPoint = null;
      }
    } else {
      koPoint = null;
    }

    return {ok:true, captures:captures};
  }


  function rebuildFromHistory(){
    if (current < 0) current = 0;
    if (current > history.length) current = history.length;
koPoint = null;
    for (var y = 0; y < SIZE; y++) grid[y].fill(null);

    if (hasSGF){
      for (var i = 0; i < rootAB.length; i++){
        var p = rootAB[i];
        grid[p.y][p.x] = B;
      }
      for (var j = 0; j < rootAW.length; j++){
        var q = rootAW[j];
        grid[q.y][q.x] = W;
      }
    }

    var lastMove = null;
    for (var k = 0; k < current; k++){
      var m = history[k];
      attemptPlay(m.x, m.y, m.color);
      lastMove = m;
    }

    if (!lastMove){
      turn = B;
    } else {
      turn = (lastMove.color === B ? W : B);
    }

    redraw();
    updateDesc();
    updatePassButtonState();
  }

  // ---------- SGF parsing ----------
  function readBracket(str, i){
    var out='', k=i;
    while(k<str.length){
      var ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; }
      if(ch===']') break; out+=ch;
    }
    return { text: out, next: k };
  }
  function parseGameTree(str, i){
    var seq=[], node=null;
    if (str[i] !== '(') return { seq:[], next:i };
    i++;
    while (i<str.length){
      var ch=str[i];
      if (ch===';'){ node={}; seq.push(node); i++; }
      else if ((ch>='A'&&ch<='Z')||(ch>='a'&&ch<='z')){
        var key=''; while(i<str.length){ var c=str[i]; if((c>='A'&&c<='Z')||(c>='a'&&c<='z')){ key+=c; i++; } else break; }
        var vals=[]; while(i<str.length && str[i]==='['){ var r=readBracket(str,i+1); vals.push(r.text); i=r.next; }
        if(!node){ node={}; seq.push(node); }
        node[key] = vals.length>1 ? vals : vals[0];
      }
      else if (ch==='('){
        var child = parseGameTree(str, i);
        i = child.next;
        if (seq.length){
          var parent = seq[seq.length-1];
          parent.variations = parent.variations || [];
          parent.variations.push(child.seq);
        }
      }
      else if (ch===')'){ i++; break; }
      else { i++; }
    }
    return { seq: seq, next: i };
  }
  function sgfCoordToXY(s){
    if(!s||s.length<2) return null;
    var x=s.charCodeAt(0)-97, y=s.charCodeAt(1)-97;
    if(x<0||y<0||x>=SIZE||y>=SIZE) return null;
    return {x:x,y:y};
  }
  function parseLB(lb){
    var out=[], list = Array.isArray(lb) ? lb : (lb ? [lb] : []);
    for (var i=0;i<list.length;i++){
      var t=list[i]||'', colon=t.indexOf(':');
      var a=t.substring(0, colon>=0?colon:t.length);
      var label = colon>=0 ? t.substring(colon+1) : '•';
      var xy=sgfCoordToXY(a); if(xy) out.push({x:xy.x,y:xy.y,text:label});
    }
    return out;
  }
  function listCoords(prop){
    var out=[], list = Array.isArray(prop)? prop : (prop?[prop]:[]);
    for (var i=0;i<list.length;i++){ var xy=sgfCoordToXY(list[i]); if(xy) out.push(xy); }
    return out;
  }
  function linkify(seq, parent){
    for (var i=0;i<seq.length;i++){
      var n=seq[i];
      n.prev = (i===0? parent : seq[i-1]);
      n.next = (i<seq.length-1? seq[i+1] : null);
      if (n.C) n.comment = Array.isArray(n.C)? n.C[0] : n.C;
      if (n.LB) n.LB_ = parseLB(n.LB);
      if (n.AB) n.AB_ = listCoords(n.AB);
      if (n.AW) n.AW_ = listCoords(n.AW);
      if (n.variations && n.variations.length){
        for (var v=0; v<n.variations.length; v++){
          var childSeq = n.variations[v];
          if (childSeq && childSeq.length) linkify(childSeq, n);
        }
      }
    }
  }
  function extractRoot(seq){
    rootLabels = []; rootNote = ''; rootAB = []; rootAW = [];
    if (!seq || !seq.length) return;
    var n = seq[0];
    if (n && n.LB_) rootLabels = n.LB_;
    if (n && n.comment) rootNote = n.comment;
    if (n && n.AB_) rootAB = n.AB_;
    if (n && n.AW_) rootAW = n.AW_;
  }
  function nodeHasMove(n){ return !!(n && (n.B || n.W)); }
  function nodeMoveXY(n){
    var s = n.B || n.W; var xy = sgfCoordToXY(s);
    return xy ? {x:xy.x, y:xy.y, color: (n.B?B:W)} : null;
  }
  function candidatesDedup(list){
    var seen={}, out=[];
    for (var i=0;i<list.length;i++){
      var mv=list[i]; var key = mv.xy.x+':'+mv.xy.y+':'+mv.color;
      if (!seen[key]){ seen[key]=1; out.push(mv); }
    }
    return out;
  }

  // Helpers that are aware of pass nodes (B[] / W[])

  function nodeHasColorProp(n){
    return !!(n && (typeof n.B !== 'undefined' || typeof n.W !== 'undefined'));
  }

  function nodePassColor(n){
    if (!n) return null;
    if (typeof n.B !== 'undefined'){
      var v = Array.isArray(n.B) ? n.B[0] : n.B;
      if (v === '') return B;
    }
    if (typeof n.W !== 'undefined'){
      var v2 = Array.isArray(n.W) ? n.W[0] : n.W;
      if (v2 === '') return W;
    }
    return null;
  }

  function getRootCandidates(){
    var out=[];
    if (!sgfRootSeq || !sgfRootSeq.length) return out;
    var r = sgfRootSeq[0];

    var n = r;
    while(n && !nodeHasMove(n)) n = n.next;
    if (n && nodeHasMove(n)){ var mv = nodeMoveXY(n); if (mv) out.push({node:n, xy:{x:mv.x,y:mv.y}, color:mv.color}); }

    if (r && r.variations && r.variations.length){
      for (var v=0; v<r.variations.length; v++){
        var seq = r.variations[v];
        if (seq && seq.length){
          var first = seq[0];
          var m = first;
          while(m && !nodeHasMove(m)) m = m.next;
          if (m && nodeHasMove(m)){ var mv2=nodeMoveXY(m); if (mv2) out.push({node:m, xy:{x:mv2.x,y:mv2.y}, color:mv2.color}); }
        }
      }
    }
    return candidatesDedup(out);
  }

  function getNextCandidates(node){
    if (!node) return getRootCandidates();
    var arr=[];
    if (node.next){
      var n=node.next; while(n && !nodeHasMove(n)) n=n.next;
      if (n && nodeHasMove(n)){ var mv=nodeMoveXY(n); if (mv) arr.push({node:n, xy:{x:mv.x,y:mv.y}, color:mv.color}); }
    }
    if (node.variations && node.variations.length){
      for (var v=0; v<node.variations.length; v++){
        var seq = node.variations[v];
        if (seq && seq.length){
          var m = seq[0];
          while(m && !nodeHasMove(m)) m = m.next;
          if (m && nodeHasMove(m)){ var mv2=nodeMoveXY(m); if (mv2) arr.push({node:m, xy:{x:mv2.x,y:mv2.y}, color:mv2.color}); }
        }
      }
    }
    return candidatesDedup(arr);
  }

  // Color nodes for "next position" regardless of whether it is a pass or a board move
  function getNextColorNodes(node){
    var arr = [];
    if (!sgfRootSeq || !sgfRootSeq.length) return arr;

    if (!node){
      var r = sgfRootSeq[0];
      var n = r;
      while (n && !nodeHasColorProp(n)) n = n.next;
      if (n && nodeHasColorProp(n)) arr.push(n);

      if (r.variations && r.variations.length){
        for (var v = 0; v < r.variations.length; v++){
          var seq = r.variations[v];
          if (seq && seq.length){
            var m = seq[0];
            while (m && !nodeHasColorProp(m)) m = m.next;
            if (m && nodeHasColorProp(m)) arr.push(m);
          }
        }
      }
      return arr;
    }

    if (node.next){
      var n2 = node.next;
      while (n2 && !nodeHasColorProp(n2)) n2 = n2.next;
      if (n2 && nodeHasColorProp(n2)) arr.push(n2);
    }
    if (node.variations && node.variations.length){
      for (var vv = 0; vv < node.variations.length; vv++){
        var seq2 = node.variations[vv];
        if (seq2 && seq2.length){
          var m2 = seq2[0];
          while (m2 && !nodeHasColorProp(m2)) m2 = m2.next;
          if (m2 && nodeHasColorProp(m2)) arr.push(m2);
        }
      }
    }
    return arr;
  }

  // All pass-nodes reachable as immediate next positions from the given node (or root)
  function getPassCandidates(node){
    var colorNodes = getNextColorNodes(node || null);
    var out = [];
    for (var i = 0; i < colorNodes.length; i++){
      var c = nodePassColor(colorNodes[i]);
      if (c){
        out.push({ node: colorNodes[i], color: c });
      }
    }
    return out;
  }

  // Only candidates for current side to move (board moves, not passes)
  function getTurnCandidates(node){
    var all = getNextCandidates(node);
    if (!all || !all.length) return [];
    return all.filter(function(c){ return c.color === turn; });
  }

  // Decide when the Pass button should be enabled:
  // enabled only if there is at least one SGF pass node (B[] / W[]) for the current side to move.
  function computePassAvailability(){
    if (!hasSGF || freeMode) return false;

    var passList = getPassCandidates(currentNode || null);
    if (!passList || !passList.length) return false;

    for (var i = 0; i < passList.length; i++){
      if (passList[i].color === turn) return true;
    }
    return false;
  }

  function updatePassButtonState(){
    setPassEnabled(computePassAvailability());
  }

  function pathTo(node){
    var out=[]; var n=node;
    while(n){ out.push(n); n=n.prev; }
    out.reverse();
    return out;
  }

  // Apply a single SGF node (including pass) to the board; returns the move color if
  // this node represents a move or pass, otherwise null.
  function applyNodeToBoard(nd){
    if (!nd) return null;
    var colorProp, color;
    if (typeof nd.B !== 'undefined'){
      colorProp = nd.B;
      color = B;
    } else if (typeof nd.W !== 'undefined'){
      colorProp = nd.W;
      color = W;
    } else {
      return null; // no move/pass
    }

    var str;
    if (Array.isArray(colorProp)) str = colorProp[0];
    else str = colorProp;

    if (str === '' || str == null){
      // Pure pass: change only the side to move, no stones
      return color;
    }

    var xy = sgfCoordToXY(str);
    if (!xy) return color; // treat as "move" for color progression, even if coord is weird

    var r = attemptPlay(xy.x, xy.y, color);
    if (r.ok){
      history.push({ x: xy.x, y: xy.y, color: color, captures: r.captures });
      return color;
    }
    return color;
  }

  function buildPositionTo(node){
    for (var y=0;y<SIZE;y++) grid[y].fill(null);
    history.length = 0;
koPoint = null;
    for (var i=0;i<rootAB.length;i++){ var p=rootAB[i]; grid[p.y][p.x]=B; }
    for (var j=0;j<rootAW.length;j++){ var q=rootAW[j]; grid[q.y][q.x]=W; }

    if (!node){
      current = 0;
      turn = B;
      redraw();
      updateDesc();
      updatePassButtonState();
      return;
    }

    var path = pathTo(node);
    var lastColor = null;

    for (var k=0;k<path.length;k++){
      var nd = path[k];
      if (nd.AB_) for (var a=0;a<nd.AB_.length;a++){ var pb=nd.AB_[a]; grid[pb.y][pb.x]=B; }
      if (nd.AW_) for (var b=0;b<nd.AW_.length;b++){ var pw=nd.AW_[b]; grid[pw.y][pw.x]=W; }

      var c = applyNodeToBoard(nd);
      if (c) lastColor = c;
    }

    current = history.length;

    if (!lastColor){
      turn = B;
    } else {
      turn = (lastColor === B ? W : B);
    }

    redraw();
    updateDesc();
    updatePassButtonState();
  }

  function gotoPrev (){ if (!currentNode) return; currentNode = currentNode.prev || null; buildPositionTo(currentNode); }
  function gotoNext (){ var cand = getNextCandidates(currentNode); if (!cand.length) return; currentNode = cand[0].node; buildPositionTo(currentNode); }

  // Shared tap handler used by normal click + zoom-tap
  function handleBoardTap(x,y){
    if (hasSGF && !freeMode){
      var opts = getTurnCandidates(currentNode); // filtered by turn
      for (var i=0;i<opts.length;i++){
        if (opts[i].xy.x===x && opts[i].xy.y===y){
          currentNode = opts[i].node;
          buildPositionTo(currentNode);
          try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
          return;
        }
      }
      if (grid[y][x] !== null) return;
      freeMode = true;
      josekiAnchor = currentNode;
      josekiAnchorIndex = current;   // how many moves were on the board when we diverged
    }

    if (current < history.length) history.splice(current);
    var r = attemptPlay(x,y,turn);
    if(!r.ok) return;
    history.push({ x:x, y:y, color: turn, captures: r.captures });
    current = history.length;
    turn = (turn===B?W:B);
    redraw();
    updateDesc();
    updatePassButtonState();
    try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
  }

  board.addEventListener('click', function(x, y){
    // When zoom is enabled we rely on our pointer pipeline.
    // This prevents double-fires and prevents WGo's click mapping
    // from misreading coordinates under CSS transforms.
    if (zoomEnabled) return;
    handleBoardTap(x, y);
  });



  // ---------- controls ----------
  function hook(id, fn){
    var el = document.getElementById(id);
    if (el) el.addEventListener('click', fn);
    else setTimeout(function(){ hook(id, fn); }, 50);
  }

hook('jbtnBack', function(){
  if (hasSGF && !freeMode) {
    // Normal joseki navigation
    gotoPrev();
  } else if (current > 0) {
    // Free mode or no SGF: step back through history
    current--;
    rebuildFromHistory();

    // If we were in free mode and have undone all free moves,
    // snap back to the joseki branch (same as "Back to Joseki").
    if (hasSGF && freeMode && current <= josekiAnchorIndex) {
      freeMode = false;
      currentNode = josekiAnchor;
      buildPositionTo(currentNode);
    }
  }
});


hook('jbtnForward', function(){
    var didMove = false;

    if (hasSGF && !freeMode) {
      // Check if a next move actually exists before trying to go there
      var cand = getNextCandidates(currentNode);
      if (cand.length) {
        gotoNext();
        didMove = true;
      }
    } else if (current < history.length){
      // Replaying from history
      current++;
      rebuildFromHistory();
      didMove = true;
    }

    // Play sound if a move actually happened
    if (didMove) {
      try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
    }
  });

  // Pass: follow an SGF pass node (B[] / W[]) for the current side to move.
  hook('jbtnPass', function(){
    if (!hasSGF || freeMode) return;

    var passList = getPassCandidates(currentNode || null);
    if (!passList || !passList.length) return;

    var chosen = null;
    for (var i = 0; i < passList.length; i++){
      if (passList[i].color === turn){
        chosen = passList[i].node;
        break;
      }
    }
    if (!chosen) return;

    currentNode = chosen;
    buildPositionTo(currentNode);
    try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
  });

  hook('jbtnReset',   function(){
    if (hasSGF) {
      freeMode=false; josekiAnchor=null; currentNode=null;
      buildPositionTo(null);
    } else {
      current=0;
      rebuildFromHistory();
    }
  });

  // ====== In-app "Back to menu" dialog ======
  var menuConfirmOverlay = document.getElementById('menu-confirm-overlay');
  var menuConfirmCancel  = document.getElementById('menuConfirmCancel');
  var menuConfirmOk      = document.getElementById('menuConfirmOk');

  function closeMenuConfirm(){
    if (!menuConfirmOverlay) return;
    menuConfirmOverlay.classList.remove('is-open');
  }

  // Disable click-outside-to-close.
  // The dialog should close only via the explicit buttons.
  if (menuConfirmOverlay){
    menuConfirmOverlay.addEventListener('click', function(e){
      if (e.target === menuConfirmOverlay) {
        e.preventDefault();
        e.stopPropagation();
        // no close here
      }
    });
  }

  if (menuConfirmCancel){
    menuConfirmCancel.addEventListener('click', function(e){
      e.stopPropagation();
      closeMenuConfirm();
    });
  }

  if (menuConfirmOk){
    menuConfirmOk.addEventListener('click', function(e){
      e.stopPropagation();
      closeMenuConfirm();
      window.location.href = MENU_URL;
    });
  }

  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape') {
      closeMenuConfirm();
    }
  });

  function openMenuWithConfirm(){
    if (menuConfirmOverlay){
      menuConfirmOverlay.classList.add('is-open');
    } else {
      window.location.href = MENU_URL;
    }
  }

  hook('jbtnMenu', openMenuWithConfirm);

  // public APIs
  window.JosekiBoard = window.JosekiBoard || {};
  window.JosekiBoard.reset = function(){
    freeMode = false; josekiAnchor = null; currentNode = null; current = 0; history.length = 0;
koPoint = null;
    buildPositionTo(null);
    try { document.getElementById('desc-box').scrollTop = 0; } catch(e){}
    try { window.dispatchEvent(new Event('resize')); } catch(e){}
    try { if (window.PageBG && typeof PageBG.add === 'function') PageBG.add(); } catch(e){}
  };

  window.JosekiSound = {
    isEnabled: function(){ return soundEnabled; },
    setEnabled: function(v){ setSoundEnabled(v); }
  };

  window.JosekiHighlight = {
    isEnabled: function(){ return highlightLastEnabled; },
    setEnabled: function(v){ highlightLastEnabled = !!v; redraw(); }
  };

  // No-op stub so settings page won't break if it calls JosekiZoom here.
  window.JosekiZoom = {
    isEnabled: function(){ return !!zoomEnabled; },
    setEnabled: function(v){
      zoomEnabled = !!v;
      GoPrefs.josekiZoom = zoomEnabled;
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(GoPrefs)); } catch(e){}

      if (!zoomEnabled) {
        disableDockMode();

        if (isFullscreen || scale > 1) smoothZoomOutAndExit();
        else resetViewLocal();
      }
    },
    resetView: function(){
      if (isFullscreen) exitFullscreen();
      else resetViewLocal();
    },
    isFullscreen: function(){ return !!isFullscreen; }
  };


// ---------- load SGF (Manifest) ----------
  var SGF_MANIFEST_URL = "../sgf/manifest.json";

  // 1. Helper to resolve manifest URLs (Matches Drills logic)
  function resolveLibrarySgfUrls(){
      return fetch(SGF_MANIFEST_URL, { cache:'no-cache' })
      .then(function(r){
          if (!r.ok) throw new Error('Manifest HTTP ' + r.status);
          return r.text();
      })
      .then(function(raw){
          raw = (raw || '').trim();
          if (!raw) throw new Error('Empty manifest');
          var m = null;
          if (raw[0] === '{' || raw[0] === '['){
              try { m = JSON.parse(raw); } catch(e){ throw new Error('Bad JSON manifest'); }
          }
          var files = [];
          if (!m){
              files = raw.split(/\?|\n/).map(function(s){ return s.trim(); }).filter(Boolean);
          } else if (typeof m === 'string'){
              files = [m];
          } else if (Array.isArray(m)){
              files = m.filter(function(x){ return typeof x === 'string' && x.trim(); });
          } else {
              if (typeof m.library === 'string') files = [m.library];
              else if (Array.isArray(m.library)) files = m.library;
              else if (Array.isArray(m.files)) files = m.files;
          }
          var base = new URL(SGF_MANIFEST_URL, window.location.href);
          return files.map(function(f){ return new URL(f, base).toString(); });
      });
  }

  // 2. Main Loader: Fetches ALL files, merges them, and initializes the board
  function loadSGFManifest(){
    resolveLibrarySgfUrls().then(function(urls){
        return Promise.all(urls.map(function(u){
            return fetch(u, { cache:'no-cache' }).then(function(r){ return r.text(); });
        }));
    }).then(function(texts){
        // Combine all file contents
        var combinedTxt = texts.join('\n');
        loadCombinedSGFText(combinedTxt);
    }).catch(function(err){
        console.error('SGF Manifest load failed:', err);
    });
  }

  // 3. Parsing Logic: Handles multiple game trees (files) and merges them into one root
  function loadCombinedSGFText(txt){
    try{
      if (txt.charCodeAt && txt.charCodeAt(0)===0xFEFF) txt = txt.slice(1);

      var combinedRoot = null;
      var cursor = 0;

      // Loop through ALL trees found in the text (handling multiple files)
      while(true){
         var start = txt.indexOf('(', cursor);
         if (start === -1) break;
         
         var parsed = parseGameTree(txt, start);
         cursor = parsed.next;
         
         var seq = parsed.seq;
         if (seq && seq.length){
            var thisRoot = seq[0];
            linkify(seq, null); // Set up internal links for this tree

            if (!combinedRoot) {
                // First tree found becomes the master root
                combinedRoot = thisRoot;
                if (!combinedRoot.variations) combinedRoot.variations = [];
            } else {
                // Subsequent trees (e.g. from file 2) get merged into the master root
                if (thisRoot.variations && thisRoot.variations.length) {
                    for (var v=0; v<thisRoot.variations.length; v++) {
                         var varSeq = thisRoot.variations[v];
                         // Re-link the parent of this variation to the master root
                         if (varSeq.length) varSeq[0].prev = combinedRoot;
                         combinedRoot.variations.push(varSeq);
                    }
                }
            }
         }
      }

      if (!combinedRoot){ 
        hasSGF=false; freeMode=false; redraw(); updateDesc(); updatePassButtonState(); return; 
      }

      // Initialize the board with the combined result
      sgfRootSeq = [combinedRoot];
      extractRoot(sgfRootSeq);
      hasSGF = true;
      freeMode = false;
      josekiAnchor = null;
      currentNode = null;
      buildPositionTo(null);
      fitBoard();
      try { if (window.PageBG && typeof PageBG.add === 'function') PageBG.add(); } catch(e){}

    }catch(e){
      console.error('SGF parse error:', e);
      hasSGF=false; freeMode=false;
      redraw();
      updateDesc();
      updatePassButtonState();
    }
  }

  // Start the loading process
  loadSGFManifest();
})(); // mountBoard
} // _mainBoardMounted
</script>
<script>
  (function () {
    var fade = document.getElementById("page-fade");
    if (!fade) return;

    var reduceMotion = window.matchMedia &&
      window.matchMedia("(prefers-reduced-motion: reduce)").matches;

    if (reduceMotion) {
      fade.classList.add("is-hidden");
      fade.style.display = "none";
      return;
    }

    function runReveal() {
      // snap to black without animating
      fade.style.transition = "none";
      fade.classList.remove("is-hidden");

      // force reflow so opacity:1 is applied immediately
      void fade.offsetHeight;

      // hand control back to CSS timing
      fade.style.transition = "";

      // fade out on next frame
      requestAnimationFrame(function () {
        fade.classList.add("is-hidden");
      });
    }

    // pageshow runs on first load AND when returning via back/forward cache
    window.addEventListener("pageshow", runReveal);
  })();
</script>

</body>
</html>







