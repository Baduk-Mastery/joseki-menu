<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    min-height: 100%;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  /* Page wood background (no flex here anymore) */
/* Page wood background + centering */
body {
  background-image:
    linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)),
    url('../img/wood.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: fixed;

  /* center the whole joseki block */
  display: flex;
  align-items: center;      /* vertical center */
  justify-content: center;  /* horizontal center */
  padding: 16px 0;
  box-sizing: border-box;
}


  /* Simple wrapper inside the centered body */
  #page-wrap {
    width: 100%;
    max-width: 720px;
    margin: 0 auto;
  }

  /* Board wrapper */
  #go-board-wrap {
    width: 100%;
    max-width: 720px;
    margin: 0 auto;
    box-sizing: border-box;
  }

  @media (max-width: 480px){
    #go-board-wrap { padding:8px 12px 0; }
  }

  #go-board-wrap #desc-wrap{ max-width:720px; width:100%; }
  #desc-box::-webkit-scrollbar { display: none; }
  #desc-box.grabbing { cursor: grabbing; }

  .j-ctrls{
    width:100%; max-width:720px; margin:10px auto 0;
    padding:8px 12px; gap:10px; justify-content:center; flex-wrap:wrap;
    display:flex; box-sizing:border-box;
  }
  .jbtn{
    padding:12px 16px; border-radius:12px; border:1px solid #cbd5e1;
    background:#fff; font-weight:800; font-size:15px; color:#0f172a;
    cursor:pointer; box-shadow:0 2px 8px rgba(15,23,42,.06);
    -webkit-tap-highlight-color: transparent;
  }
  .jbtn:active{ transform:translateY(1px); }
  .jbtn-alt{ background:#e7f0ff; color:#0b4aa2; border-color:#a7c1ff; }
  .jbtn-strong{ background:#111827; color:#fff; border-color:#111827; }

  /* Board drop shadow */
  #go-board{
    box-shadow:
      0 18px 40px rgba(0,0,0,.32),
      0 6px 16px rgba(0,0,0,.22) !important;
    border-radius: 10px;
  }
</style>
  <style>
    /* Make the description box's width include its border so edges align */
    #desc-box { box-sizing: border-box; }

    /* Let the button row use the full width (no side padding),
       so it lines up exactly with #desc-box */
    #joseki-ctrls{
      padding-left: 0 !important;
      padding-right: 0 !important;
    }

    /* Keep one-line layout while allowing each button to stretch evenly */
    #joseki-ctrls .jbtn,
    #joseki-ctrls .jbtn-strong,
    #joseki-ctrls .jbtn-alt{
      flex: 1 1 0;
      min-width: 0;
      white-space: nowrap;
    }
  </style>

  <style>
  /* Joseki Board buttons – same wood style as Practice Board */
  #joseki-ctrls{
    max-width: 720px;
    width: 100%;
    box-sizing: border-box;
    margin: 14px auto 0;
    padding: 0 12px 18px;
    display: flex;
    justify-content: center;
    gap: 12px;
    flex-wrap: wrap;
  }

  #joseki-ctrls .jbtn,
  #joseki-ctrls .jbtn-strong,
  #joseki-ctrls .jbtn-alt{
    position: relative;
    min-width: 90px;
    padding: 8px 24px;

    /* same layout idea as Practice buttons */
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    text-align: center;

    border-radius: 10px;
    border: 1px solid rgba(255,255,255,.40);

    font-size: 16px;
    font-weight: 800;
    line-height: 1.1;
    color: #fff3cf;
    text-shadow: 0 1px 0 rgba(120,60,20,.7);
    cursor: pointer;

    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;

    background-image:
      linear-gradient(
        to bottom,
        rgba(255,255,255,.12),
        rgba(255,255,255,.03) 38%,
        rgba(0,0,0,.14) 100%
      ),
      url('../img/wood.jpg');
    background-size: 100% 100%, cover;
    background-position: center;
    background-repeat: no-repeat;

    filter: brightness(1.08) saturate(.96);

    box-shadow:
      0 3px 0 rgba(133,74,26,.85),
      0 8px 14px rgba(0,0,0,.45);

    transition:
      transform .08s ease-out,
      box-shadow .08s ease-out,
      filter .12s ease-out;
  }

  #joseki-ctrls .jbtn:hover,
  #joseki-ctrls .jbtn-strong:hover,
  #joseki-ctrls .jbtn-alt:hover{
    filter: brightness(1.12) saturate(.98);
    transform: translateY(-1px);
    box-shadow:
      0 4px 0 rgba(133,74,26,.9),
      0 10px 16px rgba(0,0,0,.48);
  }

  #joseki-ctrls .jbtn:active,
  #joseki-ctrls .jbtn-strong:active,
  #joseki-ctrls .jbtn-alt:active{
    filter: brightness(.97) saturate(.96);
    transform: translateY(2px);
    box-shadow:
      0 1px 0 rgba(120,60,20,.9),
      0 4px 8px rgba(0,0,0,.55);
  }

  #joseki-ctrls .jbtn:focus-visible,
  #joseki-ctrls .jbtn-strong:focus-visible,
  #joseki-ctrls .jbtn-alt:focus-visible{
    outline: 2px solid rgba(255,255,255,.9);
    outline-offset: 2px;
  }

  /* Disabled state – match Practice behavior */
  #joseki-ctrls .jbtn[disabled],
  #joseki-ctrls .jbtn-strong[disabled],
  #joseki-ctrls .jbtn-alt[disabled]{
    opacity: .45;
    cursor: default;
    box-shadow: none;
    transform: none;
    filter: brightness(1) saturate(.9);
  }
  </style>

   <style>
    /* In-app "Back to menu" dialog – same layout as Practice Board notifications */

    #menu-confirm-overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,.55);
      z-index:99999;
      -webkit-tap-highlight-color:transparent;
    }
    #menu-confirm-overlay.is-open{
      display:flex;
    }

    /* Typography and layout inside the card */
    .menu-confirm-title{
      font-size:18px;
      font-weight:800;
      margin-bottom:8px;
    }
    .menu-confirm-text{
      margin-bottom:14px;
    }
    .menu-confirm-actions{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:10px;
    }

    /* Shared notification card background (same as Practice Board) */
    .notif-card{
      position:relative;
      z-index:1;

      border-radius:10px;
      border:1px solid #e2e8f0;
      box-shadow:0 12px 28px rgba(15,23,42,.18);

      padding:16px;
      text-align:center;
      font-family:system-ui,Segoe UI,Arial,sans-serif;
      color:#fff3cf;

      background-image:
        linear-gradient(
          to bottom,
          rgba(0,0,0,.10),
          rgba(0,0,0,.25)
        ),
        url('../img/notification.jpg');
      background-size:cover;
      background-position:center;
      background-repeat:no-repeat;
    }
    .notif-card > div{
      color:inherit !important;
    }

    /* Notification action row helper (same as Practice Board) */
    .notif-actions{
      margin-top:10px;
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }

    /* Wood-style buttons inside notifications – same look as Practice Board .pbtn */
    .notif-actions .pbtn,
    .notif-actions .pbtn-strong,
    .notif-actions .pbtn-alt{
      position:relative;
      min-width:90px;
      padding:8px 24px;

      flex:1 1 0;
      display:flex;
      align-items:center;
      justify-content:center;
      box-sizing:border-box;
      text-align:center;

      border-radius:10px;
      border:1px solid rgba(255,255,255,.40);

      font-size:16px;
      font-weight:800;
      line-height:1.1;
      color:#fff3cf;
      text-shadow:0 1px 0 rgba(120,60,20,.7);
      cursor:pointer;

      user-select:none;
      -webkit-user-select:none;
      -moz-user-select:none;
      -ms-user-select:none;
      -webkit-tap-highlight-color:transparent;

      background-image:
        linear-gradient(
          to bottom,
          rgba(255,255,255,.12),
          rgba(255,255,255,.03) 38%,
          rgba(0,0,0,.14) 100%
        ),
        url('../img/wood.jpg');
      background-size:100% 100%, cover;
      background-position:center;
      background-repeat:no-repeat;

      filter:brightness(1.08) saturate(.96);

      box-shadow:
        0 3px 0 rgba(133,74,26,.85),
        0 8px 14px rgba(0,0,0,.45);

      transition:
        transform .08s ease-out,
        box-shadow .08s ease-out,
        filter .12s ease-out;
    }

    .notif-actions .pbtn:hover,
    .notif-actions .pbtn-strong:hover,
    .notif-actions .pbtn-alt:hover{
      filter:brightness(1.12) saturate(.98);
      transform:translateY(-1px);
      box-shadow:
        0 4px 0 rgba(133,74,26,.9),
        0 10px 16px rgba(0,0,0,.48);
    }

    .notif-actions .pbtn:active,
    .notif-actions .pbtn-strong:active,
    .notif-actions .pbtn-alt:active{
      filter:brightness(.97) saturate(.96);
      transform:translateY(2px);
      box-shadow:
        0 1px 0 rgba(120,60,20,.9),
        0 4px 8px rgba(0,0,0,.55);
    }

    .notif-actions .pbtn:focus-visible,
    .notif-actions .pbtn-strong:focus-visible,
    .notif-actions .pbtn-alt:focus-visible{
      outline:2px solid rgba(255,255,255,.9);
      outline-offset:2px;
    }
  </style>


</head>
<body>

<div id="page-wrap">
  <!-- Joseki Board -->
  <div id="go-board-wrap">
    <!-- Board -->
    <div id="go-board"
         style="width:100%;border-radius:6px;overflow:hidden;box-shadow:0 1px 3px rgba(0,0,0,.08);"></div>

    <!-- Integrated description -->
    <div id="desc-wrap" style="width:100%;display:flex;justify-content:center;margin:10px auto 0;">
      <div id="desc-box"
           style="
             max-width:720px;width:100%;height:120px;
             padding:12px;border:1px solid #ddd;border-radius:8px;
             overflow-y:auto;-webkit-overflow-scrolling:touch;touch-action:pan-y;
             background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.06);
             line-height:1.6;font-size:15px;text-align:center;
             scrollbar-width:none;
             cursor:grab;">
        <div id="descText"></div>
      </div>
    </div>

    <!-- Buttons -->
    <div id="joseki-ctrls" class="j-ctrls">
      <button id="jbtnBack"    class="jbtn"             type="button">Back</button>
      <button id="jbtnForward" class="jbtn"             type="button">Next</button>
      <button id="jbtnPass"    class="jbtn"             type="button" disabled>Pass</button>
      <button id="jbtnMenu"    class="jbtn" type="button">Menu</button>
      <button id="jbtnReset"   class="jbtn"    type="button">Reset</button>
    </div>
  </div>
</div>


<!-- In-app "Back to menu" confirmation – same layout as Practice Board -->
<div id="menu-confirm-overlay" aria-hidden="true">
  <div class="menu-confirm-dialog notif-card"
       style="width:min(86vw,420px);"
       role="dialog"
       aria-modal="true"
       aria-labelledby="menuConfirmTitle">
    <div class="menu-confirm-title" id="menuConfirmTitle">
      Back to menu?
    </div>
    <div class="menu-confirm-text">
      Do you want to leave this joseki view and return to the main menu?
    </div>
    <div class="menu-confirm-actions notif-actions">
      <button type="button" id="menuConfirmCancel" class="pbtn">Stay here</button>
      <button type="button" id="menuConfirmOk" class="pbtn">Yes, go to menu</button>
    </div>
  </div>
</div>


<!-- Simple click sound (local file) -->
<script>
  window.StoneSFX = (function () {
    var audio = new Audio("../sound/click.mp3");
    audio.preload = "auto";
    return {
      play: function () {
        try {
          audio.currentTime = 0;
          audio.play();
        } catch (e) {}
      }
    };
  })();
</script>

<!-- Local WGo library -->
<script src="../lib/wgo.min.js"></script>

<script>
/* Prevent double-mount */
if (!window._mainBoardMounted) {
window._mainBoardMounted = true;

(function mountBoard(){
  if (!window.WGo) return setTimeout(mountBoard, 50);

  var wrap  = document.getElementById('go-board-wrap');
  var mount = document.getElementById('go-board');
  var MENU_URL = '../joseki-menu/index.html';

  if (!wrap || mount.clientWidth === 0) return setTimeout(mountBoard, 50);

  /* ====================== PAGE BACKGROUND ====================== */
  (function(){
    if (!document.getElementById('site-bg-wood')){
      var css = `
:root{ --wood-url: url('../img/wood.jpg'); }
html.bg-wood, body.bg-wood{
  background-image: linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)), var(--wood-url);
  background-size: cover; background-position: center; background-repeat: no-repeat; background-attachment: fixed; min-height:100%;
}
body.bg-wood #bubble,
body.bg-wood .bubble-r-container,
body.bg-wood #page,
body.bg-wood .page,
body.bg-wood #root,
body.bg-wood [data-visual-element="Page"],
body.bg-wood .bubble-element.Page{
  background: transparent !important;
}
html.no-wood, body.no-wood{ background: none !important; }

body.bg-wood .modal-backdrop,
body.bg-wood .bubble-overlay,
body.bg-wood .overlay,
body.bg-wood .popup-dim,
body.bg-wood .s-dim,
body.bg-wood .dim,
body.bg-wood .backdrop{
  background: transparent !important;
  backdrop-filter: none !important;
  filter: none !important;
}
body.bg-wood .blur,
body.bg-wood .blurry,
body.bg-wood .frost,
body.bg-wood .frosted,
body.bg-wood [class*="blur"]{
  filter: none !important;
  backdrop-filter: none !important;
}
      `;
      var st = document.createElement('style');
      st.id = 'site-bg-wood';
      st.textContent = css;
      document.head.appendChild(st);
    }
    function addBG(){
      document.documentElement.classList.remove('no-wood');
      document.body.classList.remove('no-wood');
      document.documentElement.classList.add('bg-wood');
      document.body.classList.add('bg-wood');
    }
    function removeBG(){
      document.documentElement.classList.remove('bg-wood');
      document.body.classList.remove('bg-wood');
      document.documentElement.classList.add('no-wood');
      document.body.classList.add('no-wood');
    }
    window.PageBG = window.PageBG || { add: addBG, remove: removeBG };

    try { PageBG.add(); } catch(e){}

    (function keepBackgroundCrisp(){
      const SEL = '.modal-backdrop, .bubble-overlay, .overlay, .popup-dim, .s-dim, .dim, .backdrop';
      function undim(){
        if (!document.body.classList.contains('bg-wood')) return;
        document.querySelectorAll(SEL).forEach(el=>{
          el.style.background = 'transparent';
          el.style.backdropFilter = 'none';
          el.style.filter = 'none';
        });
      }
      const mo = new MutationObserver(undim);
      mo.observe(document.body, { childList:true, subtree:true, attributes:true, attributeFilter:['class','style'] });
      undim();
    })();

    function isShown(el){
      if (!el) return false;
      var cs = getComputedStyle(el);
      return cs.display !== 'none' && el.offsetWidth > 0 && el.offsetHeight > 0;
    }
    var targets = [ document.getElementById('group-joseki'), wrap ].filter(Boolean);
    if (targets.length){
      var mo2 = new MutationObserver(function(){
        for (var i=0;i<targets.length;i++){
          if (isShown(targets[i])) { try { PageBG.add(); } catch(e){} break; }
        }
      });
      targets.forEach(function(t){
        mo2.observe(t, { attributes:true, attributeFilter:['style','class','data-hidden'] });
      });
    }
  })();
  /* ==================== /PAGE BACKGROUND ==================== */

  /* ===== Remove duplicate description boxes & button rows (static page safety) ===== */
  (function dedupeUI(){
    function keepOnlyFirst(selector){
      const all = Array.from(document.querySelectorAll(selector));
      if (!all.length) return;
      let keeper = all.find(el => wrap.contains(el)) || all[0];
      all.forEach(el => { if (el !== keeper && el.parentNode) el.parentNode.removeChild(el); });
    }
    keepOnlyFirst('#desc-wrap');
    keepOnlyFirst('#joseki-ctrls');
  })();

  /* Description drag-to-scroll */
  (function(){
    var box = document.getElementById('desc-box');
    if (!box) return;
    let isDown=false, startY=0, startScroll=0;
    box.addEventListener('mousedown', (e) => {
      isDown = true; box.classList.add('grabbing'); startY = e.clientY; startScroll = box.scrollTop; e.preventDefault();
    });
    box.addEventListener('mousemove', (e) => { if (!isDown) return; const dy = e.clientY - startY; box.scrollTop = startScroll - dy; });
    ['mouseup','mouseleave'].forEach(ev => box.addEventListener(ev, () => { isDown=false; box.classList.remove('grabbing'); }));
    box.addEventListener('touchstart', (e) => { startY = e.touches[0].clientY; startScroll = box.scrollTop; }, {passive:true});
    box.addEventListener('touchmove',  (e) => { const dy = e.touches[0].clientY - startY; box.scrollTop = startScroll - dy; }, {passive:true});
  })();

  var SIZE = 19, B='B', W='W';
  // ===== shared preferences with settings page =====
  var STORAGE_KEY = 'go_prefs';
  var GoPrefs = (window.GoPrefs = window.GoPrefs || {});

  try {
    Object.assign(GoPrefs, JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}') || {});
  } catch (e) {}

  // No more josekiZoom preference here – only sound + highlight
  if (typeof GoPrefs.soundOn       === 'undefined') GoPrefs.soundOn       = true;
  if (typeof GoPrefs.highlightLast === 'undefined') GoPrefs.highlightLast = true;

  // ---------- state ----------
  var board = new WGo.Board(mount, { size: SIZE });
  // Wood texture under the board (replaces old zoomLayer background)
  mount.style.backgroundImage = "url('../img/wood.jpg')";
  mount.style.backgroundSize = "cover";
  mount.style.backgroundPosition = "center";
  mount.style.backgroundRepeat = "no-repeat";

  var grid  = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null));
  var history = [];
  var current = 0;
  var turn    = B;  // side to move

  // Simple responsive sizing (no zoom, no fullscreen)
  function fitBoard(){
    var w = mount.clientWidth || 400;
    w = Math.floor(w);
    if (w % 2) w--;
    if (w <= 0) return;
    board.setWidth(w);
    mount.style.height = w + 'px';
  }
  window.addEventListener('resize', fitBoard);
  window.addEventListener('orientationchange', function(){ setTimeout(fitBoard, 200); });
  fitBoard();

  // SGF state
  var hasSGF = false, sgfRootSeq = null, currentNode = null;
  var rootLabels = [], rootNote = '', rootAB = [], rootAW = [];

// Free-play divergence
var freeMode = false, josekiAnchor = null, josekiAnchorIndex = 0;
  // ===== Favorites storage (shared with Practice List) =====
  var FAV_KEY = 'go_favorites';

  function favLineKey(line){
    var size = line.size || SIZE;
    var seq = (line.moves || []).map(function(m){
      return (m.color || 'B')[0] + ':' + m.x + ',' + m.y;
    }).join('|');
    return size + '|' + seq;
  }

  function favReadMap(){
    try {
      return JSON.parse(localStorage.getItem(FAV_KEY) || '{}') || {};
    } catch(e){
      return {};
    }
  }

  function favWriteMap(map){
    try {
      localStorage.setItem(FAV_KEY, JSON.stringify(map));
    } catch(e){}
  }

  function favIsSaved(line){
    var map = favReadMap();
    return !!map[favLineKey(line)];
  }

  function favAdd(line){
    var map = favReadMap();
    map[favLineKey(line)] = {
      size: line.size || SIZE,
      rootAB: Array.isArray(line.rootAB) ? line.rootAB : [],
      rootAW: Array.isArray(line.rootAW) ? line.rootAW : [],
      moves: (line.moves || []).map(function(p){
        return { x:p.x, y:p.y, color:p.color };
      })
    };
    favWriteMap(map);
  }

  // Build a favorite line from current node, respecting pass rules:
  // - up to 2 initial passes allowed if they are all same color as first stone move
  // - any later pass counts as "end"; favorite stops at last stone before that pass
  // Returns { size, rootAB, rootAW, moves[] } or null if not valid.
  function buildFavoriteLineFromNode(currentNode){
    if (!hasSGF || !currentNode || freeMode) return null;

    // If we are on a pass node, treat the favorite as ending at the last stone before it
    var isPassHere = !!nodePassColor(currentNode);
    var endNode = currentNode;

    if (isPassHere){
      var pathAll = pathTo(currentNode);
      var lastMoveNode = null;
      for (var i = 0; i < pathAll.length; i++){
        if (nodeMoveXY(pathAll[i])) lastMoveNode = pathAll[i];
      }
      if (!lastMoveNode) return null; // only passes, nothing to favorite
      endNode = lastMoveNode;
    }

    var path = pathTo(endNode);

    // Find first stone move, count initial passes before it
    var firstMoveIndex = -1;
    var firstMoveColor = null;
    var initialPassCount = 0;
    var initialPassColors = [];

    for (var idx = 0; idx < path.length; idx++){
      var n = path[idx];
      var mv = nodeMoveXY(n);
      if (mv){
        firstMoveIndex = idx;
        firstMoveColor = mv.color;
        break;
      }
      var pc = nodePassColor(n);
      if (pc){
        initialPassCount++;
        initialPassColors.push(pc);
      }
    }

    if (firstMoveIndex === -1) return null;            // no stones at all
    if (initialPassCount > 2) return null;             // too many initial passes

    // all initial passes must match the first stone's color
    for (var t = 0; t < initialPassColors.length; t++){
      if (initialPassColors[t] !== firstMoveColor) return null;
    }

    // Collect all stone moves from firstMoveIndex up to endNode (stones only)
    var moves = [];
    for (var k = firstMoveIndex; k < path.length; k++){
      var n2 = path[k];
      var mv2 = nodeMoveXY(n2);
      if (mv2){
        moves.push({ x: mv2.x, y: mv2.y, color: mv2.color });
      }
    }

    if (!moves.length) return null;

    return {
      size: SIZE,
      rootAB: rootAB.slice(),
      rootAW: rootAW.slice(),
      moves: moves
    };
  }

  // Decide if the current joseki position should offer "Add to favorites"
  function getCurrentFavoriteLineCandidate(){
    if (!hasSGF || freeMode || !currentNode) return null;

    var isPassHere = !!nodePassColor(currentNode);

    // If we are on a pass node, that itself counts as "end of line"
    if (isPassHere){
      return buildFavoriteLineFromNode(currentNode);
    }

    // Otherwise, only allow favorites at leaf positions that have no further SGF moves or passes
    var nextStones = getNextCandidates(currentNode) || [];
    var nextPasses = getPassCandidates(currentNode) || [];

    if (nextStones.length > 0 || nextPasses.length > 0){
      // There is still at least one SGF continuation (stone or pass) → no favorite button yet
      return null;
    }

    return buildFavoriteLineFromNode(currentNode);
  }


  // Sound preference (initial from prefs)
  var soundEnabled = !!GoPrefs.soundOn;
  function setSoundEnabled(v){
    soundEnabled = !!v;
  }

  // Highlight last move (initial from prefs)
  var highlightLastEnabled = !!GoPrefs.highlightLast;

  // Pass button helpers
  var passBtn = null;
  function getPassBtn(){
    if (!passBtn) passBtn = document.getElementById('jbtnPass');
    return passBtn;
  }
  function setPassEnabled(on){
    var b = getPassBtn();
    if (!b) return;
    b.disabled = !on;
  }

  function addLB(x,y,text){ board.addObject({ x:x, y:y, type:'LB', text:text }); }

function redraw(){
  board.removeAllObjects();

  // Stones
  for (var y=0; y<SIZE; y++){
    for (var x=0; x<SIZE; x++){
      var v = grid[y][x];
      if (v === B) board.addObject({ x:x, y:y, c: WGo.B });
      else if (v === W) board.addObject({ x:x, y:y, c: WGo.W });
    }
  }

  // Labels and candidate markers – ONLY when NOT in free play mode
  if (hasSGF && !freeMode){
    var allCand  = getNextCandidates(currentNode || null) || [];
    var turnCand = allCand.filter(function(c){ return c.color === turn; });

    // Map of all candidate intersections (any color)
    var candMap = {};
    for (var i=0; i<allCand.length; i++){
      var key = allCand[i].xy.x + ':' + allCand[i].xy.y;
      candMap[key] = true;
    }

    // Static LB labels, but skip those on any candidate intersection
    var nodeLabels = [];
    if (!currentNode) nodeLabels = rootLabels;
    else if (currentNode.LB_) nodeLabels = currentNode.LB_;

    for (var j=0; j<nodeLabels.length; j++){
      var lab  = nodeLabels[j];
      var lkey = lab.x + ':' + lab.y;
      if (!candMap[lkey]) addLB(lab.x, lab.y, lab.text);
    }

    // Dynamic candidate letters only for side to move
    for (var k=0; k<turnCand.length; k++){
      addLB(turnCand[k].xy.x, turnCand[k].xy.y, String.fromCharCode(65 + k));
    }
  }
  // else: hasSGF && freeMode → no SGF labels at all (clean board)

  // Last-move highlighting still works in both modes
  if (highlightLastEnabled && current > 0){
    var lm = history[current - 1];
    if (lm) board.addObject({ x: lm.x, y: lm.y, type: 'CR' });
  }
}


   var descEl = document.getElementById('descText');

  // Small helper: safely escape SGF comments for innerHTML
  function escHTML(s){
    if (s == null) return '';
    return String(s).replace(/[&<>"]/g, function(ch){
      if (ch === '&') return '&amp;';
      if (ch === '<') return '&lt;';
      if (ch === '>') return '&gt;';
      if (ch === '"') return '&quot;';
      return ch;
    });
  }

   function updateDesc(){
    if (!descEl) return;

    // Free-play description (unchanged)
    if (freeMode){
      descEl.innerHTML =
        '<div style="font-weight:600;margin-bottom:8px;">Free Play Mode</div>' +
        '<button id="backToJosekiBtn" ' +
          'style="display:inline-block;padding:8px 12px;border-radius:8px;' +
                 'border:1px solid #ccc;background:#fff;' +
                 'box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer;">' +
          'Back to Joseki' +
        '</button>';

      var btn = document.getElementById('backToJosekiBtn');
      if (btn){
        btn.onclick = function(){
          freeMode = false;
          currentNode = josekiAnchor;
          buildPositionTo(currentNode);
        };
      }
      return;
    }

    // No SGF loaded → nothing to show
    if (!hasSGF){
      descEl.textContent = '';
      return;
    }

    // Base comment text (root comment or node comment)
    var baseText = '';
    if (!currentNode){
      baseText = rootNote || '';
    } else {
      baseText = currentNode.comment || '';
    }

    // Check if this position is a favorite endpoint according to pass rules
    var favLine = getCurrentFavoriteLineCandidate();
    var html = '';

    if (baseText && String(baseText).trim().length){
      html += '<div>' + escHTML(baseText) + '</div>';
    }

    if (favLine){
      var already = favIsSaved(favLine);
      if (already){
        html += '<div style="margin-top:10px;font-weight:600;color:#047857;">' +
                  'Already in your favorites' +
                '</div>';
      } else {
        html += '<div style="margin-top:10px;">' +
                  '<button id="addFavBtn" ' +
                    'style="display:inline-block;padding:8px 12px;border-radius:8px;' +
                           'border:1px solid #ccc;background:#fff;' +
                           'box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer;">' +
                    'Add this joseki to Favorites' +
                  '</button>' +
                '</div>';
      }
    }

    if (!html){
      html = '&nbsp;';
    }

    descEl.innerHTML = html;

    // Wire up the "Add to favorites" button if present
    if (favLine && !favIsSaved(favLine)){
      var addBtn = document.getElementById('addFavBtn');
      if (addBtn){
        addBtn.addEventListener('click', function(){
          favAdd(favLine);
          addBtn.disabled = true;
          addBtn.textContent = 'Added to Favorites';
        });
      }
    }
  }


  function neighbors(x,y){ var ns=[]; if(x>0)ns.push([x-1,y]); if(x<SIZE-1)ns.push([x+1,y]); if(y>0)ns.push([x,y-1]); if(y<SIZE-1)ns.push([x,y+1]); return ns; }
  function groupAndLiberties(x,y){
    var color=grid[y][x]; if(!color) return {stones:[],liberties:0};
    var st=[[x,y]], seen={}, stones=[], libs=0;
    while(st.length){
      var p=st.pop(), cx=p[0], cy=p[1], k=cx+':'+cy; if(seen[k]) continue;
      seen[k]=1; stones.push([cx,cy]);
      var ns=neighbors(cx,cy);
      for(var i=0;i<ns.length;i++){
        var nx=ns[i][0], ny=ns[i][1], v=grid[ny][nx];
        if(v===null) libs++; else if(v===color && !seen[nx+':'+ny]) st.push([nx,ny]);
      }
    }
    return {stones:stones, liberties:libs};
  }
  function attemptPlay(x,y,color){
    if(grid[y][x]!==null) return {ok:false, captures:[]};
    grid[y][x]=color;
    var opp=(color===B?W:B), captures=[], ns=neighbors(x,y);
    for(var i=0;i<ns.length;i++){
      var nx=ns[i][0], ny=ns[i][1];
      if(grid[ny][nx]===opp){
        var g=groupAndLiberties(nx,ny);
        if(g.liberties===0){
          for(var j=0;j<g.stones.length;j++){ var s=g.stones[j]; grid[s[1]][s[0]]=null; captures.push([s[0],s[1]]); }
        }
      }
    }
    var self=groupAndLiberties(x,y);
    if(captures.length===0 && self.liberties===0){ grid[y][x]=null; return {ok:false, captures:[]}; }
    return {ok:true, captures:captures};
  }

  function rebuildFromHistory(){
    if (current < 0) current = 0;
    if (current > history.length) current = history.length;

    for (var y = 0; y < SIZE; y++) grid[y].fill(null);

    if (hasSGF){
      for (var i = 0; i < rootAB.length; i++){
        var p = rootAB[i];
        grid[p.y][p.x] = B;
      }
      for (var j = 0; j < rootAW.length; j++){
        var q = rootAW[j];
        grid[q.y][q.x] = W;
      }
    }

    var lastMove = null;
    for (var k = 0; k < current; k++){
      var m = history[k];
      attemptPlay(m.x, m.y, m.color);
      lastMove = m;
    }

    if (!lastMove){
      turn = B;
    } else {
      turn = (lastMove.color === B ? W : B);
    }

    redraw();
    updateDesc();
    updatePassButtonState();
  }

  // ---------- SGF parsing ----------
  function readBracket(str, i){
    var out='', k=i;
    while(k<str.length){
      var ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; }
      if(ch===']') break; out+=ch;
    }
    return { text: out, next: k };
  }
  function parseGameTree(str, i){
    var seq=[], node=null;
    if (str[i] !== '(') return { seq:[], next:i };
    i++;
    while (i<str.length){
      var ch=str[i];
      if (ch===';'){ node={}; seq.push(node); i++; }
      else if ((ch>='A'&&ch<='Z')||(ch>='a'&&ch<='z')){
        var key=''; while(i<str.length){ var c=str[i]; if((c>='A'&&c<='Z')||(c>='a'&&c<='z')){ key+=c; i++; } else break; }
        var vals=[]; while(i<str.length && str[i]==='['){ var r=readBracket(str,i+1); vals.push(r.text); i=r.next; }
        if(!node){ node={}; seq.push(node); }
        node[key] = vals.length>1 ? vals : vals[0];
      }
      else if (ch==='('){
        var child = parseGameTree(str, i);
        i = child.next;
        if (seq.length){
          var parent = seq[seq.length-1];
          parent.variations = parent.variations || [];
          parent.variations.push(child.seq);
        }
      }
      else if (ch===')'){ i++; break; }
      else { i++; }
    }
    return { seq: seq, next: i };
  }
  function sgfCoordToXY(s){
    if(!s||s.length<2) return null;
    var x=s.charCodeAt(0)-97, y=s.charCodeAt(1)-97;
    if(x<0||y<0||x>=SIZE||y>=SIZE) return null;
    return {x:x,y:y};
  }
  function parseLB(lb){
    var out=[], list = Array.isArray(lb) ? lb : (lb ? [lb] : []);
    for (var i=0;i<list.length;i++){
      var t=list[i]||'', colon=t.indexOf(':');
      var a=t.substring(0, colon>=0?colon:t.length);
      var label = colon>=0 ? t.substring(colon+1) : '•';
      var xy=sgfCoordToXY(a); if(xy) out.push({x:xy.x,y:xy.y,text:label});
    }
    return out;
  }
  function listCoords(prop){
    var out=[], list = Array.isArray(prop)? prop : (prop?[prop]:[]);
    for (var i=0;i<list.length;i++){ var xy=sgfCoordToXY(list[i]); if(xy) out.push(xy); }
    return out;
  }
  function linkify(seq, parent){
    for (var i=0;i<seq.length;i++){
      var n=seq[i];
      n.prev = (i===0? parent : seq[i-1]);
      n.next = (i<seq.length-1? seq[i+1] : null);
      if (n.C) n.comment = Array.isArray(n.C)? n.C[0] : n.C;
      if (n.LB) n.LB_ = parseLB(n.LB);
      if (n.AB) n.AB_ = listCoords(n.AB);
      if (n.AW) n.AW_ = listCoords(n.AW);
      if (n.variations && n.variations.length){
        for (var v=0; v<n.variations.length; v++){
          var childSeq = n.variations[v];
          if (childSeq && childSeq.length) linkify(childSeq, n);
        }
      }
    }
  }
  function extractRoot(seq){
    rootLabels = []; rootNote = ''; rootAB = []; rootAW = [];
    if (!seq || !seq.length) return;
    var n = seq[0];
    if (n && n.LB_) rootLabels = n.LB_;
    if (n && n.comment) rootNote = n.comment;
    if (n && n.AB_) rootAB = n.AB_;
    if (n && n.AW_) rootAW = n.AW_;
  }
  function nodeHasMove(n){ return !!(n && (n.B || n.W)); }
  function nodeMoveXY(n){
    var s = n.B || n.W; var xy = sgfCoordToXY(s);
    return xy ? {x:xy.x, y:xy.y, color: (n.B?B:W)} : null;
  }
  function candidatesDedup(list){
    var seen={}, out=[];
    for (var i=0;i<list.length;i++){
      var mv=list[i]; var key = mv.xy.x+':'+mv.xy.y+':'+mv.color;
      if (!seen[key]){ seen[key]=1; out.push(mv); }
    }
    return out;
  }

  // Helpers that are aware of pass nodes (B[] / W[])

  function nodeHasColorProp(n){
    return !!(n && (typeof n.B !== 'undefined' || typeof n.W !== 'undefined'));
  }

  function nodePassColor(n){
    if (!n) return null;
    if (typeof n.B !== 'undefined'){
      var v = Array.isArray(n.B) ? n.B[0] : n.B;
      if (v === '') return B;
    }
    if (typeof n.W !== 'undefined'){
      var v2 = Array.isArray(n.W) ? n.W[0] : n.W;
      if (v2 === '') return W;
    }
    return null;
  }

  function getRootCandidates(){
    var out=[];
    if (!sgfRootSeq || !sgfRootSeq.length) return out;
    var r = sgfRootSeq[0];

    var n = r;
    while(n && !nodeHasMove(n)) n = n.next;
    if (n && nodeHasMove(n)){ var mv = nodeMoveXY(n); if (mv) out.push({node:n, xy:{x:mv.x,y:mv.y}, color:mv.color}); }

    if (r && r.variations && r.variations.length){
      for (var v=0; v<r.variations.length; v++){
        var seq = r.variations[v];
        if (seq && seq.length){
          var first = seq[0];
          var m = first;
          while(m && !nodeHasMove(m)) m = m.next;
          if (m && nodeHasMove(m)){ var mv2=nodeMoveXY(m); if (mv2) out.push({node:m, xy:{x:mv2.x,y:mv2.y}, color:mv2.color}); }
        }
      }
    }
    return candidatesDedup(out);
  }

  function getNextCandidates(node){
    if (!node) return getRootCandidates();
    var arr=[];
    if (node.next){
      var n=node.next; while(n && !nodeHasMove(n)) n=n.next;
      if (n && nodeHasMove(n)){ var mv=nodeMoveXY(n); if (mv) arr.push({node:n, xy:{x:mv.x,y:mv.y}, color:mv.color}); }
    }
    if (node.variations && node.variations.length){
      for (var v=0; v<node.variations.length; v++){
        var seq = node.variations[v];
        if (seq && seq.length){
          var m = seq[0];
          while(m && !nodeHasMove(m)) m = m.next;
          if (m && nodeHasMove(m)){ var mv2=nodeMoveXY(m); if (mv2) arr.push({node:m, xy:{x:mv2.x,y:mv2.y}, color:mv2.color}); }
        }
      }
    }
    return candidatesDedup(arr);
  }

  // Color nodes for "next position" regardless of whether it is a pass or a board move
  function getNextColorNodes(node){
    var arr = [];
    if (!sgfRootSeq || !sgfRootSeq.length) return arr;

    if (!node){
      var r = sgfRootSeq[0];
      var n = r;
      while (n && !nodeHasColorProp(n)) n = n.next;
      if (n && nodeHasColorProp(n)) arr.push(n);

      if (r.variations && r.variations.length){
        for (var v = 0; v < r.variations.length; v++){
          var seq = r.variations[v];
          if (seq && seq.length){
            var m = seq[0];
            while (m && !nodeHasColorProp(m)) m = m.next;
            if (m && nodeHasColorProp(m)) arr.push(m);
          }
        }
      }
      return arr;
    }

    if (node.next){
      var n2 = node.next;
      while (n2 && !nodeHasColorProp(n2)) n2 = n2.next;
      if (n2 && nodeHasColorProp(n2)) arr.push(n2);
    }
    if (node.variations && node.variations.length){
      for (var vv = 0; vv < node.variations.length; vv++){
        var seq2 = node.variations[vv];
        if (seq2 && seq2.length){
          var m2 = seq2[0];
          while (m2 && !nodeHasColorProp(m2)) m2 = m2.next;
          if (m2 && nodeHasColorProp(m2)) arr.push(m2);
        }
      }
    }
    return arr;
  }

  // All pass-nodes reachable as immediate next positions from the given node (or root)
  function getPassCandidates(node){
    var colorNodes = getNextColorNodes(node || null);
    var out = [];
    for (var i = 0; i < colorNodes.length; i++){
      var c = nodePassColor(colorNodes[i]);
      if (c){
        out.push({ node: colorNodes[i], color: c });
      }
    }
    return out;
  }

  // Only candidates for current side to move (board moves, not passes)
  function getTurnCandidates(node){
    var all = getNextCandidates(node);
    if (!all || !all.length) return [];
    return all.filter(function(c){ return c.color === turn; });
  }

  // Decide when the Pass button should be enabled:
  // enabled only if there is at least one SGF pass node (B[] / W[]) for the current side to move.
  function computePassAvailability(){
    if (!hasSGF || freeMode) return false;

    var passList = getPassCandidates(currentNode || null);
    if (!passList || !passList.length) return false;

    for (var i = 0; i < passList.length; i++){
      if (passList[i].color === turn) return true;
    }
    return false;
  }

  function updatePassButtonState(){
    setPassEnabled(computePassAvailability());
  }

  function pathTo(node){
    var out=[]; var n=node;
    while(n){ out.push(n); n=n.prev; }
    out.reverse();
    return out;
  }

  // Apply a single SGF node (including pass) to the board; returns the move color if
  // this node represents a move or pass, otherwise null.
  function applyNodeToBoard(nd){
    if (!nd) return null;
    var colorProp, color;
    if (typeof nd.B !== 'undefined'){
      colorProp = nd.B;
      color = B;
    } else if (typeof nd.W !== 'undefined'){
      colorProp = nd.W;
      color = W;
    } else {
      return null; // no move/pass
    }

    var str;
    if (Array.isArray(colorProp)) str = colorProp[0];
    else str = colorProp;

    if (str === '' || str == null){
      // Pure pass: change only the side to move, no stones
      return color;
    }

    var xy = sgfCoordToXY(str);
    if (!xy) return color; // treat as "move" for color progression, even if coord is weird

    var r = attemptPlay(xy.x, xy.y, color);
    if (r.ok){
      history.push({ x: xy.x, y: xy.y, color: color, captures: r.captures });
      return color;
    }
    return color;
  }

  function buildPositionTo(node){
    for (var y=0;y<SIZE;y++) grid[y].fill(null);
    history.length = 0;

    for (var i=0;i<rootAB.length;i++){ var p=rootAB[i]; grid[p.y][p.x]=B; }
    for (var j=0;j<rootAW.length;j++){ var q=rootAW[j]; grid[q.y][q.x]=W; }

    if (!node){
      current = 0;
      turn = B;
      redraw();
      updateDesc();
      updatePassButtonState();
      return;
    }

    var path = pathTo(node);
    var lastColor = null;

    for (var k=0;k<path.length;k++){
      var nd = path[k];
      if (nd.AB_) for (var a=0;a<nd.AB_.length;a++){ var pb=nd.AB_[a]; grid[pb.y][pb.x]=B; }
      if (nd.AW_) for (var b=0;b<nd.AW_.length;b++){ var pw=nd.AW_[b]; grid[pw.y][pw.x]=W; }

      var c = applyNodeToBoard(nd);
      if (c) lastColor = c;
    }

    current = history.length;

    if (!lastColor){
      turn = B;
    } else {
      turn = (lastColor === B ? W : B);
    }

    redraw();
    updateDesc();
    updatePassButtonState();
  }

  function gotoPrev (){ if (!currentNode) return; currentNode = currentNode.prev || null; buildPositionTo(currentNode); }
  function gotoNext (){ var cand = getNextCandidates(currentNode); if (!cand.length) return; currentNode = cand[0].node; buildPositionTo(currentNode); }

  // No zoom logic in click handler anymore
  board.addEventListener('click', function(x,y){
    if (hasSGF && !freeMode){
      var opts = getTurnCandidates(currentNode); // filtered by turn
      for (var i=0;i<opts.length;i++){
        if (opts[i].xy.x===x && opts[i].xy.y===y){
          currentNode = opts[i].node;
          buildPositionTo(currentNode);
          try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
          return;
        }
      }
  if (grid[y][x] !== null) return;
  freeMode = true;
  josekiAnchor = currentNode;
  josekiAnchorIndex = current;   // how many moves were on the board when we diverged
}


    if (current < history.length) history.splice(current);
    var r = attemptPlay(x,y,turn);
    if(!r.ok) return;
    history.push({ x:x, y:y, color: turn, captures: r.captures });
    current = history.length;
    turn = (turn===B?W:B);
    redraw();
    updateDesc();
    updatePassButtonState();
    try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
  });

  // ---------- controls ----------
  function hook(id, fn){
    var el = document.getElementById(id);
    if (el) el.addEventListener('click', fn);
    else setTimeout(function(){ hook(id, fn); }, 50);
  }

hook('jbtnBack', function(){
  if (hasSGF && !freeMode) {
    // Normal joseki navigation
    gotoPrev();
  } else if (current > 0) {
    // Free mode or no SGF: step back through history
    current--;
    rebuildFromHistory();

    // If we were in free mode and have undone all free moves,
    // snap back to the joseki branch (same as "Back to Joseki").
    if (hasSGF && freeMode && current <= josekiAnchorIndex) {
      freeMode = false;
      currentNode = josekiAnchor;
      buildPositionTo(currentNode);
    }
  }
});


  hook('jbtnForward', function(){
    if (hasSGF && !freeMode) {
      gotoNext();
    } else if (current<history.length){
      current++;
      rebuildFromHistory();
    }
  });

  // Pass: follow an SGF pass node (B[] / W[]) for the current side to move.
  hook('jbtnPass', function(){
    if (!hasSGF || freeMode) return;

    var passList = getPassCandidates(currentNode || null);
    if (!passList || !passList.length) return;

    var chosen = null;
    for (var i = 0; i < passList.length; i++){
      if (passList[i].color === turn){
        chosen = passList[i].node;
        break;
      }
    }
    if (!chosen) return;

    currentNode = chosen;
    buildPositionTo(currentNode);
    try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
  });

  hook('jbtnReset',   function(){
    if (hasSGF) {
      freeMode=false; josekiAnchor=null; currentNode=null;
      buildPositionTo(null);
    } else {
      current=0;
      rebuildFromHistory();
    }
  });

  // ====== In-app "Back to menu" dialog ======
  var menuConfirmOverlay = document.getElementById('menu-confirm-overlay');
  var menuConfirmCancel  = document.getElementById('menuConfirmCancel');
  var menuConfirmOk      = document.getElementById('menuConfirmOk');

  function closeMenuConfirm(){
    if (!menuConfirmOverlay) return;
    menuConfirmOverlay.classList.remove('is-open');
  }

  if (menuConfirmOverlay){
    menuConfirmOverlay.addEventListener('click', function(e){
      if (e.target === menuConfirmOverlay) {
        closeMenuConfirm();
      }
    });
  }

  if (menuConfirmCancel){
    menuConfirmCancel.addEventListener('click', function(e){
      e.stopPropagation();
      closeMenuConfirm();
    });
  }

  if (menuConfirmOk){
    menuConfirmOk.addEventListener('click', function(e){
      e.stopPropagation();
      closeMenuConfirm();
      window.location.href = MENU_URL;
    });
  }

  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape') {
      closeMenuConfirm();
    }
  });

  function openMenuWithConfirm(){
    if (menuConfirmOverlay){
      menuConfirmOverlay.classList.add('is-open');
    } else {
      window.location.href = MENU_URL;
    }
  }

  hook('jbtnMenu', openMenuWithConfirm);

  // public APIs
  window.JosekiBoard = window.JosekiBoard || {};
  window.JosekiBoard.reset = function(){
    freeMode = false; josekiAnchor = null; currentNode = null; current = 0; history.length = 0;
    buildPositionTo(null);
    try { document.getElementById('desc-box').scrollTop = 0; } catch(e){}
    try { window.dispatchEvent(new Event('resize')); } catch(e){}
    try { if (window.PageBG && typeof PageBG.add === 'function') PageBG.add(); } catch(e){}
  };

  window.JosekiSound = {
    isEnabled: function(){ return soundEnabled; },
    setEnabled: function(v){ setSoundEnabled(v); }
  };

  window.JosekiHighlight = {
    isEnabled: function(){ return highlightLastEnabled; },
    setEnabled: function(v){ highlightLastEnabled = !!v; redraw(); }
  };

  // No-op stub so settings page won't break if it calls JosekiZoom here.
  window.JosekiZoom = {
    isEnabled: function(){ return false; },
    setEnabled: function(){},
    resetView: function(){},
    isFullscreen: function(){ return false; }
  };

  // ---------- load SGF (local file) ----------
  var SGF_URL = "../sgf/library-1.sgf";

  function loadSGFText(txt){
    try{
      if (txt.charCodeAt && txt.charCodeAt(0)===0xFEFF) txt = txt.slice(1);
      var parsed = parseGameTree(txt, txt.indexOf('('));
      var rootSeq = parsed.seq && parsed.seq.length ? parsed.seq : [];
      if (!rootSeq.length){ hasSGF=false; freeMode=false; redraw(); updateDesc(); updatePassButtonState(); return; }
      linkify(rootSeq, null);
      sgfRootSeq = rootSeq;
      extractRoot(rootSeq);
      hasSGF = true;
      freeMode = false;
      josekiAnchor = null;
      currentNode = null;
      buildPositionTo(null);
      fitBoard();
      try { if (window.PageBG && typeof PageBG.add === 'function') PageBG.add(); } catch(e){}
    }catch(e){
      console.error('SGF parse error:', e);
      hasSGF=false; freeMode=false;
      redraw();
      updateDesc();
      updatePassButtonState();
    }
  }
  function fetchAndLoadSGF(url){
    fetch(url, { cache:'no-cache' })
      .then(function(r){ return r.text(); })
      .then(function(t){ loadSGFText(t); })
      .catch(function(err){ console.error('SGF load failed:', err); });
  }
  fetchAndLoadSGF(SGF_URL);

})(); // mountBoard
} // _mainBoardMounted
</script>

</body>
</html>
