<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    min-height: 100%;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }

  /* Page wood background + centering */
  body {
    background-image:
      linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)),
      url('../img/wood.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-attachment: fixed;

    /* center the whole joseki block */
    display: flex;
    align-items: center;      /* vertical center */
    justify-content: center;  /* horizontal center */
    padding: 16px 0;
    box-sizing: border-box;
  }

  /* Simple wrapper inside the centered body */
  #page-wrap {
    width: 100%;
    max-width: 720px;
    margin: 0 auto;
  }

  /* Board wrapper */
  #go-board-wrap {
    width: 100%;
    max-width: 720px;
    margin: 0 auto;
    box-sizing: border-box;
  }

  @media (max-width: 480px){
    #go-board-wrap { padding:8px 12px 0; }
  }

  #go-board-wrap #desc-wrap{ max-width:720px; width:100%; }
  #desc-box::-webkit-scrollbar { display: none; }
  #desc-box.grabbing { cursor: grabbing; }

  .j-ctrls{
    width:100%; max-width:720px; margin:10px auto 0;
    padding:8px 12px; gap:10px; justify-content:center; flex-wrap:wrap;
    display:flex; box-sizing:border-box;
  }
  .jbtn{
    padding:12px 16px; border-radius:12px; border:1px solid #cbd5e1;
    background:#fff; font-weight:800; font-size:15px; color:#0f172a;
    cursor:pointer; box-shadow:0 2px 8px rgba(15,23,42,.06);
    -webkit-tap-highlight-color: transparent;
  }
  .jbtn:active{ transform:translateY(1px); }
  .jbtn-alt{ background:#e7f0ff; color:#0b4aa2; border-color:#a7c1ff; }
  .jbtn-strong{ background:#111827; color:#fff; border-color:#111827; }

  /* Board drop shadow */
  #go-board{
    box-shadow:
      0 18px 40px rgba(0,0,0,.32),
      0 6px 16px rgba(0,0,0,.22) !important;
    border-radius: 10px;
  }
</style>

<style>
  /* Make the description box's width include its border so edges align */
  #desc-box { box-sizing: border-box; }

  /* Let the button row use the full width (no side padding),
     so it lines up exactly with #desc-box */
  #joseki-ctrls{
    padding-left: 0 !important;
    padding-right: 0 !important;
  }

  /* Keep one-line layout while allowing each button to stretch evenly */
  #joseki-ctrls .jbtn,
  #joseki-ctrls .jbtn-strong,
  #joseki-ctrls .jbtn-alt{
    flex: 1 1 0;
    min-width: 0;
    white-space: nowrap;
  }
</style>

<style>
  /* Joseki Board buttons – same wood style as Practice Board */
  #joseki-ctrls{
    max-width: 720px;
    width: 100%;
    box-sizing: border-box;
    margin: 14px auto 0;
    padding: 0 12px 18px;
    display: flex;
    justify-content: center;
    gap: 12px;
    flex-wrap: wrap;
  }

  #joseki-ctrls .jbtn,
  #joseki-ctrls .jbtn-strong,
  #joseki-ctrls .jbtn-alt{
    position: relative;
    min-width: 90px;
    padding: 8px 24px;

    /* same layout idea as Practice buttons */
    flex: 1 1 0;
    display: flex;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    text-align: center;

    border-radius: 10px;
    border: 1px solid rgba(255,255,255,.40);

    font-size: 16px;
    font-weight: 800;
    line-height: 1.1;
    color: #fff3cf;
    text-shadow: 0 1px 0 rgba(120,60,20,.7);
    cursor: pointer;

    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    -webkit-tap-highlight-color: transparent;

    background-image:
      linear-gradient(
        to bottom,
        rgba(255,255,255,.12),
        rgba(255,255,255,.03) 38%,
        rgba(0,0,0,.14) 100%
      ),
      url('../img/wood.jpg');
    background-size: 100% 100%, cover;
    background-position: center;
    background-repeat: no-repeat;

    filter: brightness(1.08) saturate(.96);

    box-shadow:
      0 3px 0 rgba(133,74,26,.85),
      0 8px 14px rgba(0,0,0,.45);

    transition:
      transform .08s ease-out,
      box-shadow .08s ease-out,
      filter .12s ease-out;
  }

  #joseki-ctrls .jbtn:hover,
  #joseki-ctrls .jbtn-strong:hover,
  #joseki-ctrls .jbtn-alt:hover{
    filter: brightness(1.12) saturate(.98);
    transform: translateY(-1px);
    box-shadow:
      0 4px 0 rgba(133,74,26,.9),
      0 10px 16px rgba(0,0,0,.48);
  }

  #joseki-ctrls .jbtn:active,
  #joseki-ctrls .jbtn-strong:active,
  #joseki-ctrls .jbtn-alt:active{
    filter: brightness(.97) saturate(.96);
    transform: translateY(2px);
    box-shadow:
      0 1px 0 rgba(120,60,20,.9),
      0 4px 8px rgba(0,0,0,.55);
  }

  #joseki-ctrls .jbtn:focus-visible,
  #joseki-ctrls .jbtn-strong:focus-visible,
  #joseki-ctrls .jbtn-alt:focus-visible{
    outline: 2px solid rgba(255,255,255,.9);
    outline-offset: 2px;
  }

  /* Disabled state – match Practice behavior */
  #joseki-ctrls .jbtn[disabled],
  #joseki-ctrls .jbtn-strong[disabled],
  #joseki-ctrls .jbtn-alt[disabled]{
    opacity: .45;
    cursor: default;
    box-shadow: none;
    transform: none;
    filter: brightness(1) saturate(.9);
  }
</style>

<style>
  /* In-app "Back to menu" dialog – same layout as Practice Board notifications */

  #menu-confirm-overlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.55);
    z-index:99999;
    -webkit-tap-highlight-color:transparent;
  }
  #menu-confirm-overlay.is-open{
    display:flex;
  }

  .menu-confirm-title{
    font-size:18px;
    font-weight:800;
    margin-bottom:8px;
  }
  .menu-confirm-text{
    margin-bottom:14px;
  }
  .menu-confirm-actions{
    display:flex;
    gap:10px;
    justify-content:center;
    flex-wrap:wrap;
    margin-top:10px;
  }

  .notif-card{
    position:relative;
    z-index:1;
    border-radius:10px;
    border:1px solid #e2e8f0;
    box-shadow:0 12px 28px rgba(15,23,42,.18);
    padding:16px;
    text-align:center;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    color:#fff3cf;
    background-image:
      linear-gradient(
        to bottom,
        rgba(0,0,0,.10),
        rgba(0,0,0,.25)
      ),
      url('../img/notification.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  .notif-card > div{
    color:inherit !important;
  }

  .notif-actions{
    margin-top:10px;
    display:flex;
    gap:10px;
    justify-content:center;
    flex-wrap:wrap;
  }

  .notif-actions .pbtn,
  .notif-actions .pbtn-strong,
  .notif-actions .pbtn-alt{
    position:relative;
    min-width:90px;
    padding:8px 24px;
    flex:1 1 0;
    display:flex;
    align-items:center;
    justify-content:center;
    box-sizing:border-box;
    text-align:center;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.40);
    font-size:16px;
    font-weight:800;
    line-height:1.1;
    color:#fff3cf;
    text-shadow:0 1px 0 rgba(120,60,20,.7);
    cursor:pointer;
    user-select:none;
    -webkit-user-select:none;
    -moz-user-select:none;
    -ms-user-select:none;
    -webkit-tap-highlight-color:transparent;
    background-image:
      linear-gradient(
        to bottom,
        rgba(255,255,255,.12),
        rgba(255,255,255,.03) 38%,
        rgba(0,0,0,.14) 100%
      ),
      url('../img/wood.jpg');
    background-size:100% 100%, cover;
    background-position:center;
    background-repeat:no-repeat;
    filter:brightness(1.08) saturate(.96);
    box-shadow:
      0 3px 0 rgba(133,74,26,.85),
      0 8px 14px rgba(0,0,0,.45);
    transition:
      transform .08s ease-out,
      box-shadow .08s ease-out,
      filter .12s ease-out;
  }

  .notif-actions .pbtn:hover,
  .notif-actions .pbtn-strong:hover,
  .notif-actions .pbtn-alt:hover{
    filter:brightness(1.12) saturate(.98);
    transform:translateY(-1px);
    box-shadow:
      0 4px 0 rgba(133,74,26,.9),
      0 10px 16px rgba(0,0,0,.48);
  }

  .notif-actions .pbtn:active,
  .notif-actions .pbtn-strong:active,
  .notif-actions .pbtn-alt:active{
    filter:brightness(.97) saturate(.96);
    transform:translateY(2px);
    box-shadow:
      0 1px 0 rgba(120,60,20,.9),
      0 4px 8px rgba(0,0,0,.55);
  }

  .notif-actions .pbtn:focus-visible,
  .notif-actions .pbtn-strong:focus-visible,
  .notif-actions .pbtn-alt:focus-visible{
    outline:2px solid rgba(255,255,255,.9);
    outline-offset:2px;
  }
</style>

<!-- === Joseki fullscreen zoom overlay (similar to Practice Board) === -->
<style>
  #go-zoom-overlay-joseki{
    position:fixed;
    inset:0;
    z-index:99998;
    display:none;
    align-items:center;
    justify-content:center;
    background:transparent;
    -webkit-tap-highlight-color:transparent;
  }
  #go-zoom-stage-joseki{
    width:100vw;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    touch-action:none;
  }
  #go-zoom-exit-joseki{
    position:fixed;
    left:14px;
    bottom:24px;
    width:120px;
    height:80px;
    border-radius:9px;
    background:rgba(148,163,184,.35);
    border:1px solid rgba(148,163,184,.85);
    box-shadow:0 6px 16px rgba(0,0,0,.55);
    display:none;
    cursor:pointer;
    z-index:99999;
    backdrop-filter:blur(2px);
    -webkit-tap-highlight-color:transparent;
    color:#e5e7eb;
    font-size:18px;
    font-weight:600;
    line-height:80px;
    text-align:center;
  }
</style>

</head>
<body>

<div id="page-wrap">
  <!-- Joseki Board -->
  <div id="go-board-wrap">
    <!-- Board -->
    <div id="go-board"
         style="width:100%;border-radius:6px;overflow:hidden;box-shadow:0 1px 3px rgba(0,0,0,.08);"></div>

    <!-- Integrated description -->
    <div id="desc-wrap" style="width:100%;display:flex;justify-content:center;margin:10px auto 0;">
      <div id="desc-box"
           style="
             max-width:720px;width:100%;height:120px;
             padding:12px;border:1px solid #ddd;border-radius:8px;
             overflow-y:auto;-webkit-overflow-scrolling:touch;touch-action:pan-y;
             background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.06);
             line-height:1.6;font-size:15px;text-align:center;
             scrollbar-width:none;
             cursor:grab;">
        <div id="descText"></div>
      </div>
    </div>

    <!-- Buttons -->
    <div id="joseki-ctrls" class="j-ctrls">
      <button id="jbtnBack"    class="jbtn"             type="button">Back</button>
      <button id="jbtnForward" class="jbtn"             type="button">Next</button>
      <button id="jbtnPass"    class="jbtn"             type="button" disabled>Pass</button>
      <button id="jbtnMenu"    class="jbtn" type="button">Menu</button>
      <button id="jbtnReset"   class="jbtn"    type="button">Reset</button>
    </div>
  </div>
</div>

<!-- In-app "Back to menu" confirmation – same layout as Practice Board -->
<div id="menu-confirm-overlay" aria-hidden="true">
  <div class="menu-confirm-dialog notif-card"
       style="width:min(86vw,420px);"
       role="dialog"
       aria-modal="true"
       aria-labelledby="menuConfirmTitle">
    <div class="menu-confirm-title" id="menuConfirmTitle">
      Back to menu?
    </div>
    <div class="menu-confirm-text">
      Do you want to leave this joseki view and return to the main menu?
    </div>
    <div class="menu-confirm-actions notif-actions">
      <button type="button" id="menuConfirmCancel" class="pbtn">No</button>
      <button type="button" id="menuConfirmOk" class="pbtn">Yes</button>
    </div>
  </div>
</div>

<!-- Joseki fullscreen zoom overlay -->
<div id="go-zoom-overlay-joseki" aria-hidden="true">
  <div id="go-zoom-stage-joseki"></div>
  <div id="go-zoom-exit-joseki">Zoom out</div>
</div>

<!-- Simple click sound (local file) -->
<script>
  window.StoneSFX = (function () {
    var audio = new Audio("../sound/click.mp3");
    audio.preload = "auto";
    return {
      play: function () {
        try {
          audio.currentTime = 0;
          audio.play();
        } catch (e) {}
      }
    };
  })();
</script>

<!-- Local WGo library -->
<script src="../lib/wgo.min.js"></script>

<script>
/* Prevent double-mount */
if (!window._mainBoardMounted) {
window._mainBoardMounted = true;

(function mountBoard(){
  if (!window.WGo) return setTimeout(mountBoard, 50);

  var wrap  = document.getElementById('go-board-wrap');
  var mount = document.getElementById('go-board');
  var MENU_URL = '../joseki-menu/index.html';

  if (!wrap || mount.clientWidth === 0) return setTimeout(mountBoard, 50);

  /* ====================== PAGE BACKGROUND ====================== */
  (function(){
    if (!document.getElementById('site-bg-wood')){
      var css = `
:root{ --wood-url: url('../img/wood.jpg'); }
html.bg-wood, body.bg-wood{
  background-image: linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)), var(--wood-url);
  background-size: cover; background-position: center; background-repeat: no-repeat; background-attachment: fixed; min-height:100%;
}
body.bg-wood #bubble,
body.bg-wood .bubble-r-container,
body.bg-wood #page,
body.bg-wood .page,
body.bg-wood #root,
body.bg-wood [data-visual-element="Page"],
body.bg-wood .bubble-element.Page{
  background: transparent !important;
}
html.no-wood, body.no-wood{ background: none !important; }

body.bg-wood .modal-backdrop,
body.bg-wood .bubble-overlay,
body.bg-wood .overlay,
body.bg-wood .popup-dim,
body.bg-wood .s-dim,
body.bg-wood .dim,
body.bg-wood .backdrop{
  background: transparent !important;
  backdrop-filter: none !important;
  filter: none !important;
}
body.bg-wood .blur,
body.bg-wood .blurry,
body.bg-wood .frost,
body.bg-wood .frosted,
body.bg-wood [class*="blur"]{
  filter: none !important;
  backdrop-filter: none !important;
}
      `;
      var st = document.createElement('style');
      st.id = 'site-bg-wood';
      st.textContent = css;
      document.head.appendChild(st);
    }
    function addBG(){
      document.documentElement.classList.remove('no-wood');
      document.body.classList.remove('no-wood');
      document.documentElement.classList.add('bg-wood');
      document.body.classList.add('bg-wood');
    }
    function removeBG(){
      document.documentElement.classList.remove('bg-wood');
      document.body.classList.remove('bg-wood');
      document.documentElement.classList.add('no-wood');
      document.body.classList.add('no-wood');
    }
    window.PageBG = window.PageBG || { add: addBG, remove: removeBG };

    try { PageBG.add(); } catch(e){}

    (function keepBackgroundCrisp(){
      const SEL = '.modal-backdrop, .bubble-overlay, .overlay, .popup-dim, .s-dim, .dim, .backdrop';
      function undim(){
        if (!document.body.classList.contains('bg-wood')) return;
        document.querySelectorAll(SEL).forEach(el=>{
          el.style.background = 'transparent';
          el.style.backdropFilter = 'none';
          el.style.filter = 'none';
        });
      }
      const mo = new MutationObserver(undim);
      mo.observe(document.body, { childList:true, subtree:true, attributes:true, attributeFilter:['class','style'] });
      undim();
    })();

    function isShown(el){
      if (!el) return false;
      var cs = getComputedStyle(el);
      return cs.display !== 'none' && el.offsetWidth > 0 && el.offsetHeight > 0;
    }
    var targets = [ document.getElementById('group-joseki'), wrap ].filter(Boolean);
    if (targets.length){
      var mo2 = new MutationObserver(function(){
        for (var i=0;i<targets.length;i++){
          if (isShown(targets[i])) { try { PageBG.add(); } catch(e){} break; }
        }
      });
      targets.forEach(function(t){
        mo2.observe(t, { attributes:true, attributeFilter:['style','class','data-hidden'] });
      });
    }
  })();
  /* ==================== /PAGE BACKGROUND ==================== */

  /* ===== Remove duplicate description boxes & button rows (static page safety) ===== */
  (function dedupeUI(){
    function keepOnlyFirst(selector){
      const all = Array.from(document.querySelectorAll(selector));
      if (!all.length) return;
      let keeper = all.find(el => wrap.contains(el)) || all[0];
      all.forEach(el => { if (el !== keeper && el.parentNode) el.parentNode.removeChild(el); });
    }
    keepOnlyFirst('#desc-wrap');
    keepOnlyFirst('#joseki-ctrls');
  })();

  /* Description drag-to-scroll */
  (function(){
    var box = document.getElementById('desc-box');
    if (!box) return;
    let isDown=false, startY=0, startScroll=0;
    box.addEventListener('mousedown', (e) => {
      isDown = true; box.classList.add('grabbing'); startY = e.clientY; startScroll = box.scrollTop; e.preventDefault();
    });
    box.addEventListener('mousemove', (e) => { if (!isDown) return; const dy = e.clientY - startY; box.scrollTop = startScroll - dy; });
    ['mouseup','mouseleave'].forEach(ev => box.addEventListener(ev, () => { isDown=false; box.classList.remove('grabbing'); }));
    box.addEventListener('touchstart', (e) => { startY = e.touches[0].clientY; startScroll = box.scrollTop; }, {passive:true});
    box.addEventListener('touchmove',  (e) => { const dy = e.touches[0].clientY - startY; box.scrollTop = startScroll - dy; }, {passive:true});
  })();

  var SIZE = 19, B='B', W='W';

  // ===== shared preferences with settings page =====
  var STORAGE_KEY = 'go_prefs';
  var GoPrefs = (window.GoPrefs = window.GoPrefs || {});

  try {
    Object.assign(GoPrefs, JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}') || {});
  } catch (e) {}

  if (typeof GoPrefs.soundOn       === 'undefined') GoPrefs.soundOn       = true;
  if (typeof GoPrefs.highlightLast === 'undefined') GoPrefs.highlightLast = true;
  if (typeof GoPrefs.josekiZoom    === 'undefined') GoPrefs.josekiZoom    = true;
  if (typeof GoPrefs.disableAutoZoomOut === 'undefined') GoPrefs.disableAutoZoomOut = false;

  // ---------- state ----------
  var board = new WGo.Board(mount, { size: SIZE });
  mount.style.backgroundImage = "url('../img/wood.jpg')";
  mount.style.backgroundSize = "cover";
  mount.style.backgroundPosition = "center";
  mount.style.backgroundRepeat = "no-repeat";

  var grid  = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null));
  var history = [];
  var current = 0;
  var turn    = B;

  var baseBoardWidth = 0;

  // === Zoom state (shared with JosekiZoom API) ===
  var zoomLayer = null;
  var zoomOverlay = null;
  var zoomStage = null;
  var zoomExitBtn = null;
  var returnAnchor = null;
  var prevOverflow = "";
  var isFullscreen = false;

  var zoomEnabled = !!GoPrefs.josekiZoom;
  var disableAutoZoomOut = !!GoPrefs.disableAutoZoomOut;

  var scale = 1;
  var minScale = 1;
  var maxScale = 2.6;
  var offsetX = 0;
  var offsetY = 0;
  var animId = 0;
  var isZoomAnimating = false;

  // For panning + click suppression
  var isPanning = false;
  var panStart = null;
  var activePointerId = null;
  var suppressNextBoardClick = false;
  var tapStart = null;
  var lastTapTime = 0;
  var lastTapGrid = null;
  var lastTapClientX = 0;
  var lastTapClientY = 0;
  var TAP_SLOP2 = 64;          // ~8px
  var DOUBLE_TAP_DELAY = 320;
  var DOUBLE_TAP_SLOP2 = 144;  // ~12px

  function canvasCssScale(){
    var c = mount.querySelector('canvas');
    if (!c) return 1;
    var cssW = c.clientWidth || c.getBoundingClientRect().width || 0;
    var intW = c.width || 0;
    if (!cssW || !intW) return 1;
    return cssW / intW;
  }
  function getXcss(i){ return board.getX(i) * canvasCssScale(); }
  function getYcss(j){ return board.getY(j) * canvasCssScale(); }

  function getBoardBounds(){
    var firstX = getXcss(0);
    var lastX  = getXcss(SIZE - 1);
    var firstY = getYcss(0);
    var lastY  = getYcss(SIZE - 1);

    var spacingX = SIZE > 1 ? Math.abs(getXcss(1) - firstX) : 0;
    var spacingY = SIZE > 1 ? Math.abs(getYcss(1) - firstY) : 0;
    if (!spacingX && spacingY) spacingX = spacingY;
    if (!spacingY && spacingX) spacingY = spacingX;

    var halfX = spacingX * 0.5 || 8;
    var halfY = spacingY * 0.5 || 8;

    return {
      minX: firstX - halfX,
      maxX: lastX  + halfX,
      minY: firstY - halfY,
      maxY: lastY  + halfY
    };
  }

  function clientToGrid(clientX, clientY){
    var rect = mount.getBoundingClientRect();
    var xIn = clientX - rect.left;
    var yIn = clientY - rect.top;

    var bounds = getBoardBounds();
    if (xIn < bounds.minX || xIn > bounds.maxX || yIn < bounds.minY || yIn > bounds.maxY){
      return null;
    }

    var bestI = 0, bestJ = 0, bestD2 = Infinity;
    for (var j = 0; j < SIZE; j++){
      var py = getYcss(j);
      for (var i = 0; i < SIZE; i++){
        var px = getXcss(i);
        var dx = px - xIn;
        var dy = py - yIn;
        var d2 = dx*dx + dy*dy;
        if (d2 < bestD2){
          bestD2 = d2;
          bestI = i;
          bestJ = j;
        }
      }
    }
    return { i: bestI, j: bestJ };
  }

  function ensureZoomLayer(){
    if (zoomLayer) return;
    mount.style.position = 'relative';
    mount.style.overflow = 'hidden';

    zoomLayer = document.createElement('div');
    zoomLayer.style.position = 'absolute';
    zoomLayer.style.left = '0px';
    zoomLayer.style.top  = '0px';
    zoomLayer.style.transformOrigin = '0 0';
    zoomLayer.style.willChange = 'transform';

    while (mount.firstChild) zoomLayer.appendChild(mount.firstChild);
    mount.appendChild(zoomLayer);

    zoomLayer.style.backgroundImage = "url('../img/wood.jpg')";
    zoomLayer.style.backgroundSize = "cover";
    zoomLayer.style.backgroundPosition = "center";
  }

  function ensureOverlay(){
    if (!zoomOverlay){
      zoomOverlay = document.getElementById('go-zoom-overlay-joseki');
      if (!zoomOverlay){
        zoomOverlay = document.createElement('div');
        zoomOverlay.id = 'go-zoom-overlay-joseki';
        zoomOverlay.innerHTML =
          '<div id="go-zoom-stage-joseki"></div>' +
          '<div id="go-zoom-exit-joseki">Zoom out</div>';
        document.body.appendChild(zoomOverlay);
      }
    }
    zoomStage = zoomOverlay.querySelector('#go-zoom-stage-joseki');
    zoomExitBtn = zoomOverlay.querySelector('#go-zoom-exit-joseki');

    if (zoomExitBtn && !zoomExitBtn._bound){
      zoomExitBtn._bound = true;
      zoomExitBtn.addEventListener('click', function(e){
        e.stopPropagation();
        smoothZoomOutAndExit();
      });
    }
  }

  function viewportSize(){
    if (isFullscreen){
      return {
        vw: window.innerWidth  || document.documentElement.clientWidth  || baseBoardWidth || 1,
        vh: window.innerHeight || document.documentElement.clientHeight || baseBoardWidth || 1
      };
    }
    return {
      vw: mount.clientWidth || baseBoardWidth || 1,
      vh: mount.clientHeight || baseBoardWidth || 1
    };
  }

  function clampPan(){
    if (!isFullscreen || !baseBoardWidth) return;
    const vp = viewportSize();
    const vw = vp.vw;
    const vh = vp.vh;

    const bw = Math.round(baseBoardWidth * scale);
    const bleedX = Math.ceil(vw * 0.5);
    const bleedY = Math.ceil(vh * 0.5);

    const minOX = -bleedX;
    const maxOX = Math.max(0, bw - vw) + bleedX;
    const minOY = -bleedY;
    const maxOY = Math.max(0, bw - vh) + bleedY;

    if (offsetX < minOX) offsetX = minOX;
    if (offsetX > maxOX) offsetX = maxOX;
    if (offsetY < minOY) offsetY = minOY;
    if (offsetY > maxOY) offsetY = maxOY;
  }

  function applyPanAndSize(redrawAfter){
    if (!zoomLayer) return;
    if (isFullscreen){
      var vp = viewportSize();
      var targetW = baseBoardWidth || Math.min(vp.vw, vp.vh);
      if (targetW < 2) targetW = 2;
      targetW = Math.round(targetW);
      if (board._lastW !== targetW){
        board.setWidth(targetW);
        zoomLayer.style.width  = targetW + 'px';
        zoomLayer.style.height = targetW + 'px';
        board._lastW = targetW;
        if (!redrawAfter) redrawAfter = true;
      }
      clampPan();
      zoomLayer.style.transform =
        'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';
      mount.style.width  = '100vw';
      mount.style.height = '100vh';
    } else {
      // Non-fullscreen: just reset any transform
      zoomLayer.style.transform = 'translate3d(0,0,0) scale(1)';
      mount.style.width  = '';
      mount.style.height = baseBoardWidth ? (baseBoardWidth + 'px') : mount.style.height;
    }

    if (redrawAfter) redraw();
  }

  function resetViewLocal(){
    scale = 1;
    offsetX = 0;
    offsetY = 0;
    if (isFullscreen){
      applyPanAndSize(true);
    } else if (zoomLayer){
      zoomLayer.style.transform = 'translate3d(0,0,0) scale(1)';
    }
  }

  function animateTo(targetScale, pxWorld, pyWorld, sxTarget, syTarget, onDone){
    if (!isFullscreen) return;
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));

    cancelAnimationFrame(animId);
    isZoomAnimating = true;

    var startScale = scale;
    var startOffsetX = offsetX;
    var startOffsetY = offsetY;
    var t0 = performance.now();
    var dur = 260;

    (function step(now){
      var t = (now - t0) / dur;
      if (t > 1) t = 1;
      var e = 1 - Math.pow(1 - t, 3);
      var s = startScale + (targetScale - startScale) * e;

      scale = s;
      offsetX = pxWorld * s - sxTarget;
      offsetY = pyWorld * s - syTarget;

      applyPanAndSize(false);

      if (t < 1){
        animId = requestAnimationFrame(step);
      } else {
        isZoomAnimating = false;
        applyPanAndSize(true);
        if (typeof onDone === 'function') onDone();
      }
    })(t0);
  }

  function centerZoomAtGrid(i, j, factor, tapClientX, tapClientY){
    if (!isFullscreen || !zoomLayer) return;

    var targetScale = Math.max(minScale, Math.min(maxScale, scale * factor));

    var px_curr = getXcss(i);
    var py_curr = getYcss(j);
    var px_world = px_curr / scale;
    var py_world = py_curr / scale;

    var rect = mount.getBoundingClientRect();
    var sx_target = rect.width  / 2;
    var sy_target = rect.height / 2;

    if (typeof tapClientX === 'number' && typeof tapClientY === 'number'){
      sx_target = tapClientX - rect.left;
      sy_target = tapClientY - rect.top;
      if (sx_target < 0) sx_target = 0;
      if (sx_target > rect.width)  sx_target = rect.width;
      if (sy_target < 0) sy_target = 0;
      if (sy_target > rect.height) sy_target = rect.height;
    }

    animateTo(targetScale, px_world, py_world, sx_target, sy_target);
  }

  function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
    if (!zoomEnabled || isFullscreen) return;

    ensureZoomLayer();
    ensureOverlay();

    prevOverflow = document.documentElement.style.overflow || "";
    document.documentElement.style.overflow = 'hidden';

    returnAnchor = document.createElement('div');
    returnAnchor.style.display = 'none';
    mount.parentNode.insertBefore(returnAnchor, mount);
    zoomStage.appendChild(mount);

    zoomOverlay.style.display = 'flex';
    if (zoomExitBtn) zoomExitBtn.style.display = 'block';

    isFullscreen = true;

    var vp = viewportSize();
    baseBoardWidth = Math.floor(Math.min(vp.vw, vp.vh));
    if (baseBoardWidth % 2) baseBoardWidth--;

    scale = 1;
    offsetX = 0;
    offsetY = 0;
    applyPanAndSize(true);

    requestAnimationFrame(function(){
      var rect = mount.getBoundingClientRect();
      var clientX = tapClientX;
      var clientY = tapClientY;
      // Fallback to board center if we somehow don't have tap coords
      if (typeof clientX !== 'number' || typeof clientY !== 'number'){
        clientX = rect.left + rect.width  / 2;
        clientY = rect.top  + rect.height / 2;
      }
      centerZoomAtGrid(i, j, 2.0, clientX, clientY);
    });
  }

  function exitFullscreen(){
    if (!isFullscreen) return;

    cancelAnimationFrame(animId);
    isZoomAnimating = false;

    if (returnAnchor && returnAnchor.parentNode){
      returnAnchor.parentNode.insertBefore(mount, returnAnchor);
      returnAnchor.parentNode.removeChild(returnAnchor);
      returnAnchor = null;
    }

    if (zoomOverlay) zoomOverlay.style.display = 'none';
    if (zoomExitBtn) zoomExitBtn.style.display = 'none';

    document.documentElement.style.overflow = prevOverflow;
    isFullscreen = false;

    scale = 1;
    offsetX = 0;
    offsetY = 0;

    if (zoomLayer){
      zoomLayer.style.transform = 'translate3d(0,0,0) scale(1)';
    }

    mount.style.width  = '';
    mount.style.height = '';

    fitBoard();
  }

  function smoothZoomOutAndExit(){
    if (!isFullscreen){
      return;
    }
    // Simple: just exit; you can upgrade to animated zoom-out later if you like.
    exitFullscreen();
  }

  // Simple responsive sizing (no zoom, no fullscreen)
  function fitBoard(){
    if (isFullscreen) return;
    var w = mount.clientWidth || 400;
    w = Math.floor(w);
    if (w % 2) w--;
    if (w <= 0) return;
    baseBoardWidth = w;
    board.setWidth(w);
    mount.style.height = w + 'px';

    if (zoomLayer){
      zoomLayer.style.width  = w + 'px';
      zoomLayer.style.height = w + 'px';
    }
  }

  window.addEventListener('resize', function(){
    if (isFullscreen){
      var vp = viewportSize();
      baseBoardWidth = Math.floor(Math.min(vp.vw, vp.vh));
      if (baseBoardWidth % 2) baseBoardWidth--;
      applyPanAndSize(true);
    } else {
      fitBoard();
    }
  });

  window.addEventListener('orientationchange', function(){
    setTimeout(function(){
      if (isFullscreen){
        var vp = viewportSize();
        baseBoardWidth = Math.floor(Math.min(vp.vw, vp.vh));
        if (baseBoardWidth % 2) baseBoardWidth--;
        applyPanAndSize(true);
      } else {
        fitBoard();
      }
    }, 200);
  });

  fitBoard();
  ensureZoomLayer(); // prepare immediately so board + wood move together

  // SGF state
  var hasSGF = false, sgfRootSeq = null, currentNode = null;
  var rootLabels = [], rootNote = '', rootAB = [], rootAW = [];

  // Free-play divergence
  var freeMode = false, josekiAnchor = null, josekiAnchorIndex = 0;

  // ===== Favorites storage (shared with Practice List) =====
  var FAV_KEY = 'go_favorites';

  function favLineKey(line){
    var size = line.size || SIZE;
    var seq = (line.moves || []).map(function(m){
      return (m.color || 'B')[0] + ':' + m.x + ',' + m.y;
    }).join('|');
    return size + '|' + seq;
  }

  function favReadMap(){
    try {
      return JSON.parse(localStorage.getItem(FAV_KEY) || '{}') || {};
    } catch(e){
      return {};
    }
  }

  function favWriteMap(map){
    try {
      localStorage.setItem(FAV_KEY, JSON.stringify(map));
    } catch(e){}
  }

  function favIsSaved(line){
    var map = favReadMap();
    return !!map[favLineKey(line)];
  }

  function favAdd(line){
    var map = favReadMap();
    map[favLineKey(line)] = {
      size: line.size || SIZE,
      rootAB: Array.isArray(line.rootAB) ? line.rootAB : [],
      rootAW: Array.isArray(line.rootAW) ? line.rootAW : [],
      moves: (line.moves || []).map(function(p){
        return { x:p.x, y:p.y, color:p.color };
      })
    };
    favWriteMap(map);
  }

  // Build a favorite line from current node, respecting pass rules
  function buildFavoriteLineFromNode(currentNode){
    if (!hasSGF || !currentNode || freeMode) return null;

    var isPassHere = !!nodePassColor(currentNode);
    var endNode = currentNode;

    if (isPassHere){
      var pathAll = pathTo(currentNode);
      var lastMoveNode = null;
      for (var i = 0; i < pathAll.length; i++){
        if (nodeMoveXY(pathAll[i])) lastMoveNode = pathAll[i];
      }
      if (!lastMoveNode) return null;
      endNode = lastMoveNode;
    }

    var path = pathTo(endNode);

    var firstMoveIndex = -1;
    var firstMoveColor = null;
    var initialPassCount = 0;
    var initialPassColors = [];

    for (var idx = 0; idx < path.length; idx++){
      var n = path[idx];
      var mv = nodeMoveXY(n);
      if (mv){
        firstMoveIndex = idx;
        firstMoveColor = mv.color;
        break;
      }
      var pc = nodePassColor(n);
      if (pc){
        initialPassCount++;
        initialPassColors.push(pc);
      }
    }

    if (firstMoveIndex === -1) return null;
    if (initialPassCount > 2) return null;

    for (var t = 0; t < initialPassColors.length; t++){
      if (initialPassColors[t] !== firstMoveColor) return null;
    }

    var moves = [];
    for (var k = firstMoveIndex; k < path.length; k++){
      var n2 = path[k];
      var mv2 = nodeMoveXY(n2);
      if (mv2){
        moves.push({ x: mv2.x, y: mv2.y, color: mv2.color });
      }
    }

    if (!moves.length) return null;

    return {
      size: SIZE,
      rootAB: rootAB.slice(),
      rootAW: rootAW.slice(),
      moves: moves
    };
  }

  function getCurrentFavoriteLineCandidate(){
    if (!hasSGF || freeMode || !currentNode) return null;

    var isPassHere = !!nodePassColor(currentNode);

    if (isPassHere){
      return buildFavoriteLineFromNode(currentNode);
    }

    var nextStones = getNextCandidates(currentNode) || [];
    var nextPasses = getPassCandidates(currentNode) || [];

    if (nextStones.length > 0 || nextPasses.length > 0){
      return null;
    }

    return buildFavoriteLineFromNode(currentNode);
  }

  // Sound preference
  var soundEnabled = !!GoPrefs.soundOn;
  function setSoundEnabled(v){
    soundEnabled = !!v;
  }

  // Highlight last move
  var highlightLastEnabled = !!GoPrefs.highlightLast;

  // Pass button helpers
  var passBtn = null;
  function getPassBtn(){
    if (!passBtn) passBtn = document.getElementById('jbtnPass');
    return passBtn;
  }
  function setPassEnabled(on){
    var b = getPassBtn();
    if (!b) return;
    b.disabled = !on;
  }

  function addLB(x,y,text){ board.addObject({ x:x, y:y, type:'LB', text:text }); }

  function redraw(){
    board.removeAllObjects();

    for (var y=0; y<SIZE; y++){
      for (var x=0; x<SIZE; x++){
        var v = grid[y][x];
        if (v === B) board.addObject({ x:x, y:y, c: WGo.B });
        else if (v === W) board.addObject({ x:x, y:y, c: WGo.W });
      }
    }

    if (hasSGF && !freeMode){
      var allCand  = getNextCandidates(currentNode || null) || [];
      var turnCand = allCand.filter(function(c){ return c.color === turn; });

      var candMap = {};
      for (var i=0; i<allCand.length; i++){
        var key = allCand[i].xy.x + ':' + allCand[i].xy.y;
        candMap[key] = true;
      }

      var nodeLabels = [];
      if (!currentNode) nodeLabels = rootLabels;
      else if (currentNode.LB_) nodeLabels = currentNode.LB_;

      for (var j=0; j<nodeLabels.length; j++){
        var lab  = nodeLabels[j];
        var lkey = lab.x + ':' + lab.y;
        if (!candMap[lkey]) addLB(lab.x, lab.y, lab.text);
      }

      for (var k=0; k<turnCand.length; k++){
        addLB(turnCand[k].xy.x, turnCand[k].xy.y, String.fromCharCode(65 + k));
      }
    }

    if (highlightLastEnabled && current > 0){
      var lm = history[current - 1];
      if (lm) board.addObject({ x: lm.x, y: lm.y, type: 'CR' });
    }
  }

  var descEl = document.getElementById('descText');

  function escHTML(s){
    if (s == null) return '';
    return String(s).replace(/[&<>"]/g, function(ch){
      if (ch === '&') return '&amp;';
      if (ch === '<') return '&lt;';
      if (ch === '>') return '&gt;';
      if (ch === '"') return '&quot;';
      return ch;
    });
  }

  function updateDesc(){
    if (!descEl) return;

    if (freeMode){
      descEl.innerHTML =
        '<div style="font-weight:600;margin-bottom:8px;">Free Play Mode</div>' +
        '<button id="backToJosekiBtn" ' +
          'style="display:inline-block;padding:8px 12px;border-radius:8px;' +
                 'border:1px solid #ccc;background:#fff;' +
                 'box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer;">' +
          'Back to Joseki' +
        '</button>';

      var btn = document.getElementById('backToJosekiBtn');
      if (btn){
        btn.onclick = function(){
          freeMode = false;
          currentNode = josekiAnchor;
          buildPositionTo(currentNode);
        };
      }
      return;
    }

    if (!hasSGF){
      descEl.textContent = '';
      return;
    }

    var baseText = '';
    if (!currentNode){
      baseText = rootNote || '';
    } else {
      baseText = currentNode.comment || '';
    }

    var favLine = getCurrentFavoriteLineCandidate();
    var html = '';

    if (baseText && String(baseText).trim().length){
      html += '<div>' + escHTML(baseText) + '</div>';
    }

    if (favLine){
      var already = favIsSaved(favLine);
      if (already){
        html += '<div style="margin-top:10px;font-weight:600;color:#047857;">' +
                  'Already in your favorites' +
                '</div>';
      } else {
        html += '<div style="margin-top:10px;">' +
                  '<button id="addFavBtn" ' +
                    'style="display:inline-block;padding:8px 12px;border-radius:8px;' +
                           'border:1px solid #ccc;background:#fff;' +
                           'box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer;">' +
                    'Add this joseki to Favorites' +
                  '</button>' +
                '</div>';
      }
    }

    if (!html){
      html = '&nbsp;';
    }

    descEl.innerHTML = html;

    if (favLine && !favIsSaved(favLine)){
      var addBtn = document.getElementById('addFavBtn');
      if (addBtn){
        addBtn.addEventListener('click', function(){
          favAdd(favLine);
          addBtn.disabled = true;
          addBtn.textContent = 'Added to Favorites';
        });
      }
    }
  }

  function neighbors(x,y){ var ns=[]; if(x>0)ns.push([x-1,y]); if(x<SIZE-1)ns.push([x+1,y]); if(y>0)ns.push([x,y-1]); if(y<SIZE-1)ns.push([x,y+1]); return ns; }
  function groupAndLiberties(x,y){
    var color=grid[y][x]; if(!color) return {stones:[],liberties:0};
    var st=[[x,y]], seen={}, stones=[], libs=0;
    while(st.length){
      var p=st.pop(), cx=p[0], cy=p[1], k=cx+':'+cy; if(seen[k]) continue;
      seen[k]=1; stones.push([cx,cy]);
      var ns=neighbors(cx,cy);
      for(var i=0;i<ns.length;i++){
        var nx=ns[i][0], ny=ns[i][1], v=grid[ny][nx];
        if(v===null) libs++; else if(v===color && !seen[nx+':'+ny]) st.push([nx,ny]);
      }
    }
    return {stones:stones, liberties:libs};
  }
  function attemptPlay(x,y,color){
    if(grid[y][x]!==null) return {ok:false, captures:[]};
    grid[y][x]=color;
    var opp=(color===B?W:B), captures=[], ns=neighbors(x,y);
    for(var i=0;i<ns.length;i++){
      var nx=ns[i][0], ny=ns[i][1];
      if(grid[ny][nx]===opp){
        var g=groupAndLiberties(nx,ny);
        if(g.liberties===0){
          for(var j=0;j<g.stones.length;j++){ var s=g.stones[j]; grid[s[1]][s[0]]=null; captures.push([s[0],s[1]]); }
        }
      }
    }
    var self=groupAndLiberties(x,y);
    if(captures.length===0 && self.liberties===0){ grid[y][x]=null; return {ok:false, captures:[]}; }
    return {ok:true, captures:captures};
  }

  function rebuildFromHistory(){
    if (current < 0) current = 0;
    if (current > history.length) current = history.length;

    for (var y = 0; y < SIZE; y++) grid[y].fill(null);

    if (hasSGF){
      for (var i = 0; i < rootAB.length; i++){
        var p = rootAB[i];
        grid[p.y][p.x] = B;
      }
      for (var j = 0; j < rootAW.length; j++){
        var q = rootAW[j];
        grid[q.y][q.x] = W;
      }
    }

    var lastMove = null;
    for (var k = 0; k < current; k++){
      var m = history[k];
      attemptPlay(m.x, m.y, m.color);
      lastMove = m;
    }

    if (!lastMove){
      turn = B;
    } else {
      turn = (lastMove.color === B ? W : B);
    }

    redraw();
    updateDesc();
    updatePassButtonState();
  }

  // ---------- SGF parsing ----------
  function readBracket(str, i){
    var out='', k=i;
    while(k<str.length){
      var ch=str[k++]; if(ch==='\\'){ if(k<str.length) out+=str[k++]; continue; }
      if(ch===']') break; out+=ch;
    }
    return { text: out, next: k };
  }
  function parseGameTree(str, i){
    var seq=[], node=null;
    if (str[i] !== '(') return { seq:[], next:i };
    i++;
    while (i<str.length){
      var ch=str[i];
      if (ch===';'){ node={}; seq.push(node); i++; }
      else if ((ch>='A'&&ch<='Z')||(ch>='a'&&ch<='z')){
        var key=''; while(i<str.length){ var c=str[i]; if((c>='A'&&c<='Z')||(c>='a'&&c<='z')){ key+=c; i++; } else break; }
        var vals=[]; while(i<str.length && str[i]==='['){ var r=readBracket(str,i+1); vals.push(r.text); i=r.next; }
        if(!node){ node={}; seq.push(node); }
        node[key] = vals.length>1 ? vals : vals[0];
      }
      else if (ch==='('){
        var child = parseGameTree(str, i);
        i = child.next;
        if (seq.length){
          var parent = seq[seq.length-1];
          parent.variations = parent.variations || [];
          parent.variations.push(child.seq);
        }
      }
      else if (ch===')'){ i++; break; }
      else { i++; }
    }
    return { seq: seq, next: i };
  }
  function sgfCoordToXY(s){
    if(!s||s.length<2) return null;
    var x=s.charCodeAt(0)-97, y=s.charCodeAt(1)-97;
    if(x<0||y<0||x>=SIZE||y>=SIZE) return null;
    return {x:x,y:y};
  }
  function parseLB(lb){
    var out=[], list = Array.isArray(lb) ? lb : (lb ? [lb] : []);
    for (var i=0;i<list.length;i++){
      var t=list[i]||'', colon=t.indexOf(':');
      var a=t.substring(0, colon>=0?colon:t.length);
      var label = colon>=0 ? t.substring(colon+1) : '•';
      var xy=sgfCoordToXY(a); if(xy) out.push({x:xy.x,y:xy.y,text:label});
    }
    return out;
  }
  function listCoords(prop){
    var out=[], list = Array.isArray(prop)? prop : (prop?[prop]:[]);
    for (var i=0;i<list.length;i++){ var xy=sgfCoordToXY(list[i]); if(xy) out.push(xy); }
    return out;
  }
  function linkify(seq, parent){
    for (var i=0;i<seq.length;i++){
      var n=seq[i];
      n.prev = (i===0? parent : seq[i-1]);
      n.next = (i<seq.length-1? seq[i+1] : null);
      if (n.C) n.comment = Array.isArray(n.C)? n.C[0] : n.C;
      if (n.LB) n.LB_ = parseLB(n.LB);
      if (n.AB) n.AB_ = listCoords(n.AB);
      if (n.AW) n.AW_ = listCoords(n.AW);
      if (n.variations && n.variations.length){
        for (var v=0; v<n.variations.length; v++){
          var childSeq = n.variations[v];
          if (childSeq && childSeq.length) linkify(childSeq, n);
        }
      }
    }
  }
  function extractRoot(seq){
    rootLabels = []; rootNote = ''; rootAB = []; rootAW = [];
    if (!seq || !seq.length) return;
    var n = seq[0];
    if (n && n.LB_) rootLabels = n.LB_;
    if (n && n.comment) rootNote = n.comment;
    if (n && n.AB_) rootAB = n.AB_;
    if (n && n.AW_) rootAW = n.AW_;
  }
  function nodeHasMove(n){ return !!(n && (n.B || n.W)); }
  function nodeMoveXY(n){
    var s = n.B || n.W; var xy = sgfCoordToXY(s);
    return xy ? {x:xy.x, y:xy.y, color: (n.B?B:W)} : null;
  }
  function candidatesDedup(list){
    var seen={}, out=[];
    for (var i=0;i<list.length;i++){
      var mv=list[i]; var key = mv.xy.x+':'+mv.xy.y+':'+mv.color;
      if (!seen[key]){ seen[key]=1; out.push(mv); }
    }
    return out;
  }

  function nodeHasColorProp(n){
    return !!(n && (typeof n.B !== 'undefined' || typeof n.W !== 'undefined'));
  }

  function nodePassColor(n){
    if (!n) return null;
    if (typeof n.B !== 'undefined'){
      var v = Array.isArray(n.B) ? n.B[0] : n.B;
      if (v === '') return B;
    }
    if (typeof n.W !== 'undefined'){
      var v2 = Array.isArray(n.W) ? n.W[0] : n.W;
      if (v2 === '') return W;
    }
    return null;
  }

  function getRootCandidates(){
    var out=[];
    if (!sgfRootSeq || !sgfRootSeq.length) return out;
    var r = sgfRootSeq[0];

    var n = r;
    while(n && !nodeHasMove(n)) n = n.next;
    if (n && nodeHasMove(n)){
      var mv = nodeMoveXY(n);
      if (mv) out.push({node:n, xy:{x:mv.x,y:mv.y}, color:mv.color});
    }

    if (r && r.variations && r.variations.length){
      for (var v=0; v<r.variations.length; v++){
        var seq = r.variations[v];
        if (seq && seq.length){
          var m = seq[0];
          while(m && !nodeHasMove(m)) m = m.next;
          if (m && nodeHasMove(m)){
            var mv2=nodeMoveXY(m);
            if (mv2) out.push({node:m, xy:{x:mv2.x,y:mv2.y}, color:mv2.color});
          }
        }
      }
    }
    return candidatesDedup(out);
  }

  function getNextCandidates(node){
    if (!node) return getRootCandidates();
    var arr=[];
    if (node.next){
      var n=node.next; while(n && !nodeHasMove(n)) n=n.next;
      if (n && nodeHasMove(n)){
        var mv=nodeMoveXY(n);
        if (mv) arr.push({node:n, xy:{x:mv.x,y:mv.y}, color:mv.color});
      }
    }
    if (node.variations && node.variations.length){
      for (var v=0; v<node.variations.length; v++){
        var seq = node.variations[v];
        if (seq && seq.length){
          var m = seq[0];
          while(m && !nodeHasMove(m)) m = m.next;
          if (m && nodeHasMove(m)){
            var mv2=nodeMoveXY(m);
            if (mv2) arr.push({node:m, xy:{x:mv2.x,y:mv2.y}, color:mv2.color});
          }
        }
      }
    }
    return candidatesDedup(arr);
  }

  function getNextColorNodes(node){
    var arr = [];
    if (!sgfRootSeq || !sgfRootSeq.length) return arr;

    if (!node){
      var r = sgfRootSeq[0];
      var n = r;
      while (n && !nodeHasColorProp(n)) n = n.next;
      if (n && nodeHasColorProp(n)) arr.push(n);

      if (r.variations && r.variations.length){
        for (var v = 0; v < r.variations.length; v++){
          var seq = r.variations[v];
          if (seq && seq.length){
            var m = seq[0];
            while (m && !nodeHasColorProp(m)) m = m.next;
            if (m && nodeHasColorProp(m)) arr.push(m);
          }
        }
      }
      return arr;
    }

    if (node.next){
      var n2 = node.next;
      while (n2 && !nodeHasColorProp(n2)) n2 = n2.next;
      if (n2 && nodeHasColorProp(n2)) arr.push(n2);
    }
    if (node.variations && node.variations.length){
      for (var vv = 0; vv < node.variations.length; vv++){
        var seq2 = node.variations[vv];
        if (seq2 && seq2.length){
          var m2 = seq2[0];
          while (m2 && !nodeHasColorProp(m2)) m2 = m2.next;
          if (m2 && nodeHasColorProp(m2)) arr.push(m2);
        }
      }
    }
    return arr;
  }

  function getPassCandidates(node){
    var colorNodes = getNextColorNodes(node || null);
    var out = [];
    for (var i = 0; i < colorNodes.length; i++){
      var c = nodePassColor(colorNodes[i]);
      if (c){
        out.push({ node: colorNodes[i], color: c });
      }
    }
    return out;
  }

  function getTurnCandidates(node){
    var all = getNextCandidates(node);
    if (!all || !all.length) return [];
    return all.filter(function(c){ return c.color === turn; });
  }

  function computePassAvailability(){
    if (!hasSGF || freeMode) return false;

    var passList = getPassCandidates(currentNode || null);
    if (!passList || !passList.length) return false;

    for (var i = 0; i < passList.length; i++){
      if (passList[i].color === turn) return true;
    }
    return false;
  }

  function updatePassButtonState(){
    setPassEnabled(computePassAvailability());
  }

  function pathTo(node){
    var out=[]; var n=node;
    while(n){ out.push(n); n=n.prev; }
    out.reverse();
    return out;
  }

  function applyNodeToBoard(nd){
    if (!nd) return null;
    var colorProp, color;
    if (typeof nd.B !== 'undefined'){
      colorProp = nd.B;
      color = B;
    } else if (typeof nd.W !== 'undefined'){
      colorProp = nd.W;
      color = W;
    } else {
      return null;
    }

    var str;
    if (Array.isArray(colorProp)) str = colorProp[0];
    else str = colorProp;

    if (str === '' || str == null){
      return color;
    }

    var xy = sgfCoordToXY(str);
    if (!xy) return color;

    var r = attemptPlay(xy.x, xy.y, color);
    if (r.ok){
      history.push({ x: xy.x, y: xy.y, color: color, captures: r.captures });
      return color;
    }
    return color;
  }

  function buildPositionTo(node){
    for (var y=0;y<SIZE;y++) grid[y].fill(null);
    history.length = 0;

    for (var i=0;i<rootAB.length;i++){ var p=rootAB[i]; grid[p.y][p.x]=B; }
    for (var j=0;j<rootAW.length;j++){ var q=rootAW[j]; grid[q.y][q.x]=W; }

    if (!node){
      current = 0;
      turn = B;
      redraw();
      updateDesc();
      updatePassButtonState();
      return;
    }

    var path = pathTo(node);
    var lastColor = null;

    for (var k=0;k<path.length;k++){
      var nd = path[k];
      if (nd.AB_) for (var a=0;a<nd.AB_.length;a++){ var pb=nd.AB_[a]; grid[pb.y][pb.x]=B; }
      if (nd.AW_) for (var b=0;b<nd.AW_.length;b++){ var pw=nd.AW_[b]; grid[pw.y][pw.x]=W; }

      var c = applyNodeToBoard(nd);
      if (c) lastColor = c;
    }

    current = history.length;

    if (!lastColor){
      turn = B;
    } else {
      turn = (lastColor === B ? W : B);
    }

    redraw();
    updateDesc();
    updatePassButtonState();
  }

  function gotoPrev (){ if (!currentNode) return; currentNode = currentNode.prev || null; buildPositionTo(currentNode); }
  function gotoNext (){ var cand = getNextCandidates(currentNode); if (!cand.length) return; currentNode = cand[0].node; buildPositionTo(currentNode); }

  // === Pointer / zoom interaction on the board container ===
  mount.addEventListener('pointerdown', function(e){
    if (!zoomEnabled) return;

    // Only use touch / pen for panning to avoid weird mouse behaviour
    if (isFullscreen && (e.pointerType === 'touch' || e.pointerType === 'pen')){
      isPanning = false;
      panStart = { x:e.clientX, y:e.clientY, ox:offsetX, oy:offsetY };
      activePointerId = e.pointerId;
      try { mount.setPointerCapture(e.pointerId); } catch(_) {}
    }

    tapStart = {
      x: e.clientX,
      y: e.clientY,
      t: performance.now()
    };
  });

  mount.addEventListener('pointermove', function(e){
    if (!isFullscreen) return;
    if (activePointerId == null || e.pointerId !== activePointerId) return;
    if (e.pointerType && e.pointerType !== 'touch' && e.pointerType !== 'pen') return;
    if (!panStart) return;

    var dx = e.clientX - panStart.x;
    var dy = e.clientY - panStart.y;
    var dist2 = dx*dx + dy*dy;

    if (!isPanning && dist2 > TAP_SLOP2){
      isPanning = true;
      suppressNextBoardClick = true;
    }

    if (!isPanning) return;

    offsetX = panStart.ox - dx;
    offsetY = panStart.oy - dy;

    applyPanAndSize(false);
    e.preventDefault();
  });

  function endPan(e){
    if (activePointerId != null){
      try { mount.releasePointerCapture(activePointerId); } catch(_) {}
    }
    activePointerId = null;
    panStart = null;
    // we keep isPanning boolean only to detect this gesture; no inertia
    setTimeout(function(){ isPanning = false; }, 0);
  }

  mount.addEventListener('pointerup', function(e){
    if (activePointerId !== null && e.pointerId === activePointerId){
      endPan(e);
    }

    if (!tapStart) return;
    var dt = performance.now() - tapStart.t;
    var dx = e.clientX - tapStart.x;
    var dy = e.clientY - tapStart.y;
    var dist2 = dx*dx + dy*dy;
    var wasTap = (dt < 280 && dist2 <= TAP_SLOP2);

    // Only double-tap behaviour when NOT fullscreen
    if (!isFullscreen && wasTap){
      var gridPos = clientToGrid(e.clientX, e.clientY);
      if (gridPos){
        var now = performance.now();
        var isDouble =
          lastTapGrid &&
          (now - lastTapTime) < DOUBLE_TAP_DELAY &&
          (Math.pow(e.clientX - lastTapClientX,2) + Math.pow(e.clientY - lastTapClientY,2)) < DOUBLE_TAP_SLOP2;

        if (isDouble){
          // Use last tap's grid (so both taps roughly at same intersection)
          enterFullscreenAtGrid(lastTapGrid.i, lastTapGrid.j, e.clientX, e.clientY);
          lastTapGrid = null;
        } else {
          lastTapGrid = gridPos;
          lastTapTime = now;
          lastTapClientX = e.clientX;
          lastTapClientY = e.clientY;
        }
      }
    }

    tapStart = null;
  });

  mount.addEventListener('pointercancel', function(e){
    if (activePointerId !== null && e.pointerId === activePointerId){
      endPan(e);
    }
    tapStart = null;
  });

  // Desktop double-click zoom
  mount.addEventListener('dblclick', function(e){
    if (!zoomEnabled) return;
    if (isFullscreen){
      // double-click while zoomed: just exit
      smoothZoomOutAndExit();
      return;
    }
    var gridPos = clientToGrid(e.clientX, e.clientY);
    if (gridPos){
      enterFullscreenAtGrid(gridPos.i, gridPos.j, e.clientX, e.clientY);
    }
  });

  // ---------- board click (stones + free mode) ----------
  board.addEventListener('click', function(x,y){
    if (suppressNextBoardClick){
      suppressNextBoardClick = false;
      return;
    }

    if (hasSGF && !freeMode){
      var opts = getTurnCandidates(currentNode);
      for (var i=0;i<opts.length;i++){
        if (opts[i].xy.x===x && opts[i].xy.y===y){
          currentNode = opts[i].node;
          buildPositionTo(currentNode);
          try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
          return;
        }
      }
      if (grid[y][x] !== null) return;
      freeMode = true;
      josekiAnchor = currentNode;
      josekiAnchorIndex = current;
    }

    if (current < history.length) history.splice(current);
    var r = attemptPlay(x,y,turn);
    if(!r.ok) return;
    history.push({ x:x, y:y, color: turn, captures: r.captures });
    current = history.length;
    turn = (turn===B?W:B);
    redraw();
    updateDesc();
    updatePassButtonState();
    try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
  });

  // ---------- preferences bridge (from Settings) ----------
  window.addEventListener('go:prefs-changed', function(e){
    var d = e.detail || {};
    if (!d || typeof d.key === 'undefined') return;

    if (d.key === 'highlightLast'){
      highlightLastEnabled = !!d.value;
      redraw();
    } else if (d.key === 'soundOn'){
      setSoundEnabled(!!d.value);
    } else if (d.key === 'josekiZoom'){
      zoomEnabled = !!d.value;
      if (!zoomEnabled && isFullscreen){
        exitFullscreen();
      }
    } else if (d.key === 'disableAutoZoomOut'){
      disableAutoZoomOut = !!d.value;
    }
  });

  // ---------- controls ----------
  function hook(id, fn){
    var el = document.getElementById(id);
    if (el) el.addEventListener('click', fn);
    else setTimeout(function(){ hook(id, fn); }, 50);
  }

  hook('jbtnBack', function(){
    if (hasSGF && !freeMode) {
      gotoPrev();
    } else if (current > 0) {
      current--;
      rebuildFromHistory();
      if (hasSGF && freeMode && current <= josekiAnchorIndex) {
        freeMode = false;
        currentNode = josekiAnchor;
        buildPositionTo(currentNode);
      }
    }
  });

  hook('jbtnForward', function(){
    if (hasSGF && !freeMode) {
      gotoNext();
    } else if (current<history.length){
      current++;
      rebuildFromHistory();
    }
  });

  hook('jbtnPass', function(){
    if (!hasSGF || freeMode) return;

    var passList = getPassCandidates(currentNode || null);
    if (!passList || !passList.length) return;

    var chosen = null;
    for (var i = 0; i < passList.length; i++){
      if (passList[i].color === turn){
        chosen = passList[i].node;
        break;
      }
    }
    if (!chosen) return;

    currentNode = chosen;
    buildPositionTo(currentNode);
    try { if (soundEnabled && window.StoneSFX && StoneSFX.play) StoneSFX.play(); } catch(e){}
  });

  hook('jbtnReset',   function(){
    if (hasSGF) {
      freeMode=false; josekiAnchor=null; currentNode=null;
      buildPositionTo(null);
    } else {
      current=0;
      rebuildFromHistory();
    }
    if (isFullscreen){
      resetViewLocal();
    }
  });

  // ====== In-app "Back to menu" dialog ======
  var menuConfirmOverlay = document.getElementById('menu-confirm-overlay');
  var menuConfirmCancel  = document.getElementById('menuConfirmCancel');
  var menuConfirmOk      = document.getElementById('menuConfirmOk');

  function closeMenuConfirm(){
    if (!menuConfirmOverlay) return;
    menuConfirmOverlay.classList.remove('is-open');
  }

  if (menuConfirmOverlay){
    menuConfirmOverlay.addEventListener('click', function(e){
      if (e.target === menuConfirmOverlay) {
        closeMenuConfirm();
      }
    });
  }

  if (menuConfirmCancel){
    menuConfirmCancel.addEventListener('click', function(e){
      e.stopPropagation();
      closeMenuConfirm();
    });
  }

  if (menuConfirmOk){
    menuConfirmOk.addEventListener('click', function(e){
      e.stopPropagation();
      closeMenuConfirm();
      window.location.href = MENU_URL;
    });
  }

  document.addEventListener('keydown', function(e){
    if (e.key === 'Escape') {
      if (isFullscreen){
        smoothZoomOutAndExit();
      } else {
        closeMenuConfirm();
      }
    }
  });

  function openMenuWithConfirm(){
    if (menuConfirmOverlay){
      menuConfirmOverlay.classList.add('is-open');
    } else {
      window.location.href = MENU_URL;
    }
  }

  hook('jbtnMenu', openMenuWithConfirm);

  // public APIs
  window.JosekiBoard = window.JosekiBoard || {};
  window.JosekiBoard.reset = function(){
    freeMode = false; josekiAnchor = null; currentNode = null; current = 0; history.length = 0;
    buildPositionTo(null);
    try { document.getElementById('desc-box').scrollTop = 0; } catch(e){}
    try { window.dispatchEvent(new Event('resize')); } catch(e){}
    try { if (window.PageBG && typeof PageBG.add === 'function') PageBG.add(); } catch(e){}
  };

  window.JosekiSound = {
    isEnabled: function(){ return soundEnabled; },
    setEnabled: function(v){ setSoundEnabled(v); }
  };

  window.JosekiHighlight = {
    isEnabled: function(){ return highlightLastEnabled; },
    setEnabled: function(v){ highlightLastEnabled = !!v; redraw(); }
  };

  // Real JosekiZoom API (used by Settings + potential future UI)
  window.JosekiZoom = {
    isEnabled: function(){ return zoomEnabled; },
    setEnabled: function(v){
      zoomEnabled = !!v;
      if (!zoomEnabled && isFullscreen){
        exitFullscreen();
      }
    },
    resetView: function(){
      if (isFullscreen){
        smoothZoomOutAndExit();
      } else {
        resetViewLocal();
      }
    },
    isFullscreen: function(){ return isFullscreen; }
  };

  // ---------- load SGF (local file) ----------
  var SGF_URL = "../sgf/library-1.sgf";

  function loadSGFText(txt){
    try{
      if (txt.charCodeAt && txt.charCodeAt(0)===0xFEFF) txt = txt.slice(1);
      var parsed = parseGameTree(txt, txt.indexOf('('));
      var rootSeq = parsed.seq && parsed.seq.length ? parsed.seq : [];
      if (!rootSeq.length){
        hasSGF=false; freeMode=false; redraw(); updateDesc(); updatePassButtonState(); return;
      }
      linkify(rootSeq, null);
      sgfRootSeq = rootSeq;
      extractRoot(rootSeq);
      hasSGF = true;
      freeMode = false;
      josekiAnchor = null;
      currentNode = null;
      buildPositionTo(null);
      fitBoard();
      try { if (window.PageBG && typeof PageBG.add === 'function') PageBG.add(); } catch(e){}
    }catch(e){
      console.error('SGF parse error:', e);
      hasSGF=false; freeMode=false;
      redraw();
      updateDesc();
      updatePassButtonState();
    }
  }
  function fetchAndLoadSGF(url){
    fetch(url, { cache:'no-cache' })
      .then(function(r){ return r.text(); })
      .then(function(t){ loadSGFText(t); })
      .catch(function(err){ console.error('SGF load failed:', err); });
  }
  fetchAndLoadSGF(SGF_URL);

})(); // mountBoard
} // _mainBoardMounted
</script>

</body>
</html>
