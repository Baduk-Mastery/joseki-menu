<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Joseki Master – My Patterns</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body{
      margin:0;
      padding:0;
      min-height:100%;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    }
  </style>
  <script src="../lib/tier-bridge.js"></script>

  <!-- Preferences bootstrap (same storage + defaults as Core) -->
  <script>
  (function(){
    var STORAGE_KEY = 'go_prefs';
    var GoPrefs = (window.GoPrefs = window.GoPrefs || {});
    try {
      var saved = localStorage.getItem(STORAGE_KEY);
      if (saved) Object.assign(GoPrefs, JSON.parse(saved) || {});
    } catch (e) {}

    if (typeof GoPrefs.josekiZoom === 'undefined')         GoPrefs.josekiZoom = true;
    if (typeof GoPrefs.soundOn === 'undefined')            GoPrefs.soundOn = true;
    if (typeof GoPrefs.highlightLast === 'undefined')      GoPrefs.highlightLast = true;
    if (typeof GoPrefs.disableAutoZoomOut === 'undefined') GoPrefs.disableAutoZoomOut = false;

    window.GoPrefsSave = function(){
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(GoPrefs)); }
      catch (e) {}
    };
  })();
  </script>
</head>
<body>

<noscript>
  <p>
    JavaScript is required to use My Patterns.
    <a href="../joseki-menu/index.html">Back to menu</a>
  </p>
</noscript>

<!-- Simple global menu bridge used by My Patterns -->
<script>
  window.GoMenu = window.GoMenu || {
    open: function(){
      // From /my-patterns/ go back to main menu
      window.location.href = "../joseki-menu/index.html";
    }
  };
</script>

<!-- ============== OWN PATTERNS (ported from Bubble) ============== -->
<div id="ownpatterns-root">
  <!-- My Patterns overlay -->
  <div id="own-overlay" aria-modal="true" role="dialog" style="display:none">
    <div class="s-inner">
      <div class="s-header">
        <button id="own-back" class="s-back" type="button" aria-label="Back">← Back</button>
        <h1 class="s-title">My Patterns</h1>
      </div>

      <!-- Message card -->
      <div class="s-card info">
        <div class="info-title">Bring your own patterns</div>
        <div class="info-desc">Can’t find the pattern you want to study? Add your own and train it in the Practice section.</div>
      </div>

      <!-- Primary action -->
      <div class="actions">
        <button id="own-add" class="s-btn s-btn-lg" type="button">Add</button>
      </div>

      <!-- Patterns list (populated by script) -->
      <div class="own-grid" id="own-list">
        <div class="s-card empty">
          <div class="empty-title">No patterns yet</div>
          <div class="empty-desc">Start by adding your first pattern.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Editor overlay (opens when you press Add) -->
  <div id="own-editor" aria-modal="true" role="dialog" style="display:none">
    <div class="s-inner">
      <div class="s-header">
        <button id="own-edit-back" class="s-back" type="button" aria-label="Back">← Back</button>
        <h1 class="s-title">Add Pattern</h1>
      </div>

     <div id="own-editor-wrap">
  <div id="own-editor-board"></div>

  <!-- anchor for restoring controls when leaving fullscreen -->
  <div id="own-editor-ctrls-anchor"></div>

  <div class="own-editor-ctrls">
    <div class="own-editor-row">
      <button id="own-edit-undo"  class="s-btn" type="button">Undo</button>
      <button id="own-edit-reset" class="s-btn" type="button">Reset</button>
      <button id="own-edit-pass"  class="s-btn" type="button">Pass</button>
    </div>

    <div class="own-editor-row">
      <button id="own-edit-save" class="s-btn s-btn-lg" type="button">Add</button>
    </div>
  </div>
</div>

    </div>
  </div>

  <!-- Info notice (OK-only). Kept for empty pattern etc. -->
  <div id="own-notice" role="alert" aria-live="polite" style="display:none">
      <div class="s-inner">
        <div class="s-card own-notice-card">
          <div class="info-title" id="own-notice-title">Heads up</div>
          <div class="info-desc" id="own-notice-text">Add at least one move to save a pattern.</div>
          <div class="actions" style="margin-top:12px;">
            <button id="own-notice-ok" class="s-btn s-btn-lg" type="button" aria-label="Close">OK</button>
          </div>
        </div>
      </div>
  </div>

  <div id="zoom-exit-btn" aria-label="Zoom out" role="button"></div>

  <!-- fullscreen bottom dock for editor controls (Joseki-style) -->
  <div id="go-zoom-ui-own"></div>
</div>



<!-- Level Selector Overlay (reused from Practice List) -->
<div id="level-overlay" aria-modal="true" role="dialog" style="display:none">
  <div class="s-inner">
    <div class="s-header">
      <button id="level-back" class="s-back" type="button" aria-label="Back to patterns">← Back</button>
      <h1 class="s-title">Choose Level</h1>
    </div>
    <div class="level-grid">
      <button class="s-card level-card" data-level="1" type="button">
        <div class="level-title">Level 1</div>
        <div class="level-desc">Every move is marked with “A”. Get familiar with the sequence.</div>
      </button>
      <button class="s-card level-card" data-level="2" type="button">
        <div class="level-title">Level 2</div>
        <div class="level-desc">You play Black only; White moves are auto-placed.</div>
      </button>
      <button class="s-card level-card" data-level="3" type="button">
        <div class="level-title">Level 3</div>
        <div class="level-desc">You play White only; Black moves are auto-placed.</div>
      </button>
      <button class="s-card level-card" data-level="4" type="button">
        <div class="level-title">Level 4</div>
        <div class="level-desc">Only the second move is marked “A”; you play the rest for both colors.</div>
        <span class="pro-chip" aria-hidden="true">PRO</span>
      </button>
      <button class="s-card level-card" data-level="5" type="button">
        <div class="level-title">Level 5</div>
        <div class="level-desc">Like Level 4, but the opening color alternates each try.</div>
        <span class="pro-chip" aria-hidden="true">PRO</span>
      </button>
    </div>
  </div>
</div>

<style>
  /* Scope EVERYTHING to this page via #ownpatterns-root */
  #ownpatterns-root {
    --wood:url('../img/wood.jpg'); /* keep in lockstep with Practice */
    --board-max: 720px;
  }

  /* Overlays (My Patterns + Editor) */
#ownpatterns-root #own-overlay,
#ownpatterns-root #own-editor{
  position:fixed;
  inset:0;
  z-index:100000;
  display:none;

  /* Full-screen flex, wood stays fixed, no scroll here */
  align-items:stretch;
  justify-content:center;
  padding:0 0 12px 0;          /* only bottom margin of wood */
  box-sizing:border-box;
  overflow:hidden;             /* prevent overscroll showing body */
  color:#e6f3ff;
  -webkit-tap-highlight-color:transparent;

  background-color:#1b1208;    /* warm fallback */
  background-image:
    linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)),
    var(--wood);
  background-size:cover;
  background-position:center;
}

/* Keep the My Patterns list aligned to the top */
#ownpatterns-root #own-overlay{
  align-items:flex-start;
}

/* Keep the My Patterns list aligned to the top */
#ownpatterns-root #own-overlay{
  align-items:flex-start;
}
#ownpatterns-root .s-inner{
  /* Match Joseki page width behavior more closely */
  width: min(100vw, var(--board-max));

  height:100%;
  max-height:100%;
  margin:0 auto;
  padding:16px 24px 22px;
  text-align:left;
  position:relative;

  /* This is the only scrollable area */
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}

@media (max-width:480px){
  #ownpatterns-root .s-inner{
    /* Same mobile side feel as your Joseki layout */
    padding:16px 12px 22px;
  }
}
/* Match Practice List width ONLY for the My Patterns list overlay */
#ownpatterns-root #own-overlay .s-inner{
  width: min(92vw, var(--board-max));
}
@media (max-width:480px){
  #ownpatterns-root #own-overlay .s-inner{
    padding:16px 24px 22px; /* mirror Practice List */
  }
}


/* Practice/Drills-aligned header frame for My Patterns */
#ownpatterns-root .s-header{
  max-width: var(--board-max);
  width: 100%;
  margin: 16px auto 10px;   /* match Drills topbar vertical rhythm */
  padding: 0;               /* no extra header padding */
  box-sizing: border-box;

  /* keep your “true centered title” behavior */
  display: grid;
  grid-template-columns: minmax(max-content, 1fr) auto minmax(max-content, 1fr);
  align-items: center;
  column-gap: 14px;
}


/* Put back button on the left, title truly centered */
#ownpatterns-root .s-header .s-back{
  grid-column: 1;
  justify-self: start;
}

#ownpatterns-root .s-header .s-title{
  grid-column: 2;
  justify-self: center;
  text-align: center;
}

  #ownpatterns-root .s-title{
    margin:0; font-size:24px; line-height:1.15; font-weight:800;
    text-shadow:0 1px 2px rgba(0,0,0,.35);
  }

  /* Buttons + cards – align with Practice List (glass cards + wood buttons) */

  /* Glass cards (keep same look as Practice List) */
  #ownpatterns-root .s-card{
    background: rgba(37,99,235,.22);
    border:2px solid rgba(37,99,235,.75);
    border-radius:12px;
    box-shadow:0 8px 20px rgba(2,6,23,.45), inset 0 0 0 1px rgba(255,255,255,.08);
    color:#e6f3ff;
    padding:12px;
    box-sizing:border-box;
    overflow:hidden;
  }

  #ownpatterns-root .info-title{
    font-weight:900;
    font-size:16px;
    margin-bottom:4px;
  }
  #ownpatterns-root .info-desc{
    font-size:13px;
    line-height:1.5;
    opacity:.96;
    white-space:normal;
    word-break:break-word;
    overflow-wrap:anywhere;
    max-width:100%;
  }
/* Match Practice Board notification typography inside the My Patterns notice */
#ownpatterns-root #own-notice .info-title{
  font-size:18px;
  margin-bottom:8px;
}

#ownpatterns-root #own-notice .info-desc{
  font-size:16px;
  line-height:1.4;
  margin-bottom:14px; /* same feel as notif body text on Practice Board */
}


  #ownpatterns-root .actions{
    margin-top:14px;
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }

 /* Wood-style buttons – size + feel aligned with Practice Board .pbtn */
#ownpatterns-root .s-back,
#ownpatterns-root .s-btn{
  position: relative;

  /* same baseline footprint as Practice */
  min-width: 90px;
  padding: 8px 24px;

  display: inline-flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  text-align: center;

  border-radius: 8px;
  border: 1px solid rgba(255,255,255,.40);

  font-size: 16px;
  font-weight: 800;
  line-height: 1.1;
  color: #fff3cf;
  text-shadow: 0 1px 0 rgba(120,60,20,.7);
  cursor: pointer;

  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;

  background-image:
    linear-gradient(
      to bottom,
      rgba(255,255,255,.12),
      rgba(255,255,255,.03) 38%,
      rgba(0,0,0,.14) 100%
    ),
    var(--wood);
  background-size: 100% 100%, cover;
  background-position: center;
  background-repeat: no-repeat;

  filter: brightness(1.08) saturate(.96);

  box-shadow:
    0 3px 0 rgba(133,74,26,.85),
    0 8px 14px rgba(0,0,0,.45);

  transition:
    transform .08s ease-out,
    box-shadow .08s ease-out,
    filter .12s ease-out;
}

#ownpatterns-root .s-back:hover,
#ownpatterns-root .s-btn:hover{
  filter: brightness(1.12) saturate(.98);
  transform: translateY(-1px);
  box-shadow:
    0 4px 0 rgba(133,74,26,.9),
    0 10px 16px rgba(0,0,0,.48);
}

#ownpatterns-root .s-back:active,
#ownpatterns-root .s-btn:active{
  filter: brightness(.97) saturate(.96);
  transform: translateY(2px);
  box-shadow:
    0 1px 0 rgba(120,60,20,.9),
    0 4px 8px rgba(0,0,0,.55);
}


  #ownpatterns-root .s-back:hover,
  #ownpatterns-root .s-btn:hover{
    filter:brightness(1.12) saturate(.98);
    transform:translateY(-1px);
    box-shadow:
      0 4px 0 rgba(133,74,26,.9),
      0 10px 16px rgba(0,0,0,.48);
  }

  #ownpatterns-root .s-back:active,
  #ownpatterns-root .s-btn:active{
    filter:brightness(.97) saturate(.96);
    transform:translateY(2px);
    box-shadow:
      0 1px 0 rgba(120,60,20,.9),
      0 4px 8px rgba(0,0,0,.55);
  }

/* Slimmer header back button (like Practice header) */
#ownpatterns-root .s-header .s-back{
  min-width: auto;   /* prevent the Practice-sized minimum here */
  padding: 6px 12px;
  font-size: 14px;
  border-radius: 8px;
}
/* Larger primary buttons – keep same baseline as Practice */
#ownpatterns-root .s-btn.s-btn-lg{
  padding: 8px 24px;
  font-size: 16px;
}


  /* Danger variant for Remove (red-tinted wood) */
  #ownpatterns-root .s-btn.s-btn-danger{
    background-image:
      linear-gradient(
        to bottom,
        rgba(255,255,255,.10),
        rgba(255,255,255,.03) 38%,
        rgba(0,0,0,.18) 100%
      ),
      var(--wood);
    background-size:100% 100%, cover;
    background-position:center;
    background-repeat:no-repeat;
    background-color:rgba(220,38,38,.55);
    border-color:rgba(248,113,113,.95);
    box-shadow:
      0 3px 0 rgba(120,30,20,.9),
      0 8px 14px rgba(0,0,0,.50);
  }


/* List grid */
#ownpatterns-root .own-grid{
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  margin-top:16px;
  padding-bottom:12px;   /* extra space under the last pattern card */
}
@media (min-width: 720px){
  #ownpatterns-root .own-grid{ grid-template-columns:1fr 1fr; }
}

  #ownpatterns-root .empty-title{
    font-weight:900; font-size:16px; margin-bottom:4px;
  }
  #ownpatterns-root .empty-desc{
    font-size:13px; opacity:.95;
  }

  /* Own list card layout — updated to match Practice alignment */
  #ownpatterns-root .own-card{
    display:flex; align-items:stretch; gap:12px; width:100%; text-align:left; padding:10px; cursor:pointer;
    transition:transform .06s, background .15s; user-select:none; -webkit-user-select:none;
  }
  #ownpatterns-root .own-card:active{ transform:translateY(1px); }

  /* Thumbnail: wood background & frame (WGo board floats above) */
  #ownpatterns-root .own-thumb{
    width:132px; height:132px; border-radius:10px; overflow:hidden; flex:none;
    position: relative;
    background-image:
      linear-gradient(rgba(0,0,0,.04), rgba(0,0,0,.06)),
      var(--wood);
    background-size:cover; background-position:center;
    border:2px solid rgba(37,99,235,.65);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
  }
#ownpatterns-root .own-thumb canvas.own-canvas{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  display:block;
  pointer-events:none;
}


  #ownpatterns-root .own-meta{
    flex:1; min-width:0; display:flex; flex-direction:column; height:100%;
  }
  #ownpatterns-root .own-title{
    font-weight:800; font-size:18px; line-height:1.3;
  }
/* Buttons area inside each pattern card */
#ownpatterns-root .own-cta{
  margin-top:auto;
  display:flex;
  flex-direction:column;   /* stack vertically by default */
  gap:8px;
  align-items:stretch;     /* make children fill width */
}

/* Make the wood buttons fill the card width inside own-cta */
#ownpatterns-root .own-cta .s-btn{
  width:100%;
  justify-content:center;
  box-sizing:border-box;
}

/* On wider screens you can show them side-by-side without overflow */
@media (min-width: 720px){
  #ownpatterns-root .own-cta{
    flex-direction:row;
  }
  #ownpatterns-root .own-cta .s-btn{
    flex:1 1 0;
  }
}


  /* ===== Editor overlay centering (make it feel like Core board) ===== */
  #ownpatterns-root #own-editor{
    align-items: center; /* centers the whole editor content vertically */
  }

  /* Override the shared full-height inner container only for the editor */
  #ownpatterns-root #own-editor .s-inner{
    height: auto;
    max-height: 100%;
  }

#ownpatterns-root #own-editor-wrap{
  width:100%;
  max-width:var(--board-max);
  margin:0 auto;
  box-sizing:border-box;

  display:flex;
  flex-direction:column;
  align-items:center;
}

/* Editor board box matches Joseki board corners + shadow */
#ownpatterns-root #own-editor-board{
  position:relative;
  width:100%;

  border-radius:6px;
  overflow:hidden;

  margin:0 auto;

  box-shadow:
    0 18px 40px rgba(0,0,0,.32),
    0 6px 16px rgba(0,0,0,.22);
}
/* ===== My Patterns editor zoom fullscreen state (no button) ===== */
#ownpatterns-root #own-editor-board.is-fullscreen{
  position: fixed !important;
  inset: 0 !important;
  width: 100vw !important;
  height: 100vh !important;

  border-radius: 0 !important;
  box-shadow: none !important;
  margin: 0 !important;

  z-index: 100003;
  overflow: hidden !important;
  touch-action: none;
}
/* ZOOM OUT BUTTON - matching Core board */
#ownpatterns-root #zoom-exit-btn{
  position:fixed;
  left:14px;
  bottom:90px;

  width:120px;
  height:80px;
  border-radius:9px;

  background:rgba(148,163,184,.35);
  border:1px solid rgba(148,163,184,.85);
  box-shadow:0 6px 16px rgba(0,0,0,.55);

display:none; /* toggled in JS */
  cursor:pointer;
  pointer-events: none; /* <--- ADD THIS LINE: Default to pass-through */

  /* Make sure it sits above the fullscreen editor board */
  z-index:100004;

  backdrop-filter:blur(2px);
  -webkit-tap-highlight-color:transparent;

  color:#e5e7eb;
  font-size:18px;
  font-weight:600;

  align-items:center;
  justify-content:center;
}

/* Text content placeholder (same as Core) */
#ownpatterns-root #zoom-exit-btn::after { content: ""; }

/* Bottom dock for My Patterns editor controls while fullscreen zoom is active */
#ownpatterns-root #go-zoom-ui-own{
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;

  /* match Joseki/Practice dock padding */
  padding: 0 12px 18px;

  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: flex-end;

  /* allow board gestures through gaps, but buttons clickable */
  pointer-events: none;

  /* above fullscreen editor board (100003) */
  z-index: 100004;
}
#ownpatterns-root #go-zoom-ui-own > *{
  pointer-events: auto;
}
/* ===== Keep editor header/back above fullscreen zoom (match Drills topbar) ===== */
#ownpatterns-root.own-zoom-mode #own-editor .s-header{
  position: fixed;
  top: 28px; /* Drills: 12px dock padding + 16px topbar margin */

  left: 50%;
  transform: translateX(-50%);

  /* Emulate Drills' outer 12px side padding */
  width: min(calc(100vw - 24px), var(--board-max));
  max-width: var(--board-max);

  margin: 0;
  padding: 0; /* IMPORTANT: remove inner padding that shifts desktop left edge */

  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 10px;

  z-index: 100005;

  /* don't block board taps except the back button */
  pointer-events: none;
}

#ownpatterns-root.own-zoom-mode #own-editor .s-header .s-title{
  display: none !important;
}


/* re-enable click only on the back button */
#ownpatterns-root.own-zoom-mode #own-editor .s-header .s-back{
  pointer-events: auto;
}

/* remove the headline while zoomed in */
#ownpatterns-root.own-zoom-mode #own-editor .s-header .s-title{
  display: none !important;
}



/* When in zoom mode, adapt the editor controls for dock use */
#ownpatterns-root.own-zoom-mode .own-editor-ctrls{
  margin: 0 auto !important;
  padding: 0 12px 18px !important;
  width: 100%;
  max-width: var(--board-max);
}

/* Show only the first row (Undo/Reset/Pass) while zoomed */
#ownpatterns-root.own-zoom-mode .own-editor-ctrls .own-editor-row:nth-child(2){
  display: none !important;
}

/* Give the wood/zoom layer the same transform setup as Core */
#ownpatterns-root #own-editor-board .own-zoom-layer{
  transform-origin: 0 0;
  will-change: transform;
}


/* Ensure all children respect rounding */
#ownpatterns-root #own-editor-board > *{
  border-radius: inherit;
}

#ownpatterns-root #own-editor-board .own-zoom-layer{
  position:absolute;
  inset:0;
  background-image: var(--wood);
  background-size: cover;
  background-position: center;
}

#ownpatterns-root #own-editor-board canvas{
  display:block;
  margin:0 auto;
}


/* Practice-matching control container under the editor board */
#ownpatterns-root .own-editor-ctrls{
  max-width: var(--board-max);
  width: 100%;
  align-self: stretch;          /* key fix inside centered flex parent */
  box-sizing: border-box;

  margin: 14px auto 0;          /* closer to Practice feel */
  padding: 0 12px 18px;         /* mirrors #prac-ctrls spacing */

  display: flex;
  flex-direction: column;       /* two rows */
  gap: 12px;
  align-items: stretch;
}

/* Rows behave like Practice control row */
#ownpatterns-root .own-editor-row{
  width: 100%;
  display: flex;
  gap: 12px;                    /* match Practice gap */
  justify-content: center;
  flex-wrap: wrap;
}

/* Equal-width buttons per row, same baseline as Practice */
#ownpatterns-root .own-editor-row .s-btn{
  flex: 1 1 0;
  min-width: 90px;
}



  /* Centered info notice (OK-only) – match Practice Board notif design */
  #ownpatterns-root #own-notice{
    position:fixed;
    inset:0;
    z-index:100001;
    display:none;
    align-items:center;
    justify-content:center;
    padding:0;
    background:rgba(0,0,0,.55); /* same dim backdrop as Practice modals */
  }
#ownpatterns-root #own-notice .s-inner{
  width:auto;
  padding:0;
  margin:0;
  display:block;
  height:auto;
  max-height:none;
  overflow:visible;
}

  #ownpatterns-root #own-notice .own-notice-card{
    position:relative;
    border-radius:10px;
    border:1px solid #e2e8f0;
    box-shadow:0 12px 28px rgba(15,23,42,.18);
    padding:16px;
    text-align:center;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    color:#fff3cf;

    /* Same background as Practice .notif-card */
    background-image:
      linear-gradient(
        to bottom,
        rgba(0,0,0,.10),
        rgba(0,0,0,.25)
      ),
      url('../img/notification.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;

    min-width:280px;
    max-width:min(86vw, 420px);
    max-height:calc(100vh - 32px);
    overflow:auto;
  }
  #ownpatterns-root #own-notice .own-notice-card > *{
    color:inherit !important; /* override any inline colors like on Practice */
  }
  #ownpatterns-root #own-notice .actions{
    margin-top:10px;
    display:flex;
    gap:10px;
    justify-content:center;
    flex-wrap:wrap;
  }


    /* Centered confirm toast (Remove) – match Practice Board notif design */
  #ownpatterns-root .own-toast{
    position:fixed;
    inset:0;
    z-index:100002;
    display:none;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.55); /* dim backdrop */
  }
  #ownpatterns-root .own-toast .own-toast-card{
    position:relative;
    border-radius:10px;
    border:1px solid #e2e8f0;
    box-shadow:0 12px 28px rgba(15,23,42,.18);
    padding:16px;
    text-align:center;
    font-family:system-ui,Segoe UI,Arial,sans-serif;
    color:#fff3cf;

    background-image:
      linear-gradient(
        to bottom,
        rgba(0,0,0,.10),
        rgba(0,0,0,.25)
      ),
      url('../img/notification.jpg');
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;

    min-width:280px;
    max-width:min(86vw, 420px);
    max-height:calc(100vh - 32px);
    overflow:auto;
  }
  #ownpatterns-root .own-toast .own-toast-card > *{
    color:inherit !important;
  }
#ownpatterns-root .own-toast .own-toast-text{
  font-weight:800;
  font-size:18px;
  line-height:1.35;
  margin-bottom:8px; /* same visual spacing as Practice Board titles */
}
  #ownpatterns-root .own-toast .own-toast-actions{
    margin-top:10px;
    display:flex;
    gap:10px;
    justify-content:center;
    flex-wrap:wrap;
  }


  /* Lock interactions while any notice/toast open */
  #ownpatterns-root.notice-open #own-editor-board{ pointer-events:none; }
  #ownpatterns-root.notice-open #own-overlay .s-inner{ pointer-events:none; }

  /* Level overlay styling (copied to match Practice List style) */
  #level-overlay{
  position:fixed;
  inset:0;
  z-index:100000;
  display:none;

  align-items:stretch;
  justify-content:center;
  padding:0 0 12px 0;
  box-sizing:border-box;
  overflow:hidden;

  color:#e6f3ff;
  -webkit-tap-highlight-color:transparent;
  background-color:#1b1208;
  background-image:
    linear-gradient(rgba(0,0,0,.35), rgba(0,0,0,.45)),
    url('../img/wood.jpg');
  background-size:cover;
  background-position:center;
}

#level-overlay .s-inner{
  width:min(92vw,720px);
  height:100%;
  max-height:100%;
  margin:0 auto;
  padding:16px 24px 22px;
  text-align:left;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}

#level-overlay .s-header{
  display: grid;
  grid-template-columns: minmax(max-content, 1fr) auto minmax(max-content, 1fr);
  align-items: center;
  column-gap: 14px;
  margin: 6px 0 10px;
}


  #level-overlay .s-title{
    margin:0; font-size:24px; line-height:1.15; font-weight:800;
    text-shadow:0 1px 2px rgba(0,0,0,.35);
  }
  #level-overlay .s-back{
    position:relative;
    display:inline-flex; align-items:center; justify-content:center;
    padding:6px 12px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.40);
    font-size:14px;
    font-weight:800;
    line-height:1.1;
    color:#fff3cf;
    text-shadow:0 1px 0 rgba(120,60,20,.7);
    cursor:pointer;
    background-image:
      linear-gradient(
        to bottom,
        rgba(255,255,255,.12),
        rgba(255,255,255,.03) 38%,
        rgba(0,0,0,.14) 100%
      ),
      url('../img/wood.jpg');
    background-size:100% 100%, cover;
    background-position:center;
    background-repeat:no-repeat;
    filter:brightness(1.08) saturate(.96);
    box-shadow:
      0 3px 0 rgba(133,74,26,.85),
      0 8px 14px rgba(0,0,0,.45);
    transition:
      transform .08s ease-out,
      box-shadow .08s ease-out,
      filter .12s ease-out;
  }
#level-overlay .s-back{
  grid-column: 1;
  justify-self: start;
  white-space: nowrap;

  position:relative;
  display:inline-flex; align-items:center; justify-content:center;
  padding:6px 12px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,.40);
  font-size:14px;
  font-weight:800;
  line-height:1.1;
}

  #level-overlay .s-back:hover{
    filter:brightness(1.12) saturate(.98);
    transform:translateY(-1px);
    box-shadow:
      0 4px 0 rgba(133,74,26,.9),
      0 10px 16px rgba(0,0,0,.48);
  }
  #level-overlay .s-back:active{
    filter:brightness(.97) saturate(.96);
    transform:translateY(2px);
    box-shadow:
      0 1px 0 rgba(120,60,20,.9),
      0 4px 8px rgba(0,0,0,.55);
  }

#level-overlay .level-grid{
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  margin-top:8px;
  padding-bottom:12px;   /* same extra space under the last level card */
}
@media (min-width: 720px){
  #level-overlay .level-grid{ grid-template-columns:1fr 1fr; }
}

  #level-overlay .level-card{
    background: rgba(37,99,235,.22);
    border:2px solid rgba(37,99,235,.75);
    border-radius:12px;
    box-shadow:0 8px 20px rgba(2,6,23,.45), inset 0 0 0 1px rgba(255,255,255,.08);
    color:#e6f3ff;
    position:relative; padding:12px; text-align:left; cursor:pointer;
    transition:transform .06s, background .15s;
  }
  #level-overlay .level-card:active{
    transform:translateY(1px);
  }
  #level-overlay .level-title{
    font-weight:900; font-size:16px; margin-bottom:4px;
  }
  #level-overlay .level-desc{
    font-size:13px; line-height:1.5; opacity:.95;
  }
  #level-overlay .pro-chip{
    position:absolute; top:10px; right:10px; padding:3px 8px; font-size:11px; font-weight:900;
    border-radius:999px; background:#3b82f6; color:#fff; border:1px solid #3b82f6;
    box-shadow:0 6px 16px rgba(2,6,23,.45);
  }
  #level-overlay .level-card[aria-disabled="true"]{
    opacity:.55; cursor:not-allowed; filter:saturate(.9);
  }
</style>

<!-- Load WGo only if not already present on the page -->
<script>
(function ensureWGo(){
  if (window.WGo) return;
  var s = document.createElement('script');
  // You can replace this with a local path if you host wgo.min.js yourself
  s.src = "https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754893285939x971907393576095400/wgo.min.js";
  s.async = true;
  document.head.appendChild(s);
})();
</script>

<!-- Stone SFX (same module & bridge used by Practice) -->
<script>
if (!window.StoneSFX) {
  window.StoneSFX = (() => {
    let pool = [], i = 0, unlocked = false;
    function init(url, voices = 5, volume = 0.35){
      pool = Array.from({ length: voices }, () => {
        const a = new Audio(url); a.preload = 'auto'; a.volume = volume; return a;
      });
      const unlock = () => {
        if (unlocked) return;
        for (const a of pool) {
          try {
            a.play().then(()=>a.pause()).catch(()=>{});
            a.currentTime = 0;
          } catch(e){}
        }
        unlocked = true;
        window.removeEventListener('touchstart', unlock);
        window.removeEventListener('mousedown',  unlock);
      };
      window.addEventListener('touchstart', unlock, { once:true });
      window.addEventListener('mousedown',  unlock, { once:true });
    }
    function play(){
      if (!pool.length) return;
      const a = pool[i++ % pool.length];
      try {
        a.currentTime=0;
        a.playbackRate=0.97+Math.random()*0.06;
        a.play();
      } catch(e){}
    }
    return { init, play };
  })();
}
if (!window._stoneSFXInit) {
  StoneSFX.init("https://3d85c7a311526e02aeeeb19e952d0c09.cdn.bubble.io/f1754926303439x491369894441766600/klick.mp3");
  window._stoneSFXInit = true;
}
(function(){
  if (!window.StoneSFX || window._soundBridgeReady) return;
  window._soundBridgeReady = true;
  if (typeof StoneSFX.play === 'function' && !('_enabled' in StoneSFX)){
    StoneSFX._enabled = (window.GoPrefs ? !!window.GoPrefs.soundOn : true);
    const _origPlay = StoneSFX.play.bind(StoneSFX);
    StoneSFX.play = function(){ if (StoneSFX._enabled) _origPlay(); };
  }
  window.JosekiSound   = window.JosekiSound   || {
    isEnabled(){ return !!StoneSFX._enabled; },
    setEnabled(v){ StoneSFX._enabled = !!v; }
  };
  window.PracticeSound = window.PracticeSound || window.JosekiSound;
})();
</script>

<script>
/* Scoped logic; exposes GoOwnPatterns and uses PracticeConfig + Level overlay like Practice List */
(function(){
  var root     = document.getElementById('ownpatterns-root');
  if (!root) return;

  var overlay  = root.querySelector('#own-overlay');
  var editor   = root.querySelector('#own-editor');
  var notice   = root.querySelector('#own-notice');
  var noticeText = root.querySelector('#own-notice-text');
  var noticeOk   = root.querySelector('#own-notice-ok');

  var openBtn  = root.querySelector('#own-add');
  var backTop  = root.querySelector('#own-back');
  var backEd   = root.querySelector('#own-edit-back');
var undoBtn  = root.querySelector('#own-edit-undo');
var resetBtn = root.querySelector('#own-edit-reset');
var passBtn  = root.querySelector('#own-edit-pass');
var saveBtn  = root.querySelector('#own-edit-save');
  var mount    = root.querySelector('#own-editor-board');
  var wrap     = root.querySelector('#own-editor-wrap');
  var listEl   = root.querySelector('#own-list');
  var exitBtn  = root.querySelector('#zoom-exit-btn');
  // ===== Zoom dock wiring (My Patterns editor controls) =====
  var dockOwn = root.querySelector('#go-zoom-ui-own');
  var ctrlsOwn = root.querySelector('.own-editor-ctrls');
  var ctrlsOwnAnchor = root.querySelector('#own-editor-ctrls-anchor');

  var ctrlsOwnHomeParent = null;
  var ctrlsOwnHomeNext = null;

  function enableOwnDockMode(){
    if (!dockOwn || !ctrlsOwn) return;

    root.classList.add('own-zoom-mode');
    dockOwn.style.display = 'flex';

    if (!ctrlsOwnHomeParent){
      ctrlsOwnHomeParent = ctrlsOwn.parentNode;
      ctrlsOwnHomeNext = ctrlsOwn.nextSibling;
    }

    dockOwn.appendChild(ctrlsOwn);
  }

  function disableOwnDockMode(){
    root.classList.remove('own-zoom-mode');
    if (dockOwn) dockOwn.style.display = 'none';
    if (!ctrlsOwn) return;

    if (ctrlsOwnAnchor && ctrlsOwnAnchor.parentNode){
      ctrlsOwnAnchor.parentNode.insertBefore(ctrlsOwn, ctrlsOwnAnchor.nextSibling);
      return;
    }

    if (ctrlsOwnHomeParent){
      if (ctrlsOwnHomeNext && ctrlsOwnHomeNext.parentNode === ctrlsOwnHomeParent){
        ctrlsOwnHomeParent.insertBefore(ctrlsOwn, ctrlsOwnHomeNext);
      } else {
        ctrlsOwnHomeParent.appendChild(ctrlsOwn);
      }
    }
  }


  // Practice Board bridge: persist config across pages
  var PRACTICE_CFG_KEY = 'go_practice_config';
  function savePracticeConfig(){
    try {
      localStorage.setItem(PRACTICE_CFG_KEY, JSON.stringify(window.PracticeConfig || {}));
    } catch(e){}
  }

  function show(el){ el.style.display='flex'; }
  function hide(el){ el.style.display='none'; }
  function isNoticeOpen(){ return root.classList.contains('notice-open'); }

  /* Info notice helpers (OK-only) */
  function showNotice(msg, title){
    if (noticeText) noticeText.textContent = msg || 'Notice';
    var t = root.querySelector('#own-notice-title');
    if (t) t.textContent = title || 'Heads up';
    show(notice);
    root.classList.add('notice-open');
    setTimeout(function(){
      try { noticeOk && noticeOk.focus(); } catch(_){}
    }, 30);
  }
  function hideNotice(){
    hide(notice);
    root.classList.remove('notice-open');
  }
  // Expose notice helper for Level overlay
  window.OwnShowNotice = showNotice;

  noticeOk && noticeOk.addEventListener('click', hideNotice);
  window.addEventListener('keydown', function(e){
    if (e.key === 'Escape' && isNoticeOpen()) hideNotice();
  });

  /* Removal confirm toast (centered) */
  var removeToast = null, removeText = null, btnYes = null, btnNo = null, currentRemoveId = null;
  function ensureRemoveToast(){
    if (removeToast) return;
    removeToast = document.createElement('div');
    removeToast.className = 'own-toast';
    removeToast.setAttribute('role','alertdialog');
    removeToast.setAttribute('aria-modal','true');
    removeToast.innerHTML =
      '<div class="s-card own-toast-card">' +
        '<div class="own-toast-text" id="own-remove-text">Remove this pattern?</div>' +
        '<div class="own-toast-actions">' +
          '<button type="button" class="s-btn s-btn-lg" id="own-remove-cancel">Cancel</button>' +
          '<button type="button" class="s-btn s-btn-lg s-btn-danger" id="own-remove-yes">Remove</button>' +
        '</div>' +
      '</div>';
    root.appendChild(removeToast);
    removeText = removeToast.querySelector('#own-remove-text');
    btnYes = removeToast.querySelector('#own-remove-yes');
    btnNo  = removeToast.querySelector('#own-remove-cancel');

    btnNo.addEventListener('click', hideRemoveToast);
    btnYes.addEventListener('click', function(){
      if (!currentRemoveId) return hideRemoveToast();
      removePattern(currentRemoveId);
      currentRemoveId = null;
      hideRemoveToast();
    });
    window.addEventListener('keydown', function(e){
      if (removeToast.style.display !== 'none' && e.key === 'Escape') hideRemoveToast();
    });
  }
function showRemoveToast(pattern, label){
  ensureRemoveToast();
  currentRemoveId = pattern.id;
  var name = label || pattern.title || 'this pattern';
  removeText.textContent = 'Remove "' + name + '"?';
  removeToast.style.display = 'flex';   // was 'block'
  root.classList.add('notice-open');
  setTimeout(function(){
    try { btnNo && btnNo.focus(); } catch(_){}
  }, 30);
}


  function hideRemoveToast(){
    if (!removeToast) return;
    removeToast.style.display = 'none';
    root.classList.remove('notice-open');
  }

  /* Storage for patterns */
  var STORE_KEY = 'go:ownpatterns';
  function loadPatterns(){
    try { return JSON.parse(localStorage.getItem(STORE_KEY) || '[]'); }
    catch(_) { return []; }
  }
  function savePatterns(arr){
    try { localStorage.setItem(STORE_KEY, JSON.stringify(arr)); } catch(_) {}
  }
  function removePattern(id){
    var items = loadPatterns().filter(function(p){ return p.id !== id; });
    savePatterns(items);
    renderList();
  }

  /* Editor state */
  var SIZE=19, board=null, grid=null, moves=null, last=null, turn='B';
  /* ===================== Editor Zoom (ported from Core, trimmed) ===================== */

  // Uses GoPrefs.josekiZoom if it exists elsewhere; otherwise defaults on.
  var zoomEnabled = (window.GoPrefs && typeof window.GoPrefs.josekiZoom !== 'undefined')
    ? !!window.GoPrefs.josekiZoom
    : true;
// Match Core: whether we should avoid auto-return after a move while zoomed
var disableAutoZoomOut = (window.GoPrefs && typeof window.GoPrefs.disableAutoZoomOut !== 'undefined')
  ? !!window.GoPrefs.disableAutoZoomOut
  : false;

  var scale = 1, minScale = 1, maxScale = 2.6;
  var offsetX = 0, offsetY = 0;
  var baseW = 0;

  var isFullscreen = false;
  var isZoomAnimating = false;
  var animId = 0;

  var panStart = null, tapStart = null, isPanning = false;
  var TAP_SLOP2 = 64;
  var zoomInFactor = 2.4;

  // Fling (inertia) state — ported from Core
  var isFlinging = false, flingId = 0, flingVX = 0, flingVY = 0, flingLastTime = 0;
  var panSamplePrev = null, panSampleCurr = null;


// React to global settings changes if your settings page dispatches them
window.addEventListener('go:prefs-changed', function(e){
  var d = (e && e.detail) || {};
  if (!d || typeof d.key === 'undefined') return;

  if (d.key === 'josekiZoom'){
    zoomEnabled = !!d.value;
    if (!zoomEnabled) smoothZoomOutAndExit();
  } else if (d.key === 'disableAutoZoomOut'){
    disableAutoZoomOut = !!d.value;
  }
});


  function canvasCssScale(){
    var c = mount && mount.querySelector('canvas');
    if (!c) return 1;
    var cssW = c.clientWidth || c.getBoundingClientRect().width || 0;
    var intW = c.width || 0;
    if (!cssW || !intW) return 1;
    return cssW / intW;
  }
  function getXcss(i){ return board.getX(i) * canvasCssScale(); }
  function getYcss(j){ return board.getY(j) * canvasCssScale(); }

  function getZoomLayer(){
    return mount ? mount.querySelector('.own-zoom-layer') : null;
  }

  function clampPan(){
    if (isZoomAnimating || !mount) return;

    var vw = mount.clientWidth || 0;
    var vh = mount.clientHeight || 0;
    var bw = Math.round(baseW * scale);

    // Core-style "soft bounds" so edges can be pulled around
    var bleedX = Math.ceil(vw * 0.5);
    var bleedY = Math.ceil(vh * 0.5);

    var minOX = -bleedX;
    var maxOX = Math.max(0, bw - vw) + bleedX;

    var minOY = -bleedY;
    var maxOY = Math.max(0, bw - vh) + bleedY;

    offsetX = Math.max(minOX, Math.min(offsetX, maxOX));
    offsetY = Math.max(minOY, Math.min(offsetY, maxOY));
  }


  function applyPanAndSize(redrawAfter){
    if (!board || !mount) return;

    var layer = getZoomLayer();
    if (!layer) return;

    if (!baseW){
      baseW = Math.floor(mount.getBoundingClientRect().width || 0);
      if (baseW % 2) baseW--;
    }

    if (board._zoomW !== baseW){
      board.setWidth(baseW);
      layer.style.width  = baseW + 'px';
      layer.style.height = baseW + 'px';
      board._zoomW = baseW;
      if (redrawAfter === undefined) redrawAfter = true;
    }

    clampPan();

    layer.style.transform =
      'translate3d(' + (-offsetX) + 'px,' + (-offsetY) + 'px,0) scale(' + scale + ')';

    if (redrawAfter){
      try { redraw(); } catch(_) {}
    }
  }

  function animateTo(targetScale, pxWorld, pyWorld, sxTarget, syTarget){
    targetScale = Math.max(minScale, Math.min(maxScale, targetScale));
    cancelFling();


    var s0 = scale, ox0 = offsetX, oy0 = offsetY;
    var t0 = performance.now();
    var dur = 300;

    isZoomAnimating = true;
    cancelAnimationFrame(animId);

    var targetOffsetX = (pxWorld * targetScale) - sxTarget;
    var targetOffsetY = (pyWorld * targetScale) - syTarget;

    (function step(now){
      var t = (now - t0) / dur;
      if (t > 1) t = 1;
      var e = 1 - Math.pow(1 - t, 3);

      scale   = s0  + (targetScale - s0) * e;
      offsetX = ox0 + (targetOffsetX - ox0) * e;
      offsetY = oy0 + (targetOffsetY - oy0) * e;

      applyPanAndSize(false);

      if (t < 1){
        animId = requestAnimationFrame(step);
      } else {
        isZoomAnimating = false;
        applyPanAndSize(true);
      }
    })(t0);
  }
  function startFling(vx, vy){
    if (scale <= 1 && !isFullscreen) return;
    cancelFling();

    var speed = Math.sqrt(vx*vx + vy*vy);

    // Cap max speed (Core behavior)
    var MAX_SPEED = 0.50;
    if (speed > MAX_SPEED){
      var s = MAX_SPEED / speed;
      vx *= s;
      vy *= s;
      speed = MAX_SPEED;
    }

    // Ignore tiny velocities
    if (speed < 0.04) return;

    isFlinging = true;
    flingVX = vx;
    flingVY = vy;
    flingLastTime = performance.now();

    (function step(now){
      if (!isFlinging) return;

      var dt = now - flingLastTime;
      if (dt <= 0){
        flingId = requestAnimationFrame(step);
        return;
      }
      if (dt > 50) dt = 50;
      flingLastTime = now;

      offsetX += flingVX * dt;
      offsetY += flingVY * dt;

      // Linear friction (Core behavior)
      var friction = 0.0010; // px/ms²
      var currentSpeed = Math.sqrt(flingVX*flingVX + flingVY*flingVY);
      var decel = friction * dt;

      if (currentSpeed <= 0.01 || decel >= currentSpeed){
        cancelFling();
        applyPanAndSize(true);
        return;
      }

      var newSpeed = currentSpeed - decel;
      var scaleFactor = newSpeed / currentSpeed;

      flingVX *= scaleFactor;
      flingVY *= scaleFactor;

      applyPanAndSize(false);
      flingId = requestAnimationFrame(step);
    })(performance.now());
  }

  function cancelFling(){
    isFlinging = false;
    if (flingId){
      cancelAnimationFrame(flingId);
      flingId = 0;
    }
  }

function enterFullscreenAtGrid(i, j, tapClientX, tapClientY){
    if (!mount || isFullscreen) return;
    cancelFling();
    
    // 1. Set Fullscreen State
    mount.classList.add('is-fullscreen');
    isFullscreen = true;

    // 2. Hide Button & Disable Clicks (Ghost Mode)
    if (exitBtn) {
      exitBtn.style.display = 'none';
      exitBtn.style.pointerEvents = 'none';
    }

    // 3. Show Dock
    enableOwnDockMode();

    // 4. Set CSS Dimensions
    mount.style.width  = '100vw';
    mount.style.height = '100vh';

    // 5. Start Animation Logic
    requestAnimationFrame(function(){
      // --- FIX: Update GLOBAL scoped variables ---
      var vw = window.innerWidth;
      var vh = window.innerHeight;
      
      // Update global baseW so applyPanAndSize works correctly in fullscreen
      baseW = Math.floor(Math.min(vw, vh));
      if (baseW % 2) baseW--; 

      // Reset global state for the start of the animation
      scale = 1; 
      offsetX = 0; 
      offsetY = 0;
      
      // Force an immediate apply to snap the DOM to the new baseW
      applyPanAndSize(true);

      // --- Calculate Target Zoom ---
      // In fullscreen, the board side is effectively the smaller dimension (baseW).
      // We want to cover the LARGER dimension.
      var needToCover = Math.max(vw, vh) / (baseW || 360);
      var dynamicZoom = Math.max(1.8, needToCover + 0.02);
      // -----------------------------

      var px = getXcss(i);
      var py = getYcss(j);

      var rect = mount.getBoundingClientRect();
      var sx = rect.width / 2;
      var sy = rect.height / 2;

      if (typeof tapClientX === 'number' && typeof tapClientY === 'number'){
        sx = tapClientX - rect.left;
        sy = tapClientY - rect.top;
      }

      // Update global offsets to center the tap point
      offsetX = px - sx;
      offsetY = py - sy;
      
      // Apply this starting state (centered, scale 1) without redrawing contents yet
      applyPanAndSize(false);

      // Animate to the calculated dynamicZoom
      animateTo(dynamicZoom, px, py, sx, sy);

      // 6. Restore UI Interaction
      setTimeout(function(){
        if (exitBtn && isFullscreen) {
          exitBtn.style.display = 'flex';
          exitBtn.style.pointerEvents = 'auto'; 
        }
      }, 200);
    });
  }
function exitFullscreen(){
    if (!mount) return;

    cancelFling();
    cancelAnimationFrame(animId);
    isZoomAnimating = false;

    // 1. Remove Fullscreen State
    mount.classList.remove('is-fullscreen');
    isFullscreen = false;

    // 2. Hide Button & Disable Clicks (Ghost Mode)
    if (exitBtn) {
      exitBtn.style.display = 'none';
      exitBtn.style.pointerEvents = 'none'; 
    }

    // 3. Hide Dock
    disableOwnDockMode();

    // 4. Reset Dimensions
    mount.style.width  = '';
    mount.style.height = '';

    scale = 1; offsetX = 0; offsetY = 0;

    fitSoon();
  }
  function smoothZoomOutAndExit(){
    cancelFling();
    cancelAnimationFrame(animId);

    isZoomAnimating = false;

    scale = 1; offsetX = 0; offsetY = 0;

    if (isFullscreen){
      exitFullscreen();
    } else {
      applyPanAndSize(true);
    }
  }
function bindZoomExitBtn(){
    if (!exitBtn) return;
    
    // Force initial state to ensure it doesn't block clicks on load
    exitBtn.style.pointerEvents = 'none';
    exitBtn.style.display = 'none';
    
    if (exitBtn._bound) return;
    exitBtn._bound = true;

    exitBtn.addEventListener('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      // Only allow exit if we aren't currently animating (double protection)
      if (!isZoomAnimating) {
        smoothZoomOutAndExit();
      }
    });
  }
  function bindZoomHandlers(){
    if (!mount || mount._zoomBound) return;
    mount._zoomBound = true;

    mount.addEventListener('pointerdown', function(e){
      if (!zoomEnabled) return;
      if (e.pointerType !== 'touch' && e.button !== 0) return;

      var r = mount.getBoundingClientRect();
      var sx = e.clientX - r.left;
      var sy = e.clientY - r.top;

      var boardX = (sx + offsetX) / scale;
      var boardY = (sy + offsetY) / scale;

      var bestI = -1, bestJ = -1, bestDx = 1e9, bestDy = 1e9;

      for (var i=0; i<SIZE; i++){
        var dx = Math.abs(getXcss(i) - boardX);
        if (dx < bestDx){ bestDx = dx; bestI = i; }
      }
      for (var j=0; j<SIZE; j++){
        var dy = Math.abs(getYcss(j) - boardY);
        if (dy < bestDy){ bestDy = dy; bestJ = j; }
      }

      cancelFling();

      panStart = { x:e.clientX, y:e.clientY, ox:offsetX, oy:offsetY };
      panSamplePrev = panSampleCurr = null;

      try { mount.setPointerCapture(e.pointerId); } catch(_){}

      tapStart = { x:e.clientX, y:e.clientY, gridI:bestI, gridJ:bestJ };
      isPanning = false;

    }, {passive:false});

    mount.addEventListener('pointermove', function(e){
      if (!zoomEnabled) return;
      if (!panStart) return;
      if (scale <= 1.01 && !isFullscreen) return;

      var dx = e.clientX - panStart.x;
      var dy = e.clientY - panStart.y;

      if (!isPanning && (dx*dx + dy*dy > TAP_SLOP2)) isPanning = true;

      if (isPanning){
        offsetX = panStart.ox - dx;
        offsetY = panStart.oy - dy;
        applyPanAndSize(false);
        e.preventDefault();

        var now = performance.now();
        panSamplePrev = panSampleCurr;
        panSampleCurr = { ox: offsetX, oy: offsetY, t: now };
      }

    }, {passive:false});

    mount.addEventListener('pointerup', function(e){
      if (!zoomEnabled){
        panStart = null; tapStart = null; isPanning = false;
        return;
      }

      try { mount.releasePointerCapture(e.pointerId); } catch(_){}

      if (!tapStart){
        panStart = null;
        return;
      }

      var dist2 =
        (e.clientX - tapStart.x) * (e.clientX - tapStart.x) +
        (e.clientY - tapStart.y) * (e.clientY - tapStart.y);

      var gridI = tapStart.gridI;
      var gridJ = tapStart.gridJ;
      var tapX  = tapStart.x;
      var tapY  = tapStart.y;

      panStart = null; tapStart = null;

      if (isPanning){
        isPanning = false;

        if (panSamplePrev && panSampleCurr){
          var dt = panSampleCurr.t - panSamplePrev.t;
          if (dt > 0 && dt < 120){
            startFling(
              (panSampleCurr.ox - panSamplePrev.ox) / dt,
              (panSampleCurr.oy - panSamplePrev.oy) / dt
            );
          }
        }
        return;
      }


      if (dist2 <= TAP_SLOP2){
        e.preventDefault();

if (scale <= 1.05 && !isFullscreen){
  enterFullscreenAtGrid(gridI, gridJ, tapX, tapY);
} else {
  if (!isNoticeOpen()) playAt(gridI, gridJ);
  // Match Core setting: only auto-return if user didn't disable it
  if (!disableAutoZoomOut){
    setTimeout(smoothZoomOutAndExit, 10);
  }
}

      }
    }, {passive:false});

    // Minimal escape hatch without adding UI
    window.addEventListener('keydown', function(e){
      if (e.key === 'Escape' && isFullscreen){
        e.stopPropagation();
        smoothZoomOutAndExit();
      }
    });
  }

  var koPoint=null;
  var highlightLastEnabled = (window.GoPrefs && typeof window.GoPrefs.highlightLast !== 'undefined') ? !!window.GoPrefs.highlightLast : true;

  window.addEventListener('go:prefs-changed', function(e){
    var d = (e && e.detail) || {};
    if (d.key === 'highlightLast'){
      highlightLastEnabled = !!d.value;
      try { redraw(); } catch(_) {}
    }
    if (d.key === 'soundOn' && window.StoneSFX){
      StoneSFX._enabled = !!d.value;
    }
  });

  window.OwnHighlight = {
    isEnabled(){ return highlightLastEnabled; },
    setEnabled(v){ highlightLastEnabled = !!v; try { redraw(); } catch(_) {} }
  };

  function initState(){
    grid = Array.from({length:SIZE}, ()=>Array(SIZE).fill(null));
    moves = [];
    last  = null;
    turn  = 'B';
    koPoint = null;
  }

  function redraw(){
    if (!board) return;
    board.removeAllObjects();

    // First pass (legacy; kept but redundant)
    for (var y=0;y<SIZE;y++){
      for (var x=0;x<SIZE;x++){
        var v=grid[y][x];
        if (v==='B') board.addObject({x:x,y:y,c:WGo.B});
        if (v==='W') board.addObject({x:x,y:x,c:WGo.W}); // typo guarded by second pass
      }
    }

    // Correct second pass
    board.removeAllObjects();
    for (var y2=0;y2<SIZE;y2++){
      for (var x2=0;x2<SIZE;x2++){
        var v2=grid[y2][x2];
        if (v2==='B') board.addObject({x:x2,y:y2,c:WGo.B});
        if (v2==='W') board.addObject({x:x2,y:y2,c:WGo.W});
      }
    }

    if (highlightLastEnabled && last){
      board.addObject({ x:last.x, y:last.y, type:'CR' });
    }
  }

  function resetAll(){
    initState();
    redraw();
  }

  function ensureWoodLayer(){
    if (!mount || mount._woodReady) return;
    var layer = document.createElement('div');
    layer.className = 'own-zoom-layer';
    while (mount.firstChild) layer.appendChild(mount.firstChild);
    mount.appendChild(layer);
    mount._woodReady = true;
  }

  function ensureBoard(cb){
    function mountNow(){
      if (board){ cb&&cb(); return; }
      board = new WGo.Board(mount, { size: SIZE });
      ensureWoodLayer();

      // Make sure the layer exists before binding zoom
      bindZoomHandlers();
      bindZoomExitBtn();
      resetAll();
      bindBoardClicks();
      fitSoon();
      cb && cb();

    }
    if (window.WGo) return mountNow();
    var tries=0;
    (function wait(){
      if (window.WGo) return mountNow();
      if (tries++>120) return;
      setTimeout(wait,50);
    })();
  }

  /* Liberty / capture helpers */
  function neighbors(x,y){
    var n=[];
    if (x>0) n.push({x:x-1,y:y});
    if (x<SIZE-1) n.push({x:x+1,y:y});
    if (y>0) n.push({x:x,y:y-1});
    if (y<SIZE-1) n.push({x:x,y:y+1});
    return n;
  }
  function groupAt(x,y){
    var color = grid[y][x];
    if (!color) return { stones:[], libs:new Set() };
    var seen = new Set(), q=[{x:x,y:y}], stones=[], libs=new Set();
    function key(p){ return p.x+','+p.y; }
    while(q.length){
      var p=q.pop();
      var k=key(p);
      if (seen.has(k)) continue;
      seen.add(k);
      stones.push(p);
      neighbors(p.x,p.y).forEach(function(nb){
        var v=grid[nb.y][nb.x];
        if (v===null){ libs.add(nb.x+','+nb.y); }
        else if (v===color){
          if (!seen.has(nb.x+','+nb.y)) q.push(nb);
        }
      });
    }
    return { stones:stones, libs:libs };
  }
  function removeStones(sts){
    for (var i=0;i<sts.length;i++){
      var s=sts[i];
      grid[s.y][s.x]=null;
    }
  }

  function playAt(x,y){
    if (grid[y][x]!==null) return;

    if (koPoint && x===koPoint.x && y===koPoint.y){
      showNotice('Ko — immediate recapture is not allowed. Play elsewhere first.', 'Ko');
      return;
    }

    var me = turn;
    var opp = (me==='B') ? 'W' : 'B';

    grid[y][x]=me;

    var capturedList = [];
    var seenOpp = new Set();
    neighbors(x,y).forEach(function(nb){
      if (grid[nb.y][nb.x]===opp){
        var key = nb.x+','+nb.y;
        if (seenOpp.has(key)) return;
        seenOpp.add(key);
        var g = groupAt(nb.x, nb.y);
        if (g.libs.size===0){
          g.stones.forEach(function(s){ capturedList.push({x:s.x,y:s.y,color:opp}); });
          removeStones(g.stones);
        }
      }
    });

    var myGroup = groupAt(x,y);
    if (myGroup.libs.size===0 && capturedList.length===0){
      grid[y][x]=null;
      showNotice('Self-capture is not allowed in this editor.', 'Illegal move');
      return;
    }

    var prevKo = koPoint ? {x:koPoint.x, y:koPoint.y} : null;
    koPoint = null;

    if (capturedList.length === 1){
      if (myGroup.stones.length === 1 && myGroup.libs.size === 1){
        var onlyLib = Array.from(myGroup.libs)[0].split(',').map(function(v){ return parseInt(v,10); });
        if (onlyLib[0] === capturedList[0].x && onlyLib[1] === capturedList[0].y){
          koPoint = { x: capturedList[0].x, y: capturedList[0].y };
        }
      }
    }

    last = { x:x, y:y };
    moves.push({
      x:x, y:y, color: me,
      captured: capturedList,
      prevKo: prevKo
    });
    turn = opp;
    redraw();
    try { StoneSFX.play(); } catch(_) {}
  }

  function bindBoardClicks(){
    if (!board || board._bound) return;
    board._bound = true;
    board.addEventListener('click', function(x,y){
      // Custom pointer zoom handlers own taps when zoomed
      if (zoomEnabled && (isFullscreen || scale > 1.05)) return;
      if (!isNoticeOpen()) playAt(x,y);
    });
  }


  function targetWidth(){
    var cap = parseInt(getComputedStyle(root).getPropertyValue('--board-max')) || 720;
    var avail = Math.round((wrap && wrap.getBoundingClientRect().width) ||
                           (editor && editor.getBoundingClientRect().width) ||
                           (window.innerWidth || cap));
    var prac = document.getElementById('go-board-prac');
    var wP = prac ? Math.round(prac.getBoundingClientRect().width || 0) : 0;
    var w = wP ? Math.min(wP, avail, cap) : Math.min(avail, cap);
    w = Math.floor(w);
    if (w % 2) w--;
    return w;
  }
  function fit(){
    if (!board) return;
    if (isFullscreen) return;

    var w = targetWidth();
    if (!w){
      setTimeout(fit,60);
      return;
    }

    baseW = w;

    mount.style.width  = w + 'px';
    mount.style.height = w + 'px';

    // Ensure the internal layer matches the base size
    var layer = mount.querySelector('.own-zoom-layer');
    if (layer){
      layer.style.width  = w + 'px';
      layer.style.height = w + 'px';
    }

    applyPanAndSize(true);
  }

  function fitSoon(){
    fit();
    setTimeout(fit,60);
    setTimeout(fit,180);
    setTimeout(fit,360);
  }
  window.addEventListener('resize', fit);
  window.addEventListener('orientationchange', function(){ setTimeout(fit,150); });
  window.addEventListener('pageshow', fitSoon);

  (function observeEditorVisibility(){
    var mo = new MutationObserver(function(muts){
      for (var i=0;i<muts.length;i++){
        if (muts[i].type === 'attributes' && muts[i].attributeName === 'style'){
          if (editor.style.display === 'none'){
            resetAll();
          } else {
            fitSoon();
          }
        }
      }
    });
    try { mo.observe(editor, { attributes:true, attributeFilter:['style'] }); } catch(_){}
  })();

  /* Thumbnail rendering – same logic as Practice List, no WGo needed */

  function simulatePosition(size, rootAB, rootAW, moves){
    var N = size || 19;
    var E = 0, B = 1, W = 2;
    var board = Array.from({length:N}, function(){ return Array(N).fill(E); });

    function inB(x,y){ return x>=0 && y>=0 && x<N && y<N; }
    function at(x,y){ return board[y][x]; }
    function set(x,y,v){ board[y][x] = v; }
    function neigh(x,y){
      return [
        [x+1,y],[x-1,y],
        [x,y+1],[x,y-1]
      ].filter(function(p){ return inB(p[0],p[1]); });
    }

    (Array.isArray(rootAB) ? rootAB : []).forEach(function(p){
      if (inB(p.x,p.y)) set(p.x,p.y,B);
    });
    (Array.isArray(rootAW) ? rootAW : []).forEach(function(p){
      if (inB(p.x,p.y)) set(p.x,p.y,W);
    });

    function groupAndLibs(x,y){
      var color = at(x,y);
      if (color === E) return null;
      var q = [[x,y]];
      var seen = new Set([x + '_' + y]);
      var group = [[x,y]];
      var libs = 0;
      while(q.length){
        var cur = q.pop();
        var cx = cur[0], cy = cur[1];
        neigh(cx,cy).forEach(function(n){
          var nx = n[0], ny = n[1];
          var v = at(nx,ny);
          if (v === E){
            libs++;
          } else if (v === color){
            var k = nx + '_' + ny;
            if (!seen.has(k)){
              seen.add(k);
              q.push([nx,ny]);
              group.push([nx,ny]);
            }
          }
        });
      }
      return { group: group, libs: libs };
    }

    function removeGroup(g){
      g.forEach(function(p){ set(p[0],p[1],E); });
    }

    function play(move){
      if (!move) return;
      var x = move.x, y = move.y;
      if (!inB(x,y)) return;
      var color = (move.color === 'W') ? W : B;
      var opp   = (color === B) ? W : B;
      if (at(x,y) !== E) return;
      set(x,y,color);

      var oppToCheck = [];
      neigh(x,y).forEach(function(n){
        var nx = n[0], ny = n[1];
        if (at(nx,ny) === opp) oppToCheck.push([nx,ny]);
      });

      var captured = 0;
      oppToCheck.forEach(function(n){
        var info = groupAndLibs(n[0], n[1]);
        if (info && info.libs === 0){
          removeGroup(info.group);
          captured += info.group.length;
        }
      });

      var mine = groupAndLibs(x,y);
      if (mine && mine.libs === 0 && captured === 0){
        // suicide – undo it
        removeGroup(mine.group);
      }
    }

    (Array.isArray(moves) ? moves : []).forEach(play);

    var out = [];
    for (var y=0; y<N; y++){
      for (var x=0; x<N; x++){
        var v = board[y][x];
        if (v === B) out.push({ x:x, y:y, color:'B' });
        else if (v === W) out.push({ x:x, y:y, color:'W' });
      }
    }
    return out;
  }

  function hoshiPoints(size){
    if (size === 19) return [3,9,15];
    if (size === 13) return [3,6,9];
    if (size === 9)  return [2,4,6];
    var mid = Math.floor((size-1)/2);
    var off = size >= 15 ? 3 : Math.max(2, Math.round(size/6));
    return [off, mid, size-1-off];
  }

  function ensureThumbCanvas(el){
    var cv = el.querySelector('canvas.own-canvas');
    if (!cv){
      cv = document.createElement('canvas');
      cv.className = 'own-canvas';
      el.appendChild(cv);
    }
    return cv;
  }

  function drawStone(ctx, cx, cy, r, color){
    var isBlack = (color === 'B');
    ctx.save();
    ctx.shadowColor = 'transparent';

    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.clip();

    var hx = cx - r * 0.28;
    var hy = cy - r * 0.28;
    var body = ctx.createRadialGradient(hx, hy, r * 0.12, cx, cy, r);
    if (isBlack){
      body.addColorStop(0.00, '#686868');
      body.addColorStop(0.65, '#141414');
      body.addColorStop(1.00, '#000000');
    } else {
      body.addColorStop(0.00, '#ffffff');
      body.addColorStop(0.70, '#f2f2f2');
      body.addColorStop(1.00, '#e4e4e4');
    }
    ctx.fillStyle = body;
    ctx.fillRect(cx - r, cy - r, 2*r, 2*r);

    var edge = Math.max(0.6, r * 0.08);
    var rim = ctx.createRadialGradient(cx, cy, r - edge, cx, cy, r);
    if (isBlack){
      rim.addColorStop(0, 'rgba(255,255,255,0)');
      rim.addColorStop(1, 'rgba(255,255,255,0.12)');
    } else {
      rim.addColorStop(0, 'rgba(0,0,0,0)');
      rim.addColorStop(1, 'rgba(0,0,0,0.18)');
    }
    ctx.fillStyle = rim;
    ctx.fillRect(cx - r, cy - r, 2*r, 2*r);

    var spec = ctx.createRadialGradient(hx, hy, 0, hx, hy, r * 0.55);
    if (isBlack){
      spec.addColorStop(0, 'rgba(255,255,255,0.10)');
      spec.addColorStop(1, 'rgba(255,255,255,0)');
    } else {
      spec.addColorStop(0, 'rgba(255,255,255,0.22)');
      spec.addColorStop(1, 'rgba(255,255,255,0)');
    }
    ctx.fillStyle = spec;
    ctx.fillRect(cx - r, cy - r, 2*r, 2*r);

    ctx.restore();
  }

  function drawBoardThumb(el, size, stones, opts){
    var crop = !!(opts && opts.crop);
    var w = Math.max(64, Math.floor(el.clientWidth || 132));
    var h = w;
    var dpr = Math.max(1, window.devicePixelRatio || 1);

    var cv = ensureThumbCanvas(el);
    if (cv.width !== w*dpr || cv.height !== h*dpr){
      cv.width = Math.floor(w*dpr);
      cv.height = Math.floor(h*dpr);
      cv.style.width = w + 'px';
      cv.style.height = h + 'px';
    }

    var ctx = cv.getContext('2d');
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);

    var pad   = Math.round(w * 0.10);
    var inner = w - pad*2;
    var step  = inner / (size - 1);
    var getX  = function(i){ return pad + i*step; };
    var getY  = function(j){ return pad + j*step; };

    var minX=0, minY=0, maxX=size-1, maxY=size-1;
    if (crop && stones && stones.length){
      minX = maxX = stones[0].x;
      minY = maxY = stones[0].y;
      stones.forEach(function(s){
        if (s.x < minX) minX = s.x;
        if (s.x > maxX) maxX = s.x;
        if (s.y < minY) minY = s.y;
        if (s.y > maxY) maxY = s.y;
      });

      var MARGIN = 1;
      minX = Math.max(0, minX - MARGIN);
      minY = Math.max(0, minY - MARGIN);
      maxX = Math.min(size-1, maxX + MARGIN);
      maxY = Math.min(size-1, maxY + MARGIN);

      var EDGE_NEAR = 6;
      var pinLeft   = (minX <= EDGE_NEAR);
      var pinTop    = (minY <= EDGE_NEAR);
      var pinRight  = (maxX >= size-1-EDGE_NEAR);
      var pinBottom = (maxY >= size-1-EDGE_NEAR);
      if (pinLeft)  minX = 0;
      if (pinTop)   minY = 0;
      if (pinRight) maxX = size-1;
      if (pinBottom)maxY = size-1;

      var wG = (maxX - minX + 1);
      var hG = (maxY - minY + 1);
      var target = Math.max(wG, hG);

      if (hG < target){
        var need = target - hG;
        if (pinTop && !pinBottom)      maxY = Math.min(size-1, maxY + need);
        else if (pinBottom && !pinTop) minY = Math.max(0, minY - need);
        else {
          var up = Math.ceil(need/2), dn = Math.floor(need/2);
          minY = Math.max(0, minY - up);
          maxY = Math.min(size-1, maxY + dn);
        }
      }
      if (wG < target){
        need = target - wG;
        if (pinLeft && !pinRight)       maxX = Math.min(size-1, maxX + need);
        else if (pinRight && !pinLeft)  minX = Math.max(0, minX - need);
        else {
          var lf = Math.ceil(need/2), rt = Math.floor(need/2);
          minX = Math.max(0, minX - lf);
          maxX = Math.min(size-1, maxX + rt);
        }
      }
    }

    var leftPx   = getX(minX) - step/2;
    var rightPx  = getX(maxX) + step/2;
    var topPx    = getY(minY) - step/2;
    var bottomPx = getY(maxY) + step/2;
    var cropSide = Math.max(rightPx-leftPx, bottomPx-topPx);
    var scale    = w / cropSide;

    ctx.save();
    ctx.scale(scale, scale);
    ctx.translate(-leftPx, -topPx);

    ctx.strokeStyle = 'rgba(0,0,0,.9)';
    var desiredPx = Math.max(1, Math.floor(w * 0.006));
    ctx.lineWidth = desiredPx / scale;

    for (var i=0; i<size; i++){
      var y = getY(i);
      ctx.beginPath(); ctx.moveTo(getX(0), y); ctx.lineTo(getX(size-1), y); ctx.stroke();
      var x = getX(i);
      ctx.beginPath(); ctx.moveTo(x, getY(0)); ctx.lineTo(x, getY(size-1)); ctx.stroke();
    }

    ctx.fillStyle = '#000';
    var hs = hoshiPoints(size);
    var hr = Math.max(1, step * 0.02);
    hs.forEach(function(ix){
      hs.forEach(function(iy){
        var cx = getX(ix), cy = getY(iy);
        ctx.beginPath(); ctx.arc(cx, cy, hr, 0, Math.PI*2); ctx.fill();
      });
    });

    var r = step * 0.46;
    (stones || []).forEach(function(s){
      drawStone(ctx, getX(s.x), getY(s.y), r, (s.color === 'W' ? 'W' : 'B'));
    });

    ctx.restore();
  }

  function renderOwnThumb(el, line){
    var size = line.size || 19;
    var stones = simulatePosition(
      size,
      Array.isArray(line.rootAB) ? line.rootAB : [],
      Array.isArray(line.rootAW) ? line.rootAW : [],
      Array.isArray(line.moves)  ? line.moves  : []
    );
    drawBoardThumb(el, size, stones, { crop:true });
  }


  /* Pattern list rendering */
  function renderList(){
    var items = loadPatterns();
    listEl.innerHTML='';
    if (!items.length){
      var empty=document.createElement('div');
      empty.className='s-card empty';
      empty.innerHTML='<div class="empty-title">No patterns yet</div><div class="empty-desc">Start by adding your first pattern.</div>';
      listEl.appendChild(empty);
      return;
    }

    items.forEach(function(pat, idx){
      var card=document.createElement('button');
      card.type='button';
      card.className='s-card own-card';
      card.dataset.id=pat.id;

      var thumb=document.createElement('div');
      thumb.className='own-thumb';

      var meta=document.createElement('div');
      meta.className='own-meta';

      var title=document.createElement('div');
      title.className='own-title';

      var cta=document.createElement('div');
      cta.className='own-cta';

var moveCount = (pat && Array.isArray(pat.moves)) ? pat.moves.length : 0;
var displayName = 'Pattern ' + (idx+1);
title.textContent = displayName + ' (' + moveCount + ' Moves)';


      var practiceBtn = document.createElement('span');
      practiceBtn.className = 's-btn';
      practiceBtn.textContent = 'Practice';
      practiceBtn.addEventListener('click', function(ev){
        ev.stopPropagation();
        ev.preventDefault();
        if (!pat || !(pat.moves||[]).length){
          showNotice('This pattern is empty. Please add some moves first.', 'Empty pattern');
          return;
        }

        window.PracticeConfig = window.PracticeConfig || {};
        window.PracticeConfig.selectedLine = {
          size:  pat.size || 19,
          rootAB: Array.isArray(pat.rootAB) ? pat.rootAB.slice() : [],
          rootAW: Array.isArray(pat.rootAW) ? pat.rootAW.slice() : [],
          moves:  pat.moves.map(function(m){ return { x:m.x, y:m.y, color:m.color }; })
        };

        savePracticeConfig();

        var lvlOverlayEl = document.getElementById('level-overlay');
        if (lvlOverlayEl){
          applyTierGateOnLevelOverlay();
          lvlOverlayEl.style.display = 'flex';
        } else {
          window.PracticeConfig.level = 2;
          savePracticeConfig();
          window.location.href = "../practice-board/practice-board.html";
        }
      });

      var removeBtn = document.createElement('span');
      removeBtn.className = 's-btn s-btn-danger';
      removeBtn.textContent = 'Remove';
   removeBtn.addEventListener('click', function(ev){
  ev.stopPropagation();
  ev.preventDefault();
  showRemoveToast(pat, displayName);
});


      cta.appendChild(practiceBtn);
      cta.appendChild(removeBtn);

      meta.appendChild(title);
      meta.appendChild(cta);
      card.appendChild(thumb);
      card.appendChild(meta);
      listEl.appendChild(card);

      renderOwnThumb(thumb, pat);

      card.addEventListener('click', function(){
        practiceBtn.click();
      });
    });
  }

  /* Tier gating reused for Level overlay (use shared GoTier bridge if present) */
  var TierAPI = window.GoTier || window.Tier || {
    get: function(){
      try { return (localStorage.getItem('go_tier') || 'free').toLowerCase(); }
      catch(_) { return 'free'; }
    }
  };

  function getTier(){
    try {
      if (TierAPI && typeof TierAPI.get === 'function'){
        return String(TierAPI.get() || 'free').toLowerCase();
      }
    } catch(_){}
    return 'free';
  }

  function isPro(){
    return getTier() === 'pro';
  }

  function applyTierGateOnLevelOverlay(){
    var proLocked = !isPro();
    document.querySelectorAll('#level-overlay .level-card').forEach(function(btn){
      var lvl = +(btn.getAttribute('data-level') || 0);
      btn.setAttribute('aria-disabled', (proLocked && lvl >= 4) ? 'true' : 'false');
    });
  }

  // When GoTier.set() changes the plan, refresh level gating in-place
  window.addEventListener('tier:changed', function(){
    applyTierGateOnLevelOverlay();
  });


  /* Level overlay wiring */
  var lvlOverlay = document.getElementById('level-overlay');
  var lvlBack    = lvlOverlay ? document.getElementById('level-back') : null;

  if (lvlOverlay){
    lvlOverlay.addEventListener('click', function(e){
      var card = e.target.closest('.level-card');
      if (!card) return;

      if (card.getAttribute('aria-disabled') === 'true'){
        if (window.OwnShowNotice){
          window.OwnShowNotice('Levels 4 and 5 are part of Joseki Master Pro.', 'Pro feature');
        }
        return;
      }

      var lvl = parseInt(card.getAttribute('data-level') || '2', 10) || 2;
      window.PracticeConfig = window.PracticeConfig || {};
      window.PracticeConfig.level = lvl;
      savePracticeConfig();

      if (!window.PracticeConfig.selectedLine){
        console.warn('[OwnPatterns] Level picked but no selectedLine in PracticeConfig; not opening board.');
        return;
      }

      window.location.href = "../practice-board/practice-board.html";
    });

    if (lvlBack){
      lvlBack.addEventListener('click', function(){
        lvlOverlay.style.display = 'none';
      });
    }
  }

  /* Public API */
  if (!window.GoOwnPatterns || !window.GoOwnPatterns.__ready){
    window.GoOwnPatterns = {
      open: function(){
        hideNotice();
        hideRemoveToast();
        renderList();
        show(overlay);
      },
      close: function(){
        hide(overlay);
        hide(editor);
        if (lvlOverlay) lvlOverlay.style.display='none';
        hideNotice();
        hideRemoveToast();
        resetAll();
      },
      openCreate: function(){
        hideNotice();
        hideRemoveToast();
        hide(overlay);
        show(editor);
        ensureBoard(function(){
          resetAll();
          fitSoon();
        });
        requestAnimationFrame(fitSoon);
      },
      __ready: true
    };
  }

  /* Wiring */
  if (openBtn){
    openBtn.addEventListener('click', function(){
      window.GoOwnPatterns.openCreate();
    });
  }

  if (backTop){
    backTop.addEventListener('click', function(){
      window.GoOwnPatterns.close();
      if (window.GoMenu && typeof window.GoMenu.open === 'function'){
        window.GoMenu.open();
      }
    });
  }

  if (backEd){
    backEd.addEventListener('click', function(){
      disableOwnDockMode();
      if (isFullscreen) smoothZoomOutAndExit();

      hide(editor);
      hideNotice();
      hideRemoveToast();
      resetAll();
      renderList();
      show(overlay);
    });
  }


  if (undoBtn){
    undoBtn.addEventListener('click', function(){
      if (!moves.length || isNoticeOpen()) return;
      var m=moves.pop();
      grid[m.y][m.x]=null;
      if (Array.isArray(m.captured)){
        m.captured.forEach(function(s){ grid[s.y][s.x]=s.color; });
      }
      koPoint = m.prevKo ? { x:m.prevKo.x, y:m.prevKo.y } : null;
      last = moves.length ? { x:moves[moves.length-1].x, y:moves[moves.length-1].y } : null;
      turn = m.color;
      redraw();
    });
  }

  if (resetBtn){
    resetBtn.addEventListener('click', function(){
      if (!isNoticeOpen()) resetAll();
    });
  }
if (passBtn){
  passBtn.addEventListener('click', function(){
    if (isNoticeOpen()) return;

    // Treat pass as an editor helper:
    // it flips the turn so you can play the same color again.
    koPoint = null; // a pass counts as an intervening move for ko purposes here
    turn = (turn === 'B') ? 'W' : 'B';
  });
}

  if (saveBtn){
    saveBtn.addEventListener('click', function(){
      if (isNoticeOpen()) return;
      if (!moves.length){
        showNotice('Add at least one move to save a pattern.', 'Add a move');
        return;
      }
      var S = SIZE;
      function pp(m){
        var L="ABCDEFGHJKLMNOPQRST".slice(0,Math.min(19,S));
        return (L[m.x]||String(m.x))+(S-m.y);
      }
      var title = 'Pattern: ' + moves.slice(0,3).map(pp).join(' → ') + (moves.length>3 ? ' …' : '');
      var items = loadPatterns();
      var pat = {
        id: 'own-' + Date.now(),
        title: title,
        createdAt: new Date().toISOString(),
        size: SIZE,
        rootAB: [],
        rootAW: [],
        moves: moves.map(function(m){ return { x:m.x, y:m.y, color:m.color }; })
      };
      items.unshift(pat);
      savePatterns(items);
      resetAll();
      hide(editor);
      renderList();
      show(overlay);
    });
  }

  // Esc handling for whole page (back to menu if root overlay open)
  window.addEventListener('keydown', function(e){
    if (e.key !== 'Escape') return;

    if (lvlOverlay && lvlOverlay.style.display !== 'none'){
      lvlOverlay.style.display = 'none';
      return;
    }

    if (overlay && overlay.style.display !== 'none' && !isNoticeOpen()){
      window.GoOwnPatterns.close();
      if (window.GoMenu && typeof window.GoMenu.open === 'function'){
        window.GoMenu.open();
      }
    }
  });

})();
</script>

<!-- Auto-open My Patterns overlay on page load -->
<script>
  window.addEventListener('load', function(){
    if (window.GoOwnPatterns && typeof window.GoOwnPatterns.open === 'function'){
      window.GoOwnPatterns.open();
    }
  });
</script>

</body>
</html>



